
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>5.1.1. 贪心法(I) 背包问题 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="5.1.2. 贪心法(II) 复杂任务调度" href="412_greedy_complex_scheduling.html" />
    <link rel="prev" title="5.1. 贪心法" href="../410_greedy.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="412_greedy_complex_scheduling.html" title="5.1.2. 贪心法(II) 复杂任务调度"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="../410_greedy.html" title="5.1. 贪心法"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../400_basic_algo_design.html" ><span class="section-number">5. </span>算法设计方法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../410_greedy.html" accesskey="U"><span class="section-number">5.1. </span>贪心法</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.1.1. 贪心法(I) 背包问题</a><ul>
<li><a class="reference internal" href="#id1">5.1.1.1. 部分背包问题</a></li>
<li><a class="reference internal" href="#id2">5.1.1.2. 0-1背包问题初探</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="../410_greedy.html"
                        title="上一章"><span class="section-number">5.1. </span>贪心法</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="412_greedy_complex_scheduling.html"
                        title="下一章"><span class="section-number">5.1.2. </span>贪心法(II) 复杂任务调度</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch04/sec01/411_greedy_bag_problems.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="i">
<h1><span class="section-number">5.1.1. </span>贪心法(I) 背包问题<a class="headerlink" href="#i" title="永久链接至标题">¶</a></h1>
<p>背包问题是一类非常经典的算法问题，它是要把 <span class="math notranslate nohighlight">\(n\)</span> 种不同物品有选择地放进一个背包中，物品有各自的重量 <span class="math notranslate nohighlight">\(\{w_1,w_2,\dots,w_n\}\)</span> 和价值 <span class="math notranslate nohighlight">\(\{v_1,v_2,\dots,v_n\}\)</span>，背包有最大承重限制 <span class="math notranslate nohighlight">\(W\)</span>，我们要选择一个最优的物品组合放入背包中，使得背包中物品的总价值 <span class="math notranslate nohighlight">\(V\)</span> 最大。通常这些重量和价值都采用正整数来表示。</p>
<p>常见的背包问题有<strong>部分背包问题</strong>、<strong>0-1背包问题</strong>、<strong>完全背包问题</strong>和<strong>多重背包问题</strong>。其中前两种是最常见的，后两种是0-1背包问题的变种。这里面只有部分背包问题是贪心法可解的。其他三种都不适用贪心法，尽管它们都有一种可行的伪多项式时间算法，但实际上它们甚至都是NP难题。下面我们分别对部分背包问题的贪心算法和0-1背包问题的贪心法不可解性质进行介绍。至于0-1背包问题及其他两种变种的伪多项式时间算法，是一种必学、常考的经典动态规划算法，我们将在讲述动态规划的章节中进行介绍。</p>
<div class="section" id="id1">
<h2><span class="section-number">5.1.1.1. </span>部分背包问题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>在部分背包问题中，所有的物品都是可以拆分的，最小可以拆到重量为1。部分背包问题的另一种常见形式是不同浓度的溶液混合，使混合后的溶液浓度最大化。</p>
<p>部分背包问题是可以用贪心法求解的，但是要正确选择贪心策略。对于背包问题，选择物品的策略有三种：一是依据重量选择，重量越小的越优先；二是依据价值选择，价值越大的越优先；三是依据单位重量的价值选择，单位重量的价值越大的越优先。</p>
<p>按照生活经验，直观地就会选择第三种贪心策略，按单位价值进行从大到小的选择（似乎用混合溶液的提法更容易直观理解）。那么如何用精准的数学语言来证明它呢？这个证明要利用到部分背包问题的一个特殊性质，背包总是能够被塞满，因此最终放入背包的物品的重量总和恒等于 <span class="math notranslate nohighlight">\(W\)</span>。为了证明这个贪心策略是能够得出正确的最优解的，我们首先要看一下怎么应用它。</p>
<p>首先计算出每一种物品的单位价值 <span class="math notranslate nohighlight">\(\rho_i=v_i/w_i\)</span>，然后对它们进行排序，得到一个有序的序列 <span class="math notranslate nohighlight">\(\rho_{i_1}\le\rho_{i_2}\le\dots\le\rho_{i_n}\)</span>。这里的 <span class="math notranslate nohighlight">\(\{i_1,i_2,\dots,i_n\}\)</span> 是物品编号 <span class="math notranslate nohighlight">\(\{1,2,\dots,n\}\)</span> 的一个排列。</p>
<p>例如我们的背包总承重限制为 <span class="math notranslate nohighlight">\(W=6\)</span>，共有四种物品，它们的编号、重量、价值和计算得到的单位价值（保留1位小数）如下表：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>物品编号 <span class="math notranslate nohighlight">\(i\)</span></p></th>
<th class="head"><p>重量 <span class="math notranslate nohighlight">\(w_i\)</span></p></th>
<th class="head"><p>价值 <span class="math notranslate nohighlight">\(v_i\)</span></p></th>
<th class="head"><p>单位价值 <span class="math notranslate nohighlight">\(\rho_i\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>7</p></td>
<td><p>2.3</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>1.0</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>8</p></td>
<td><p>2.0</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>5</p></td>
<td><p>9</p></td>
<td><p>1.8</p></td>
</tr>
</tbody>
</table>
<p>于是我们可以得到一个依单位价值从小到大的物品排列 <span class="math notranslate nohighlight">\(\{2,4,3,1\}\)</span>。</p>
<p>下一步就是应用单位价值大者优先的贪心策略来选取放入背包的物品。从具有最大单位价值 <span class="math notranslate nohighlight">\(\rho_{i_n}\)</span> 的物品 <span class="math notranslate nohighlight">\(i_n\)</span> 开始，逐个从后向前选取物品，如果背包剩余的可装重量不足以全部装下当前选择的物品了，那么就从该物品中拆分出恰好等于背包剩余承重的部分来塞满整个背包。如此进行贪心选择，最终得到的解 <span class="math notranslate nohighlight">\(\{i_n,i_{n-1},\dots,i_k\},(1 \le k \le n)\)</span> 就是最优解。此解中的物品重量总和一定为 <span class="math notranslate nohighlight">\(W\)</span>，其中物品 <span class="math notranslate nohighlight">\(i_n,i_{n-1},\dots,i_{k+1}\)</span> 全部装入背包，最后一项物品 <span class="math notranslate nohighlight">\(i_k\)</span> 装入背包的重量为 <span class="math notranslate nohighlight">\(w^\prime_{i_k}\le w_{i_k}\)</span>，所以可以计算出这个解得到的背包中物品总价值为 <span class="math notranslate nohighlight">\(V=v_{i_n}+v_{i_{n-1}}+\cdots+v_{i_{k+1}}+w^\prime_{i_k}\times\rho_{i_k}\)</span>。</p>
<p>例如在我们上面这个例子中，按照这个策略来取物品，得到的解依次包含物品 <span class="math notranslate nohighlight">\(\{1,3\}\)</span>，其中物品 <span class="math notranslate nohighlight">\(3\)</span> 所取的重量为 <span class="math notranslate nohighlight">\(3\)</span>，所以解的总价值为 <span class="math notranslate nohighlight">\(7+3\times2=13\)</span>。</p>
<p>这个贪心解一定是最优解吗？答案是肯定的。我们可以这样想，根据这个策略得到的解，包里所装的物品有 <span class="math notranslate nohighlight">\(\{i_n,i_{n-1},\dots,i_k\}\)</span>，未装入包里的物品有 <span class="math notranslate nohighlight">\(\{i_k,i_{k-1},\dots,i_1\}\)</span>。因为物品编号的排列 <span class="math notranslate nohighlight">\(\{i_1,i_2,\dots,i_n\}\)</span> 满足单位价值有序：<span class="math notranslate nohighlight">\(\rho_{i_1}\le\rho_{i_2}\le\dots\le\rho_{i_n}\)</span>，所以任何一种未装入背包的物品的单位价值都不会高于任何一种已装入背包的物品的单位价值，即对于任意的 <span class="math notranslate nohighlight">\(1\le p\le k\)</span> 和 <span class="math notranslate nohighlight">\(k\le q\le n\)</span>，<span class="math notranslate nohighlight">\(\rho_{i_p}\le\rho_{i_q}\)</span> 恒成立。而部分背包问题的特性使得我们总要保持解中所有物品的总重量之和恒为背包总承重量 <span class="math notranslate nohighlight">\(W\)</span> 不变，使得如果要对解进行变动，必然是要用未放入背包的物品去等重量地替换已经放入背包里的物品。假使我们使用任意重量 <span class="math notranslate nohighlight">\(w\)</span> 的任意未放入背包的物品 <span class="math notranslate nohighlight">\(i_p\)</span>，用它来替换等重的已放入背包物品 <span class="math notranslate nohighlight">\(i_q\)</span>，那么从解中换出去的价值为 <span class="math notranslate nohighlight">\(w\cdot\rho_{i_q}\)</span>，换进来的价值为 <span class="math notranslate nohighlight">\(w\cdot\rho_{i_p}\)</span>，因为 <span class="math notranslate nohighlight">\(\rho_{i_p}\le\rho_{i_q}\)</span>，所以这样的交换必然是得不偿失，不可能使解的总价值得到提升，只可能下降。</p>
<p>到此就证明了我们得到的贪心解，是已经不可能通过任何交换来使其价值更大了，它就是最优解。有兴趣的可以用我们上面的示例数据来试一试，看看能不能找出总价值比 <span class="math notranslate nohighlight">\(13\)</span> 更大的解来。</p>
<p>部分背包问题的贪心算法就讲解完了，但是你能编出这样一个程序来吗？事实上要编出这个程序来还是有一定难度的，难度在于计算和排序的技巧，希望大家能够尝试一下。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>要编写这个程序，第一个要注意的是单位价值不一定是整数，但是考虑到浮点数的精度问题，在排序时最好不要用浮点数进行比较，那么就需要将小数比大小改成分数比大小，怎么办？第二个难点是对单位价值进行排序的时候不能使用普通的内排序方法直接将单位价值数组进行排序，而是要对它们的编号进行排序，即要用外排序。而我们学过的外排序方法比如桶排、计数排都是针对整数的排序，并不适合分数或小数，怎么办？一种方法是可以用数据结构来帮助我们。</p>
<p>用一个数据结构来组织数据，而不是简单的用几个数组，可以使用内排序而且使得排完之后每个元素还都记得自己的编号。例如我们可以定义这样一个自定义结构来表示物品（Stuff）：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Stuff</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>         <span class="c1">// 编号</span>
        <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>          <span class="c1">// 重量</span>
        <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>          <span class="c1">// 价值</span>
<span class="p">};</span>
</pre></div>
</div>
<p>这样，我们可以自行设计一种用来比较两个分数大小的比较函数，用它来对物品数组直接进行内排序。排完之后，数组里的每一个元素虽然位置改变了，但它们还在自己的数据结构里储存着自己的物品编号。这样就避免了可能很复杂的分数外排序，甚至可以直接使用algorithm库的 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 函数来完成排序，所要做的只是提供一个可以比较 <code class="docutils literal notranslate"><span class="pre">Stuff</span></code> 型变量大小（实际上就是 <code class="docutils literal notranslate"><span class="pre">v/w</span></code> 的分数大小）的比较函数而已。</p>
</div>
</div>
<div class="section" id="id2">
<h2><span class="section-number">5.1.1.2. </span>0-1背包问题初探<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>0-1背包问题是最为经典的背包问题。所谓“0-1”的意思就是指物品不能拆分，要么不放入背包（即放入0个），要么放入背包（即放入1个），非0即1。其他规则和目标与部分背包问题全无二致。0-1背包问题还有一些更加复杂的变种，比较常见的有完全背包问题和多重背包问题。完全背包问题的变化是每种物品都有无限多个，可以选择0个或任意数量个放入背包，但是物品不能拆分。多重背包问题是每一种物品都有各自的总数量 <span class="math notranslate nohighlight">\(q_i\ge 1\)</span>，可以选择0个或者最多 <span class="math notranslate nohighlight">\(q_i\)</span> 个放入背包。事实上只要能解开0-1背包问题，这两种变种的解法也就相应产生了。0-1背包问题是出了部分背包问题以外所有其他背包问题变种的源头。</p>
<p>现在有一个坏消息和一个好消息。坏消息是：<strong>0-1背包问题是NP难题</strong>；好消息是：<strong>它有一个很好用的</strong> <span class="math notranslate nohighlight">\(O(nW)\)</span> <strong>时间的动态规划解法</strong>，其中 <span class="math notranslate nohighlight">\(W\)</span> 是背包总承重，<span class="math notranslate nohighlight">\(n\)</span> 是物品种数。听上去有点矛盾，其实这个动态规划解法并不是它看上去的那样是多项式时间的，总承重 <span class="math notranslate nohighlight">\(W\)</span> 的<strong>值</strong>作为一个因数的存在使得它事实上还是一个指数时间算法，只不过这个指数增长不快，在绝大多数数据范围内它运行得还是很有效的。</p>
<p>我们在这里不打算详细介绍0-1背包问题的动态规划解法，这个算法留到后面动态规划的部分再讲。现在我们只是来初窥一下这个目前为止第一次遇到的NP难题，看看为什么贪心法对它不起作用。</p>
<p>通过前面几个简单的例子已经可以看出来，想知道一个问题能不能用贪心法，贪心策略靠不靠谱，往往首先是来自于经验和直觉。但是也会有一些问题，会让人迷惑，对自己的经验和直觉没那么有信心。这种时候有两个选择，一是设法去证明贪心策略正确，二是设法去证伪。而证伪往往比证明简单得多，只要你能找到一个反例，证伪就成功了。证明则需要严密的数学和逻辑推理。从前面两个例子也可以看出，要严格证明一个最简单的贪心策略都可能不是那么简单的。</p>
<p>0-1背包问题的证伪就很简单，我们前面举的那个示例就是一个非常好的反例素材，让我们再来看一看它的数据：背包总承重限制为 <span class="math notranslate nohighlight">\(W=6\)</span>，共有四种物品，它们的编号、重量、价值和计算得到的单位价值（保留1位小数）如下：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>物品编号 <span class="math notranslate nohighlight">\(i\)</span></p></th>
<th class="head"><p>重量 <span class="math notranslate nohighlight">\(w_i\)</span></p></th>
<th class="head"><p>价值 <span class="math notranslate nohighlight">\(v_i\)</span></p></th>
<th class="head"><p>单位价值 <span class="math notranslate nohighlight">\(\rho_i\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>7</p></td>
<td><p>2.3</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>1.0</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4</p></td>
<td><p>8</p></td>
<td><p>2.0</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>5</p></td>
<td><p>9</p></td>
<td><p>1.8</p></td>
</tr>
</tbody>
</table>
<p>让我们来逐一尝试三种贪心策略：</p>
<ol class="arabic simple">
<li><p>重量轻者优先：放入背包的物品依次将是 <span class="math notranslate nohighlight">\(2\)</span> 号和 <span class="math notranslate nohighlight">\(1\)</span> 号，总重量 <span class="math notranslate nohighlight">\(2+3=5\)</span>，产生的总价值为 <span class="math notranslate nohighlight">\(2+7=9\)</span>；</p></li>
<li><p>价值大者优先：放入背包的物品将只有 <span class="math notranslate nohighlight">\(4\)</span> 号，重量 <span class="math notranslate nohighlight">\(5\)</span>，产生的总价值为 <span class="math notranslate nohighlight">\(9\)</span>；</p></li>
<li><p>单位价值高者优先：这次放入背包的物品依次为 <span class="math notranslate nohighlight">\(1\)</span> 号和 <span class="math notranslate nohighlight">\(2\)</span> 号，因为放入物品 <span class="math notranslate nohighlight">\(1\)</span> 后剩余背包容量减少为 <span class="math notranslate nohighlight">\(3\)</span>，单位价值第二高的物品 <span class="math notranslate nohighlight">\(3\)</span> 已经放不下了，因此跳过，接下来还可以放下物品 <span class="math notranslate nohighlight">\(2\)</span>，然后就再也放不下任何别的物品了，总重量为 <span class="math notranslate nohighlight">\(3+2=5\)</span>，总价值为 <span class="math notranslate nohighlight">\(7+2=9\)</span>。</p></li>
</ol>
<p>但是，这么简单的数据用人脑一看就可以发现，选择物品 <span class="math notranslate nohighlight">\(2\)</span> 和物品 <span class="math notranslate nohighlight">\(3\)</span> 可以得到更大的价值，二者重量总和为 <span class="math notranslate nohighlight">\(2+4=6\)</span>，恰好塞满背包，总价值为 <span class="math notranslate nohighlight">\(2+8=10\)</span>，比所有三种贪心算法得到的解都更优！</p>
<p>问题就出在0-1背包问题不能拆分物品，所以无论用什么贪心策略，都有可能使背包没有完全塞满，或者还塞的不够满。而真正的最优解有可能比它们更加能充分利用背包的承重量，把限制条件用得更彻底。这种如何合理摆布从而使得约束条件被充分利用的思路是一种整体思路，需要通盘考虑多个因素。很不巧，贪心法却是一种“只看眼前利益”的方法，它天生目光短浅，没有通盘考虑的能力。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="412_greedy_complex_scheduling.html" title="5.1.2. 贪心法(II) 复杂任务调度"
             >下一页</a> |</li>
        <li class="right" >
          <a href="../410_greedy.html" title="5.1. 贪心法"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../400_basic_algo_design.html" ><span class="section-number">5. </span>算法设计方法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../410_greedy.html" ><span class="section-number">5.1. </span>贪心法</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>