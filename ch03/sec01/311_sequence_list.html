
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>4.1.1. 顺序表 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="4.1.2. 高精度整数算法(I) 数据的表示" href="312_big_int_1.html" />
    <link rel="prev" title="4.1. 线性表" href="../310_linear_list.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="312_big_int_1.html" title="4.1.2. 高精度整数算法(I) 数据的表示"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="../310_linear_list.html" title="4.1. 线性表"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../300_basic_data_structure.html" ><span class="section-number">4. </span>基础数据结构</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../310_linear_list.html" accesskey="U"><span class="section-number">4.1. </span>线性表</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.1.1. 顺序表</a><ul>
<li><a class="reference internal" href="#stlvector">4.1.1.1. STL的vector容器</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="../310_linear_list.html"
                        title="上一章"><span class="section-number">4.1. </span>线性表</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="312_big_int_1.html"
                        title="下一章"><span class="section-number">4.1.2. </span>高精度整数算法(I) 数据的表示</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch03/sec01/311_sequence_list.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">4.1.1. </span>顺序表<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p><strong>顺序表</strong>，全名<strong>顺序存储结构</strong>，是线性表的一种。和所有线性表一样，它采用位置和元素一一对应的方式组织数据。在实际存储时，顺序表会先在内存中开辟一块足够存放所有元素的连续的空间，然后把所有元素按其序号依次紧挨着存放，彼此之间不允许出现空隙。由于顺序表并不要求它开辟的所有空间全部填满数据，因此还需要一个额外的表示当前表中有多少个元素的长度变量，通常会叫做 <code class="docutils literal notranslate"><span class="pre">length</span></code> 或 <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
<p>例如，数列 <span class="math notranslate nohighlight">\(\{a_1,a_2,a_3,a_4,a_5\}\)</span> 在用顺序表来表示的时候，实际的存储状态如下图所示。</p>
<img alt="../../_images/311_sequence_list.png" src="../../_images/311_sequence_list.png" />
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>图中每个元素上方的数字是它的序号，请千万要熟悉计算机语言中总是从0开始计数的设定。size指示当前表中的元素数量，因此等于5，而由于表元素从0开始计数，所以最后一个元素的序号是size-1，也就是4，而size=5刚好指向表尾后的下一个空位。</p>
</div>
<p>我们可以发现，顺序表极其天然的适合用C++数组来实现。事实上在许多算法程序里，为了简化编程，顺序表往往就是一个普通的数组加一个表示数据量的整型变量而已。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>这样一句简单的变量声明语句就足以构造出一张最简单的顺序表。由于顺序表具有从头开始挨个存放元素，并且有一个长度变量指示元素总数的特点，我们甚至不需要初始化数组元素。当然了，如果程序中要用到多张顺序表，每一张都这样定义就会让代码变得很难看。因此一般我们至少要用一个结构来把存放元素的数组和长度变量封装起来，形成一个定义完整的顺序表数据类型。这是实现一个定义完好的数据结构的第一步，<strong>整合数据</strong>。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">List</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>要知道虽然数据结构和算法是紧密结合的，但毕竟是两种不同的课程。二者在研究的目标、方法和技巧上有着诸多不同。正如我们刚看到的，如果重点是算法的设计与实现，那么有时候我们可以不拘泥于其用到的数据结构是否完美实现。但如果是学习数据结构，那么我们会很注重数据结构定义和实现的完整性，主要有以下几个关注点：</p>
<ul class="simple">
<li><p>所有数据和辅助变量是否有完整的封装，一般用一个或几个结构体来完成数据的封装。</p></li>
<li><p>所需的最基本的功能是否都已经实现，传统的方式是定义一系列对封装了数据结构的结构体变量进行操作的函数，这也是大多数C语言数据结构教科书使用的方式；C++的方式则是给封装了数据结构的结构体（或者类）增加<strong>成员函数</strong>。</p></li>
</ul>
<p>我们采用给结构体增加成员函数的方式来同时封装数据和功能。</p>
</div>
<div class="admonition- admonition">
<p class="admonition-title">说明</p>
<p>由于本章是数据结构部分的内容，所以本章我们将展示怎样利用C++ struct来实现一系列封装完好的数据结构。在学会了每一种数据结构的原理之后，实际算法编程时往往不需要如此完好地去手打代码自己实现它们，而是有两种变通的方法：一是根据程序需要自己实现一个简化版；二是利用C++ STL库的容器类，我们对此也会进行说明。</p>
</div>
<p><strong>顺序表的初始化</strong></p>
<p>定义了结构 <code class="docutils literal notranslate"><span class="pre">List</span></code> 之后，如果我们在程序里需要用到顺序表，那么我们就声明一个 <code class="docutils literal notranslate"><span class="pre">List</span></code> 型变量并对其进行初始化。顺序表的初始化只需要做一件事：把长度设为0。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">List</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">},</span> <span class="mi">0</span><span class="p">};</span>     <span class="c1">// 采用初始化结构变量和数组的方式进行初始化</span>

<span class="n">List</span> <span class="n">l2</span><span class="p">;</span>             <span class="c1">// 也可以像这样分两句进行，但在开始使用这张表前一定要初始化好</span>
<span class="n">l2</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>但是我们可以用C++风格来给List结构增加一个<strong>构造器</strong>（constructor），这样每次声明一个List结构的变量时就会自动调用构造器来完成必要的初始化工作。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">List</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

<span class="hll">	<span class="n">List</span><span class="p">()</span> <span class="p">{</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span><span class="p">};</span>
</pre></div>
</div>
<p>现在我们只需要声明变量就可以了，在变量被生成出来的时候构造器会自动被调用并执行其中的代码。现在生成一张顺序表时就不需要自己去显式地初始化它了，单纯地声明变量即可。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">List</span> <span class="n">l3</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>构造器有点类似一个函数，只不过它没有返回类型，所以也无需返回任何东西。如果它完全是一个顺序运行的代码块，那么甚至最后连 <code class="docutils literal notranslate"><span class="pre">return;</span></code> 语句都不需要。</p>
<p>构造器也可以有参数表，接收一些参数用来初始化结构的成员变量。那样的话我们在声明变量时在变量名后面像调用函数一样加上参数表就可以了，类似于 <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">l(3);</span></code> 这样的形式。</p>
<p>C++甚至允许给一个结构定义多个构造器，只要每个构造器的参数表不同即可。在声明变量时会自动按照参数表来匹配应该调用哪一个构造器。</p>
</div>
<p><strong>插入元素</strong></p>
<p>向顺序表里插入元素要符合以下规则：</p>
<ol class="arabic simple">
<li><p>指定位置：插入时要指定新元素插入表中的位置，这个位置要大于等于0，小于等于当前表中元素的个数。当插入位置为0时新元素放在表头，当插入元素等于当前表中元素数量时新元素放在表尾。</p></li>
<li><p>保持次序：新元素插入后，位于它之前的元素保持位置不变，从插入点开始的所有后序元素保持原有次序依次向后移动一个位置。</p></li>
<li><p>长度限制：一般情况下基于数组构建的顺序表不能长度超限，基础数组的长度就是整张表的长度限制。当然我们可以利用动态内存技术来实现可自动调节最大长度的顺序表，例如STL库的vector容器类就是这样一种顺序表。但是我们在学习数据结构的时候一般就不讨论这种技术了，毕竟首先要掌握的是原理，而且算法编程也很少用到需要动态调整长度的线性表，如果需要一般改用链表，或者更加推荐直接使用STL库提供的现成容器类型。</p></li>
</ol>
<img alt="../../_images/311_seq_list_insert.png" src="../../_images/311_seq_list_insert.png" />
<p>可以看出，插入位置在表尾时效率最高，<span class="math notranslate nohighlight">\(O(1)\)</span>；在表头时效率最低，<span class="math notranslate nohighlight">\(O(n)\)</span>。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>通常在实现顺序表的插入功能时，我们会把不在合理范围内的插入位置默认处理为插入在表尾。同时，鉴于插入在表尾效率最高，我们更喜欢新元素都按次序从前往后添加在表尾，所以往往我们会利用C++函数的默认参数，把插入位置做成默认参数，参数值为-1。这样的话如果不提供插入位置，就是插在表尾。</p>
<p>另外，我们会提供一个返回值，正常情况下就返回新元素实际被插入的位置。当出现长度超限错误时，返回一个特殊的值（错误码），比如这种场景下最常见的是返回-1。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">List</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">List</span><span class="p">()</span> <span class="p">{</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="hll">	<span class="kt">int</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class="hll">	<span class="p">{</span>
</span><span class="hll">		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">MAXN</span><span class="p">)</span>
</span><span class="hll">			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="hll">		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
</span><span class="hll">			<span class="n">pos</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span><span class="hll">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span><span class="hll">			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="hll">		<span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span><span class="hll">		<span class="n">size</span><span class="o">++</span><span class="p">;</span>
</span><span class="hll">		<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
</span><span class="hll">	<span class="p">}</span>
</span><span class="p">};</span>
</pre></div>
</div>
<p><strong>删除元素</strong></p>
<p>从顺序表里删除元素要遵循的规则和插入元素时很类似，只是方向相反，我们采用的实现技巧也很类似，同时一般的惯例是会返回被删除元素的值。用示意图和代码来进行说明，文字不再赘述，请自行思考理解。</p>
<img alt="../../_images/311_seq_list_remove.png" src="../../_images/311_seq_list_remove.png" />
<p>和插入元素的情形类似，删除表尾元素效率最高，<span class="math notranslate nohighlight">\(O(1)\)</span>；删除表头元素时效率最低，<span class="math notranslate nohighlight">\(O(n)\)</span>。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">List</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">List</span><span class="p">()</span> <span class="p">{</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

	<span class="kt">int</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">MAXN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">size</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>
	
<span class="hll">	<span class="kt">int</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class="hll">	<span class="p">{</span>
</span><span class="hll">		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
</span><span class="hll">			<span class="n">pos</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="hll">		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
</span><span class="hll">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="hll">			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="hll">		<span class="n">size</span><span class="o">--</span><span class="p">;</span>
</span><span class="hll">		<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
</span><span class="hll">	<span class="p">}</span>
</span><span class="p">};</span>
</pre></div>
</div>
<p><strong>获取元素</strong></p>
<p>获取元素，就是按位置访问数组里的具体元素。你可能会惊讶，直接访问结构变量里面的数组不就成了吗？当然是可以的，而且在许多算法编程里也确实这样干了，但是数据结构的规范告诉我们，这是不允许的。<code class="docutils literal notranslate"><span class="pre">data</span></code> 数组是构成顺序表 <code class="docutils literal notranslate"><span class="pre">List</span></code> 的底层组件，并不是顺序表本身。按照数据封装的基本要求，外部代码是不可以直接访问底层组成部分的。直接访问底层会破坏数据结构的封装性，最直接的问题就是缺失了位置有效性检查，外部代码通过直接访问底层数组，有可能访问到顺序表的空闲位置，也就是所有实际存在的元素后面的位置，也有可能访问了负数或者超限的位置。这些位置是否有效应该有一个地方统一检查，那就是获取元素的成员函数。</p>
<p>事实上，严格的数据封装标准甚至连当前长度这个变量 <code class="docutils literal notranslate"><span class="pre">size</span></code> 都是不允许直接读取的，因为允许直接读取就意味着外部代码也允许直接修改它，这就造成了很大的不安全性。所以如果是严格的数据封装，我们往往还需要提供一个获取当前表中元素个数的函数，例如 <code class="docutils literal notranslate"><span class="pre">size()</span></code> 函数。STL库的所有容器类，包括顺序表容器 <code class="docutils literal notranslate"><span class="pre">vector</span></code> 都是这样做的。</p>
<p>也许你会问，但是提供这样的函数还是不能阻止不遵守惯例的坏习惯程序员在结构外部的代码里直接访问啊？其实C++语言还提供了一套完整的<strong>成员可见性</strong>机制用来从技术角度真正限制哪些成员可以在外部直接访问，哪些则不行。但在算法编程里，我们都提倡通过惯例，养成好习惯来自己管住自己。所以我们也不准备介绍它。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>成员可见性是面向对象技术的核心，早期的面向对象编程语言都提供了完善的可见性机制。但是近几年随着JavaScript、Python等脚本语言的兴起，以及<strong>惯例高于设置</strong>的新一代编程哲学的兴起，现代较新的编程语言都放弃了严格的可见性机制，而是改由程序员通过遵循惯例来进行自我约束。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">List</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">List</span><span class="p">()</span> <span class="p">{</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

	<span class="kt">int</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">MAXN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">size</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="kt">int</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">size</span><span class="o">--</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>

<span class="hll">	<span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
</span><span class="hll">	<span class="p">{</span>
</span><span class="hll">		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
</span><span class="hll">			<span class="k">throw</span> <span class="s">&quot;pos error&quot;</span><span class="p">;</span>
</span><span class="hll">		<span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
</span><span class="hll">	<span class="p">}</span>
</span><span class="p">};</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>我们的代码里使用了C++的抛异常机制来处理位置参数错误的情况。因为在这里如果位置参数不正确，我们不能简单地处理为默认返回最后一个元素了。当访问元素时，最后一个并没有什么特殊性，不能默认返回它。</p>
<p>C++异常机制是工程编程的手段，整个异常处理体系相当复杂。但是适当应用一些最简单的异常技术往往会给调试程序带来极大的帮助。请自行编制一段测试代码来触发这个错误的发生试试会发生什么情况，另外也可以自行查阅相关书籍和网站学习一下C++异常机制的基本用法。</p>
</div>
<p>大多数算法编程课程里不会使用这样的代码来处理传入的位置参数不正确的情况，一般情况下算法书会这样处理这个问题：要么输出一段出错信息，要么返回一个不可能是元素值的特殊值，要么干脆默认参数不会有错。我们这里的 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 函数用一种比较特别的方法来处理，当遇到传入的位置参数不正确时，抛出（throw）一个异常，这时候程序运行会被强制终止，屏幕上会输出一段出错消息。当然了，这远远不是C++异常处理机制真正的能力，我们并不打算在算法编程时使用完整的异常处理机制。异常机制的目的是确保程序运行出现无法预测的异常时能得到妥善处置，这时属于工程编程领域的技术。我们这里借用了异常处理机制中最简单的一点小技巧，只是为了方便程序调试和确保异常发生时 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 函数不会不知所措。有点类似<strong>断言</strong>（assert），但是比使用断言要简单一些。</p>
<p><strong>算法编程的实用方法</strong></p>
<p>实际上，在算法编程时一般不需要也不会像学习数据结构时那样自己去实现一个完善的顺序表。通常用两种方法，当程序中只需要用到一份顺序表，表中元素数量可以预计而且内存也足够时，我们就直接用一个普通的数组来代替顺序表，这是比较常见的情况；另一种情况是可能需要用到多份顺序表，或者元素数量无法准确预期时，又或者我们对表有比较特殊的要求，比如要求元素值不能重复或者元素按值有序排列等，我们可以直接使用C++标准模板库（STL）提供的现成的数据结构，称为<strong>STL容器</strong>（container）。当然前一种情况下也可以直接使用容器，除非程序真的很简单，一般我们也推荐直接使用容器。下面我们将简单介绍一种顺序表容器，向量（vector）的使用方法。</p>
<div class="section" id="stlvector">
<span id="ref-311-vector"></span><h2><span class="section-number">4.1.1.1. </span>STL的vector容器<a class="headerlink" href="#stlvector" title="永久链接至标题">¶</a></h2>
<p>C++的STL库里有一个<strong>向量</strong>（vector）容器，就是一个非常完美的顺序表，也可以视为一个功能完善的可变长度数组。它支持范型，支持动态增长，功能丰富，安全可靠而且效率很高。如果在算法编程中需要用到顺序表，首选是采用它而不是自己写一个顺序表的代码。</p>
<p>要在程序中使用vector容器，首先要引入STL库vector，并且在程序中使用std<strong>命名空间</strong>。算法编程时一般会在整个程序的最开始，include指令之后就指定好命名空间。然后我们就可以定义vector容器变量了。STL库提供的所有容器都是所谓的模板容器，它们对元素的数据类型没有预先限定，所以我们在定义具体的容器变量时需要指定它将要存放什么数据类型的元素。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;       // 引入STL库中的vector容器</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>    <span class="c1">// 指定本程序中要用到命名空间std</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">n</span><span class="p">;</span>          <span class="c1">// 定义一个存放int型变量的vector容器，未初始化，没有任何元素</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>   <span class="c1">// 定义一个存放double型变量的vector容器，初始长度10个元素，值不定</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>   <span class="c1">// 定义一个存放bool型变量的vector容器，初始长度为5，值全部为true</span>
</pre></div>
</div>
<p>一个vector容器里如果有元素，那么就可以像一个数组一样用方括号 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 来访问其中的元素，<strong>当然同样要注意下标越限问题！</strong></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>算法编程时常会用最简单的方法来定义vector容器，就像定义一个普通的不初始化的变量，例如：<code class="docutils literal notranslate"><span class="pre">vector&lt;int&gt;</span> <span class="pre">n；</span></code>。但是这样定义出来的容器并没有初始化过，所以在还没有添加过元素之前，是不能用 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 来访问元素的。如果我们在添加过元素之前就运行语句 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">n[0];</span></code> 会产生<strong>段错误</strong>。</p>
</div>
<p>除了用类似数组的方括号加下标的方式来访问元素，vector（包括所有其他STL容器）还提供了一种叫做<strong>迭代器</strong>（iterator）的方式来访问元素。vector容器提供了一头一尾两个迭代器，分别用 <code class="docutils literal notranslate"><span class="pre">begin()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">end()</span></code> 两个成员函数来获得。头迭代器指向第一个元素，也就是0号元素；尾迭代器指向紧跟在最后一个元素后面的那个位置；迭代器的使用非常类似于指针，可以使用加减运算来改变它的位置；可以在迭代器前面加上 <code class="docutils literal notranslate"><span class="pre">*</span></code> 运算符来获得它指向的元素；两个迭代器相减之差等于它们之间（含头不含尾）的元素个数。</p>
<img alt="../../_images/311_iterator.png" src="../../_images/311_iterator.png" />
<p>下面这段代码片段演示了怎样定义、获取、操作迭代器，利用迭代器来输出一个vector里的所有数据。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>			<span class="c1">// 定义一个存放int型元素的vector</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>	<span class="c1">// 添加10个元素，分别为0到9的平方</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>	<span class="c1">// 定义迭代器it并将其初始化为v的头迭代器</span>
	<span class="k">while</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>			<span class="c1">// 循环，直到it增长到等于v的尾迭代器</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="o">++</span><span class="p">);</span>		<span class="c1">// 用*运算符取值，用++运算向后移动it的位置</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以看出来，迭代器事实上就是一个升级版的指针。</p>
<p>vector容器的使用非常简单，虽然它提供了大量的成员函数，但在算法编程时一般掌握一些常用的成员函数就基本够用了。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>成员函数</p></th>
<th class="head"><p>作用</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">vector()</span></code></p></td>
<td><p>无参构造函数，将容器初始化为空</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">vector(int</span> <span class="pre">n)</span></code></p></td>
<td><p>将容器初始化为有n个元素</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">vector(int</span> <span class="pre">n,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;val)</span></code></p></td>
<td><p>假定元素的类型是T，此构造函数将容器初始化为有n个元素，每个元素的值都是val</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">clear()</span></code></p></td>
<td><p>删除所有元素</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">empty()</span></code></p></td>
<td><p>判断容器是否为空</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">pop_back()</span></code></p></td>
<td><p>删除容器末尾的元素</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">push_back(</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;val)</span></code></p></td>
<td><p>将val添加到容器末尾</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size()</span></code></p></td>
<td><p>返回容器中元素的个数</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">&amp;front()</span></code></p></td>
<td><p>返回容器中第一个元素的引用</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">&amp;back()</span></code></p></td>
<td><p>返回容器中最后一个元素的引用</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">iterator</span> <span class="pre">insert(iterator</span> <span class="pre">i,</span> <span class="pre">const</span> <span class="pre">T</span> <span class="pre">&amp;val)</span></code></p></td>
<td><p>将val插入迭代器i指向的位置，返回i</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">iterator</span> <span class="pre">erase(iterator</span> <span class="pre">i)</span></code></p></td>
<td><p>删除迭代器i指向的元素，返回值是被删元素后面的元素的迭代器</p></td>
</tr>
</tbody>
</table>
<p>下面是一个示例程序，用来演示一下怎样使用上面这些常用成员函数、方括号+下标访问元素和迭代器访问元素的方法。这些都是算法编程中最为常见的用法，建议大家照着这个示例程序自己动手试验一下，可以试着改一改再试一试，其他在示例程序中没有演示的成员函数也可以自己加进去试试。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>		<span class="c1">// 依次向v的尾部添加1、2、3、4、5</span>
		<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>		<span class="c1">// 依次从v的头部插入1、2、3、4、5</span>
		<span class="n">v</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">i</span><span class="p">);</span>
	<span class="c1">// 到这里为止，v中的元素依次应为：5、4、3、2、1、1、2、3、4、5</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;v.size() = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>	<span class="c1">// 输出：10</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;v: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>	<span class="c1">// 依次输出v中的元素</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">v</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>				<span class="c1">// 弹掉v尾部的那个元素</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;v: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="c1">// 到这里为止，应该输出：5、4、3、2、1、1、2、3、4</span>

	<span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>		<span class="c1">// 删除从头向后数第3个位置(v[3])的元素</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;v: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="c1">// 到这里为止，应该输出：5、4、3、1、1、2、3、4</span>

	<span class="n">v</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">9</span><span class="p">);</span>		<span class="c1">// 在最头部位置(v[0])插入整数9</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;v: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="c1">// 到这里为止，应该输出：9、5、4、3、1、1、2、3、4</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>		<span class="c1">// 如果v不为空，那么清空它</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;v.empty() = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="s">&quot;true&quot;</span> <span class="o">:</span> <span class="s">&quot;false&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>运行的结果如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>v.size() = 10
v:   5  4  3  2  1  1  2  3  4  5
v:   5  4  3  2  1  1  2  3  4
v:   5  4  3  1  1  2  3  4
v:   9  5  4  3  1  1  2  3  4
v.empty() = true
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">经验</p>
<p>仿写程序是一种高效的学习方法，尤其是对笔试的大题（程序阅读、程序填空）特别有帮助。如果能在仿写的时候修改一下再试试看，学习效果更佳。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="312_big_int_1.html" title="4.1.2. 高精度整数算法(I) 数据的表示"
             >下一页</a> |</li>
        <li class="right" >
          <a href="../310_linear_list.html" title="4.1. 线性表"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../300_basic_data_structure.html" ><span class="section-number">4. </span>基础数据结构</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../310_linear_list.html" ><span class="section-number">4.1. </span>线性表</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>