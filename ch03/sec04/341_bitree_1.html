
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>4.4.1. 二叉树(I) 基础知识 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="4.4.2. 二叉树(II) 层序访问与宽度优先搜索" href="342_bitree_2.html" />
    <link rel="prev" title="4.4. 树和森林" href="../340_tree.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="342_bitree_2.html" title="4.4.2. 二叉树(II) 层序访问与宽度优先搜索"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="../340_tree.html" title="4.4. 树和森林"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../300_basic_data_structure.html" ><span class="section-number">4. </span>基础数据结构</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../340_tree.html" accesskey="U"><span class="section-number">4.4. </span>树和森林</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.4.1. 二叉树(I) 基础知识</a><ul>
<li><a class="reference internal" href="#id1">4.4.1.1. 二叉树的概念</a></li>
<li><a class="reference internal" href="#id2">4.4.1.2. 二叉树的链式结构实现</a></li>
<li><a class="reference internal" href="#id3">4.4.1.3. 二叉树的顺序结构实现</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="../340_tree.html"
                        title="上一章"><span class="section-number">4.4. </span>树和森林</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="342_bitree_2.html"
                        title="下一章"><span class="section-number">4.4.2. </span>二叉树(II) 层序访问与宽度优先搜索</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch03/sec04/341_bitree_1.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="i">
<h1><span class="section-number">4.4.1. </span>二叉树(I) 基础知识<a class="headerlink" href="#i" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2><span class="section-number">4.4.1.1. </span>二叉树的概念<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>在这一部分的引论节中我们已经了解了树和森林的概况和相关的一些概念，也已经了解到了所有的树和森林类数据结构中最为重要的一种，即<strong>二叉树</strong>（binary tree），它是指所有节点都最多只有两个子节点的树。一个节点的两个子节点习惯上分别称之为<strong>左子节点</strong>（left child）和<strong>右子节点</strong>（right child）。如果将一个节点的左子节点视为根节点，从它开始的所有后代节点共同构成的子树称为这个节点的<strong>左子树</strong>（left subtree），以其右子节点为根的部分就称为它的<strong>右子树</strong>（right subtree）。</p>
<p>二叉树每一层上的节点数量是有规律可循的。按照树结构的定义，根所在的层为第0层，在这一层上只能有一个根节点，所以第0层有且仅有一个节点。因为一个二叉树节点最多只有2个子节点，所以每一层的节点数最多是上一层节点数的2倍。设第 <span class="math notranslate nohighlight">\(i\)</span> 层上的最大节点数量为 <span class="math notranslate nohighlight">\(N_i\)</span>，则下一层上 <span class="math notranslate nohighlight">\(N_{i+1}=2N_i\)</span>，其中 <span class="math notranslate nohighlight">\(i=0,1,2,\cdots\)</span>，初值 <span class="math notranslate nohighlight">\(N_0=1\)</span>。很容易看出，这是一个等比数列，公比为2，首项为1。因此，二叉树单层最大节点数为：</p>
<div class="math notranslate nohighlight">
\[N_i=2^i, (i=0,1,2,\cdots)\]</div>
<p>由此，使用等比数列求和的方法就很容易得到一棵高度为 <span class="math notranslate nohighlight">\(h\)</span> 的二叉树的最大可能节点数量 <span class="math notranslate nohighlight">\(N(h)\)</span> 了。</p>
<div class="math notranslate nohighlight">
\[N(h) = N_0 + N_1 + N_2 + \cdots + N_{h-1} = 2^0 + 2^1 + 2^2 + \cdots + 2^{h-1} = 2^h - 1\]</div>
<p>根据上面的描述，我们很容易想象出一棵完美的二叉树应该有的样子，就像下面这样：</p>
<img alt="../../_images/341_bitree_1.png" src="../../_images/341_bitree_1.png" />
<p>这当然是最完美的一种二叉树了，在这样的二叉树中，每一层都恰好排满了节点，我们把这样的二叉树叫做<strong>满二叉树</strong>。</p>
<p>满二叉树第 <span class="math notranslate nohighlight">\(i\)</span> 层上的节点数量一定恰好等于二叉树这一层的最大可能节点数 <span class="math notranslate nohighlight">\(2^i\)</span>，而一棵高度为 <span class="math notranslate nohighlight">\(h\)</span> 的满二叉树的总节点数也一定恰好是相同高度的二叉树的最大可能节点数 <span class="math notranslate nohighlight">\(2^h-1\)</span>。例如上图中这棵高度为4的满二叉树，它的节点数就是1+2+4+8=15=2<sup>4</sup>-1个。</p>
<p>显而易见，如果节点数恰好为 <span class="math notranslate nohighlight">\(2^h-1\)</span> 这种形式的数值，那么组织成满二叉树，高度为 <span class="math notranslate nohighlight">\(h\)</span>，这是最低可能的高度了。所有基于二叉树操作的算法，树高越低，效率越高，因此满二叉树确实是最完美的。</p>
<p>但是实际应用中不可能保证节点数总是恰为 <span class="math notranslate nohighlight">\(2^h-1\)</span> 个的。因此我们一般就退而求其次，希望在任意的节点总数 <span class="math notranslate nohighlight">\(n\)</span> 下，二叉树最好能组织成下面这种样子：</p>
<img alt="../../_images/341_bitree_2.png" src="../../_images/341_bitree_2.png" />
<p>也就是说，除了最低的那一层以外，其他各层都是满二叉树的形式，而最低那一层上的节点，从左到右连续地排列，直到排完。这样的二叉树是接近完美的，我们称之为<strong>完全二叉树</strong>。于是，现在我们可以认为满二叉树是完全二叉树的一种特例。</p>
<p>完全二叉树是实际应用中所能追求的最接近完美的二叉树了，它也有很多优秀的性质：</p>
<ol class="arabic simple">
<li><p>若一棵完全二叉树的高度为 <span class="math notranslate nohighlight">\(h \ge 1\)</span>，那么它的总节点数 <span class="math notranslate nohighlight">\(n(h)\)</span> 满足 <span class="math notranslate nohighlight">\(2^{h-1} \le n(h) \le 2^h-1\)</span>。</p></li>
<li><p>若节点总数为 <span class="math notranslate nohighlight">\(n \ge 1\)</span>，那么完全二叉树的高度为 <span class="math notranslate nohighlight">\(h(n)=\left\lceil \log (n+1) \right\rceil\)</span>。</p></li>
</ol>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<p>用数学方法证明上面的三个性质。</p>
</div>
<p>现在我们可以得到这样的结论：<em>二叉树中最为完美的组织形式为完全二叉树，为了确保数据访问效率最高，使用二叉树的算法要尽力将二叉树维持为完全二叉树或极其接近完全二叉树</em>。</p>
<p>但是俗话说，世上不如意事十有八九，如果不人为地在程序中对树的形状进行监控和修整，自然生长的二叉树通常会长成各种奇怪的形状，比如：</p>
<img alt="../../_images/341_bitree_3.png" src="../../_images/341_bitree_3.png" />
<p>这就算是比较好的了，还有最差的情况，从树根开始总是向着一个方向延伸，于是变成这样：</p>
<img alt="../../_images/341_bitree_4.png" src="../../_images/341_bitree_4.png" />
<p>这种最差情况下，树的高度等于树中的节点数，数据访问的效率最低，实际上这是退化成了线性表。不光是二叉树，任何形式的树在应用中都要注意，绝对不能让它退化成线性表。</p>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>如果保持好树的形态，使其尽可能地接近或成为完全二叉树，是所有基于二叉树的算法所需要关注的问题。要实现这一目标并不简单，比如后面要讲的二叉检索树，就需要通过不断地检查和旋转来保持身材，使之成为一棵平衡二叉检索树，否则就很容易退化，失去了二叉检索树的价值。但是检查和旋转的所谓平衡二叉树算法是比较复杂的，更加复杂的还有红黑树的平衡算法。这些技术在初学阶段可以不必掌握，但是要有所了解。</p>
</div>
<p>当然了，千万不要忘记只有一个树根的树也是一棵二叉树，它既是最优秀的满二叉树，又是退化成线性表的最差劲状态。</p>
<p>从上面这种退化状态也可以看出一个结论，一棵高度为 <span class="math notranslate nohighlight">\(h\)</span> 的二叉树至少有 <span class="math notranslate nohighlight">\(h\)</span> 个节点。所以我们可以得出通常意义下二叉树的高度和节点数之间的关系：</p>
<ol class="arabic simple">
<li><p>高度为 <span class="math notranslate nohighlight">\(h\)</span> 的二叉树，其节点数 <span class="math notranslate nohighlight">\(n(h)\)</span> 的取值范围为：<span class="math notranslate nohighlight">\(h \le n(h) \le 2^h-1\)</span>。</p></li>
<li><p>节点数为 <span class="math notranslate nohighlight">\(n\)</span> 的二叉树，其高度 <span class="math notranslate nohighlight">\(h(n)\)</span> 的取值范围为：<span class="math notranslate nohighlight">\(\left\lceil \log(n+1) \right\rceil \le h(n) \le n\)</span>。</p></li>
<li><p>给定节点数，完全二叉树的高度达到最低，退化二叉树高度达到最高。</p></li>
<li><p>给定高度，满二叉树的节点数达到最大，退化二叉树的节点数达到最小。</p></li>
</ol>
<p>从上面的介绍我们可以看出，二叉树实际上隐含了一种递归的形式，即子树也是一棵二叉树。另外，无论从理论上还是从实践上来讲，我们都应该允许任何一种数据结构中的数据量为零，比如一张空链表，二叉树当然也不例外，当然允许有所谓的空树存在。哪怕连根节点都不存在，也应该视为一棵二叉树，即一棵节点数为0的空二叉树。于是我们就可以有下面这样的二叉树的递归定义：</p>
<div class="admonition- admonition">
<p class="admonition-title">二叉树的递归定义</p>
<p>一棵二叉树：
1. 要么没有节点，是一棵空二叉树；
2. 要么由一个根节点和它的左右两棵子树构成，且左右两棵子树都是二叉树。</p>
</div>
</div>
<div class="section" id="id2">
<h2><span class="section-number">4.4.1.2. </span>二叉树的链式结构实现<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>很遗憾，C++的STL库中没有现成的树类型的容器，所以当然也没有二叉树这种应用极为广泛的数据结构。如果遇到要使用二叉树的算法，我们只能自己编程实现一个。</p>
<p>二叉树最常见的实现方式为链式结构。根据二叉树的递归定义，我们只需要这样一种节点结构就可以实现二叉树了：可以存放一个数据项，有两个指向左右子树的指针，指针类型就是节点结构本身。比如下面这个简单的结构其实就已经定义了一个模板元素数据类型的二叉树节点。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
	<span class="n">T</span> <span class="n">_value</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>

	<span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">T</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>这里这个简单的 <code class="docutils literal notranslate"><span class="pre">Node</span></code> 结构我们将在后文的示例程序中一直继续使用。它的编写方式有几个需要注意的地方：</p>
<ol class="arabic simple">
<li><p>我们将模板类型的数据项用封装惯例封装了起来，可以用 <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">&amp;value()</span></code> 成员函数来访问数据项的引用，这样就可以实现对任何类型的数据项的高速读写访问。</p></li>
<li><p>但是我们并没有封装左右子节点指针的成员变量 <code class="docutils literal notranslate"><span class="pre">left</span></code> 和 <code class="docutils literal notranslate"><span class="pre">right</span></code>，意味着程序中可以直接访问这两个成员变量，这是因为封装指针类型的变量比较复杂，如果不想使用指针的指针这种反人类的形式，那么就要将子节点的读和写分成两个不同的成员函数，就像Java中的数据域访问器一样，这是被C/C++程序员所不齿的一种做法。考虑到算法编程的特殊性，我们就不坚持数据封装了，灵活一点，直接访问成员变量就可以了。</p></li>
<li><p>这个结构只是定义了一个二叉树的节点，并不是一棵二叉树。虽然根据二叉树的递归定义，一个节点就是一棵二叉树，只需要定义这样一个节点结构类型就足够了，但是使用的时候总觉得有点不太精准。因此一般我们在正式使用之前更习惯给它取一个听上去像二叉树的别名。另外，由于采用的是链式结构，会更多地用到节点的指针类型而非节点类型本身，所以我们通常干脆给它的指针类型定义一个别名，例如：</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">Node</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>模板类型在定义别名的时候要指定具体数据类型，不能给没有具体化的模板再取别名</p>
</div>
<p>这样定义之后，自定义类型 <code class="docutils literal notranslate"><span class="pre">BiTree</span></code> 其实就是指向数据项为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 型的二叉树节点的指针类型 <code class="docutils literal notranslate"><span class="pre">Node&lt;int&gt;</span> <span class="pre">*</span></code>。例如下面是一个简单的示例程序，请仔细阅读，学会怎样生成节点、添加子节点、读取和修改节点中数据项的值等最基本的操作：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
	<span class="n">T</span> <span class="n">_value</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>

	<span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">T</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">Node</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>	<span class="c1">// 定义一个具体的二叉树节点的指针类型，数据为int型</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 生成根节点，值为4</span>
	<span class="n">BiTree</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;root = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
	<span class="c1">// 修改根节点的值</span>
	<span class="o">++</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;root = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
	<span class="c1">// 添加左右子节点</span>
	<span class="n">BiTree</span> <span class="n">left_child</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left_child</span><span class="p">;</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;left = %d, right = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(),</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
	<span class="k">delete</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>在实际使用中，为了方便访问，往往会把父子关系做成双向链的结构，即每一个节点都再增加一个指向父节点的成员变量，以便从子节点回溯到父节点去。根节点的父节点指针规定为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。但是这样的双链结构会增加节点增删时的工作量，添加子节点的时候要同时维护好子节点的父节点指针才行。后面我们会很快看到这种双链结构的二叉树。</p>
</div>
</div>
<div class="section" id="id3">
<h2><span class="section-number">4.4.1.3. </span>二叉树的顺序结构实现<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>除了上面这种最常见的链式结构以外，二叉树其实也可以基于顺序表，比如最简单的数组来实现。基于顺序结构实现的二叉树，在代码形式上能够更加简洁，在节点的查找与读写上也可以利用按下标直接访问的优势提高速度。</p>
<p>假如我们将一棵二叉树中的所有节点按照层次从上到下、同层从左到右的顺序依次从0开始编号。根节点规定为0号节点，那么根节点的左右两个子节点就分别为1号节点和2号节点。再下一层，从左到右依次是1号节点的左右子节点和2号节点的左右子节点，它们的编号依次为3、4、5、6号。例如下面这样一棵满二叉树：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            0
           / \
          /   \
         /     \
        /       \
       /         \
      /           \
     1             2
    / \           / \
   /   \         /   \
  3     4       5     6
 / \   / \     / \   / \
7   8 9  10   11 12 13 14
</pre></div>
</div>
<p>我们可以发现，每一个位置上的节点编号和它的父节点编号是有确定的关系的。对于任意一个编号为 <span class="math notranslate nohighlight">\(n\)</span> 的节点：</p>
<ol class="arabic simple">
<li><p>父节点编号：<span class="math notranslate nohighlight">\(\text{Parent}(n)=\left\lfloor\frac{n-1}{2}\right\rfloor\)</span>。</p></li>
<li><p>左子节点编号：<span class="math notranslate nohighlight">\(\text{LeftChild}(n)=2n+1\)</span>。</p></li>
<li><p>右子节点编号：<span class="math notranslate nohighlight">\(\text{RightChild}(n)=2n+2\)</span>。</p></li>
</ol>
<p>所以我们可以把一棵二叉树的节点按照这样的规则放进一个数组里去，节点的编号就是在数组中的位置下标。为了表示某个位置没有节点，我们应该使用指向数据项的指针数组而不是实际数据项的数组。例如下面这个程序，定义了一个基于数组的二叉树结构类型，并且进行了和上面这个链式结构二叉树示例程序类似的测试。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Node</span><span class="p">;</span>	<span class="c1">// 用数组下标来代指节点，定义一个类型别名</span>

<span class="c1">// 计算父节点编号</span>
<span class="kr">inline</span> <span class="n">Node</span> <span class="nf">parent</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 计算左子节点编号</span>
<span class="kr">inline</span> <span class="n">Node</span> <span class="nf">left_child</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// 计算右子节点编号</span>
<span class="kr">inline</span> <span class="n">Node</span> <span class="nf">right_child</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">1023</span><span class="p">;</span>		<span class="c1">// 1024个节点，支持最大10层的二叉树</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">BiTree</span> <span class="p">{</span>
	<span class="n">T</span> <span class="o">*</span><span class="n">_nodes</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>

	<span class="n">BiTree</span><span class="p">()</span> <span class="p">{</span> <span class="n">memset</span><span class="p">(</span><span class="n">_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_nodes</span><span class="p">));</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">BiTree</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">delete</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="c1">// 判断节点是否存在</span>
	<span class="kt">bool</span> <span class="n">has_node</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span>
	<span class="c1">// 重载[]运算，使得可以按下标值访问节点</span>
	<span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span>
	<span class="c1">// 插入一个新的节点</span>
	<span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">;</span>
			<span class="o">*</span><span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 删除一个节点</span>
	<span class="kt">void</span> <span class="n">erase</span><span class="p">(</span><span class="n">Node</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">delete</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
			<span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// 生成一棵二叉树，数据项为int型</span>
	<span class="n">BiTree</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">;</span>
	<span class="c1">// 插入根节点，数据值为4</span>
	<span class="n">tree</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;root = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">root</span><span class="p">]);</span>
	<span class="c1">// 修改根节点的值</span>
	<span class="o">++</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;root = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">root</span><span class="p">]);</span>
	<span class="c1">// 添加左右子节点</span>
	<span class="n">tree</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">left_child</span><span class="p">(</span><span class="n">root</span><span class="p">),</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">tree</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">right_child</span><span class="p">(</span><span class="n">root</span><span class="p">),</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;left = %d, right = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">left_child</span><span class="p">(</span><span class="n">root</span><span class="p">)],</span> <span class="n">tree</span><span class="p">[</span><span class="n">right_child</span><span class="p">(</span><span class="n">root</span><span class="p">)]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从读写节点数据的实际运行速度来看，用顺序结构实现一定会更快一些，因为顺序结构天生就比链式结构的读写效率高。而且顺序结构的代码也更加简洁，最极端的情况是有明确取值范围的基本数据类型数据项，这种情况下甚至不需要用指针数组，任取一个不在取值范围内的值作为该位置没有节点的标识。例如非负整数的二叉树，直接用 <code class="docutils literal notranslate"><span class="pre">int</span></code> 数组构造即可，用值 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 表示此处没有节点，而 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 又恰好可以用 <code class="docutils literal notranslate"><span class="pre">memset()</span></code> 函数批量赋值。这种情况下顺序结构的二叉树代码会非常简洁优雅。</p>
<p>但是顺序结构实现二叉树有一个非常致命的问题，那就是空间浪费。试想在上面的代码中，我们用一个长度为1023的数组作为基础。按照二叉树层与节点数量的关系，这个数组支持存放最多10层的二叉树。如果遇到稀疏的树形，节点数远少于1023个，空间就被浪费了。极端情况下，10层的二叉树最少可以少到只有10个节点，1013个数组元素空间被浪费。</p>
<p>绝大多数算法问题会给出明确的数据量，假如我们已经知道了最多有可能有 <span class="math notranslate nohighlight">\(N\)</span> 个节点，而且二叉树的形状并没有特别的控制，那么我们要考虑最坏情况，可能会是 <span class="math notranslate nohighlight">\(N\)</span> 层，不排除每一层都是最右边的节点的情况，即上面示意图中沿着 <code class="docutils literal notranslate"><span class="pre">0-&gt;2-&gt;6-&gt;14</span></code> 这条边一路贴着右边界下来的情况。所以我们需要准备一个长度为 <span class="math notranslate nohighlight">\(2^N-1\)</span> 的底层数组，<span class="math notranslate nohighlight">\(O(2^n)\)</span> 级别的空间复杂度，太可怕了！算法竞赛一般要求内存使用不超过128M，那么最大可能的节点数大概为25个以内，一旦 <span class="math notranslate nohighlight">\(N\)</span> 超过30，普通的家用电脑就没得玩了，如果 <span class="math notranslate nohighlight">\(N\)</span> 等于64，那么把全世界的内存加在一起也不够了。</p>
<p>所以如果不控制二叉树的形状，顺序结构几乎就是没有任何实用价值的。要用顺序结构，就必须控制二叉树的形状。</p>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>顺序结构实现的二叉树，一般都要求是完全二叉树，或总是非常接近完全二叉树。高级数据结构<strong>堆</strong>就是一个非常典型的例子。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="342_bitree_2.html" title="4.4.2. 二叉树(II) 层序访问与宽度优先搜索"
             >下一页</a> |</li>
        <li class="right" >
          <a href="../340_tree.html" title="4.4. 树和森林"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../300_basic_data_structure.html" ><span class="section-number">4. </span>基础数据结构</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../340_tree.html" ><span class="section-number">4.4. </span>树和森林</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>