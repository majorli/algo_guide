
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>4.2.2. 栈的应用：表达式求值 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="5. 算法设计方法" href="../../400_basic_algo_design.html" />
    <link rel="prev" title="4.2.1. 栈：概念、stack容器和实现" href="321_stack_1.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../../400_basic_algo_design.html" title="5. 算法设计方法"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="321_stack_1.html" title="4.2.1. 栈：概念、stack容器和实现"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../300_basic_data_structure.html" ><span class="section-number">4. </span>基础数据结构</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../320_stack_queue.html" accesskey="U"><span class="section-number">4.2. </span>特殊线性表：栈和队列</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.2.2. 栈的应用：表达式求值</a><ul>
<li><a class="reference internal" href="#id2">4.2.2.1. 前缀、中缀和后缀表达式</a></li>
<li><a class="reference internal" href="#id3">4.2.2.2. 中缀表达式的分析算法</a></li>
<li><a class="reference internal" href="#id4">4.2.2.3. 后缀表达式的生成算法</a></li>
<li><a class="reference internal" href="#id5">4.2.2.4. 后缀表达式的计算算法</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="321_stack_1.html"
                        title="上一章"><span class="section-number">4.2.1. </span>栈：概念、stack容器和实现</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="../../400_basic_algo_design.html"
                        title="下一章"><span class="section-number">5. </span>算法设计方法</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch03/sec02/322_stack_2.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">4.2.2. </span>栈的应用：表达式求值<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>求表达式的值是最常见的数学运算之一，也是计算机软件最常见的任务之一。例如最简单的整数四则运算表达式，只允许使用加减乘除四则运算和括号（允许嵌套），所有运算数都是整数，但要注意其值不一定是整数。</p>
<p>对于人类来说，四则运算求值这个任务有可能计算过程会比较麻烦，但是对表达式的理解一定是很简单的，只要上过小学，四则运算和括号的使用规则就一定非常熟练，只要认真地去一步步计算即可。但是对于计算机来说，给定一个字符串形式的表达式，最大的挑战是要让软件看懂这个表达式，而计算却不是什么问题。</p>
<p>计算机要对表达式求值，首先要分析词法，即分解出运算符和运算数，对于运算数要将其从字符串形式转为整数。经过词法分析，一个字符串形式的表达式就会被拆解成一个记号（token）序列，这些记号有两种类型，一种是运算符，另一种是运算数。</p>
<p>完成词法分析之后，要对得到的记号序列进行语法分析，根据运算优先级（乘除优先级高于加减）和括号的位置确定计算顺序。语法分析结束之后即可按照分析结果逐步完成计算。</p>
<p>词法分析和语法分析还承担了判断表达式是否正确的任务，词法错误主要包括不正确的运算符、不符合规则的运算数等，语法错误主要包括运算符前后缺少运算数、括号不匹配等。在算法问题中往往题目会确保输入的表达式是正确的，这时候我们就可以忽略查错这个步骤。</p>
<p>所以计算机要完成一个表达式的求值，前后共要进行词法分析、语法分析和求值三个步骤。由于不同运算有不同优先级，通过加括号又可以调整计算顺序，所以数学表达式的计算过程可以非常灵活。但是计算机最不喜欢的就是灵活，计算机希望表达式能够没有括号、没有优先级、总是从左到右或者从右到左按固定的顺序运算。</p>
<p>为此人们发明了<strong>前缀表达式</strong>和<strong>后缀表达式</strong>两种新的表达式形式，同时把人类使用的通常的表达式称为<strong>中缀表达式</strong>。</p>
<div class="section" id="id2">
<h2><span class="section-number">4.2.2.1. </span>前缀、中缀和后缀表达式<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>所谓的前缀、中缀、后缀表达式，是三种不同的表达式形式，是指运算符放在运算数的前面、中间还是后面而言的。比如通常的数学表达式 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>，运算符加号是放在两个运算数中间的，所以叫做中缀表达式，如果写成前缀表达式就是 <code class="docutils literal notranslate"><span class="pre">+</span> <span class="pre">1</span> <span class="pre">2</span></code>，写成后缀表达式就是 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">+</span></code>。前缀表达式和后缀表达式是由波兰逻辑学家 Lukasewicz 发明的，因此前缀表达式也叫做<strong>波兰表达式</strong>，后缀表达式叫做<strong>逆波兰表达式</strong>。</p>
<p>前缀和后缀表达式是不允许也不需要使用括号的，所有运算也没有优先级之分。在把通常的中缀表达式转换为相应的前缀或后缀表达式时，就已经使所有运算按正确的顺序沿一个方向排列好了，前缀表达式从右向左，后缀表达式从左向右。于是这两种表达式形式特别适用于计算机求值。</p>
<p><strong>前缀表达式</strong></p>
<p>例如普通的表达式 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">3</span></code>，写成前缀表达式时应该把运算符 <code class="docutils literal notranslate"><span class="pre">-</span></code> 和 <code class="docutils literal notranslate"><span class="pre">*</span></code> 都放在各自的运算数之前，按照优先级，乘法先算，所以先把 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">3</span></code> 写成 <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">2</span> <span class="pre">3</span></code>，而减法的两个运算数分别为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">2</span> <span class="pre">3</span></code>，因此最终的前缀表达式为 <code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">1</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">3</span></code>。</p>
<p>计算机求前缀表达式的值时，使用一个栈存放中间结果。计算过程从右向左扫描表达式，遇到运算数就将其压栈，遇到运算符就从栈中弹出两个数进行计算并把计算结果重新压入栈中。如此下去直到整个表达式扫描完毕，栈中留下的那个数就是表达式的值。例如示例中的这个表达式的运算过程如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>表达式：+ 1 * 2 3

初始栈：[]

第1步：读到运算数3，压栈，栈变成 [3]

第2步：读到运算数2，压栈，栈变成 [3, 2]

第3步：读到运算符*，从栈中先后弹出2和3，计算2 * 3 = 6，压栈，栈变成 [6]

第4步：读到运算数1，压栈，栈变成 [6, 1]

第5步：读到运算符-，从栈中先后弹出1和6，计算1 - 6 = -5，压栈，栈变成 [-5]

表达式扫描完毕，栈中应该只剩下一个元素，即计算结果-5
</pre></div>
</div>
<p>带括号的中缀表达式的处理方法也是一样的，无非最内层的括号有最高的运算优先级而已。例如 <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">5</span> <span class="pre">-</span> <span class="pre">6</span></code>，优先级最高的运算是 <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">4)</span></code>，先将其变成 <code class="docutils literal notranslate"><span class="pre">+</span> <span class="pre">3</span> <span class="pre">4</span></code>，然后将乘法部分变成 <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">5</span></code>，最后再将减法部分也变成前缀形式，得到最终的前缀表达式 <code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">*</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">5</span> <span class="pre">6</span></code>。</p>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<ol class="arabic">
<li><p>仿照前面所示的步骤，手工进行前缀表达式 <code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">*</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">5</span> <span class="pre">6</span></code> 的运算，检查计算结果。</p></li>
<li><p>手工将下列中缀表达式转换为前缀表达式并求值，检查计算结果：</p>
<p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">3</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">+</span> <span class="pre">13</span> <span class="pre">*</span> <span class="pre">14</span> <span class="pre">-</span> <span class="pre">15</span> <span class="pre">/</span> <span class="pre">16</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">((2</span> <span class="pre">+</span> <span class="pre">3)</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">-</span> <span class="pre">5</span></code></p>
</li>
</ol>
</div>
<p><strong>后缀表达式</strong></p>
<p>实际上在计算机软件中使用前缀表达式的情况并不多，几乎都使用后缀表达式。具体的原因和表达式优化有关，现在不需要深究，知道即可。正因为如此，在算法问题中基本也只会出现后缀表达式有关的问题，我们需要熟练地掌握后缀表达式的生成和运算方法，能熟练地编写相关的程序。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>后缀表达式的生成和计算是目前为止遇到的最大难点，也是一大重点。</p>
</div>
<p>首先仍然用 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">3</span></code> 为例来看看怎样手动生成后缀表达式。和生成前缀表达式一样，还是按照运算顺序来逐个部分的变为后缀式。首先将 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">3</span></code> 变成 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">3</span> <span class="pre">*</span></code>，随后处理减法部分，前后两个操作数分别为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">3</span> <span class="pre">*</span></code>，所以写成 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">-</span></code> 的形式，这就是最终的后缀表达式。</p>
<p>后缀表达式的计算方法和前缀表达式也是几乎一样的，有两个区别：一是从左向右扫描，二是每一步运算先弹出的数为右运算数、后弹出的数为左运算数。以计算 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">-</span></code> 为例：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>表达式：1 2 3 * -

初始栈：[]

第1步：读到运算数1，压栈，栈变成 [1]

第2步：读到运算数2，压栈，栈变成 [1, 2]

第3步：读到运算数3，压栈，栈变成 [1, 2, 3]

第4步：读到运算符*，从栈中先后弹出3和2，计算2 * 3 = 6，压栈，栈变成 [1, 6]

第5步：读到运算符-，从栈中先后弹出6和1，计算1 - 6 = -5，压栈，栈变成 [-5]

表达式扫描完毕，栈中应该只剩下一个元素，即计算结果-5
</pre></div>
</div>
<p>再如中缀表达式 <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">5</span> <span class="pre">-</span> <span class="pre">6</span></code>，按照运算顺序，先把 <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">4)</span></code> 变成 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">+</span></code>，接下来将乘法部分改成 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span></code>，最后处理减法部分，得到最终的后缀表达式 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">6</span> <span class="pre">-</span></code>。</p>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<ol class="arabic">
<li><p>仿照前面所示的步骤，手工进行后缀表达式 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">6</span> <span class="pre">-</span></code> 的运算，检查计算结果。</p></li>
<li><p>手工将下列中缀表达式转换为后缀表达式并求值，检查计算结果：</p>
<p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">3</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">+</span> <span class="pre">13</span> <span class="pre">*</span> <span class="pre">14</span> <span class="pre">-</span> <span class="pre">15</span> <span class="pre">/</span> <span class="pre">16</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">((2</span> <span class="pre">+</span> <span class="pre">3)</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">-</span> <span class="pre">5</span></code></p>
</li>
</ol>
</div>
</div>
<div class="section" id="id3">
<h2><span class="section-number">4.2.2.2. </span>中缀表达式的分析算法<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>读入中缀表达式字符串后，首先要进行词法分析，将其识别为记号序列。整数四则运算有两种记号：一种是<strong>运算符</strong>（operator），包括 <code class="docutils literal notranslate"><span class="pre">+-*/()</span></code>；另一种是<strong>运算数</strong>（operand），即所有整数，简单起见，我们限定操作数都在 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的取值范围内。</p>
<p>所以我们先定义一个表示记号的结构，可以用来存放两种类型的记号：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Token</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">op</span><span class="p">;</span>	<span class="c1">// 运算符</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>	<span class="c1">// 运算数</span>
	<span class="kt">bool</span> <span class="n">is_op</span><span class="p">;</span>	<span class="c1">// 是否为运算符：+-*/()</span>
<span class="p">};</span>
</pre></div>
</div>
<p>当 <code class="docutils literal notranslate"><span class="pre">is_op</span> <span class="pre">==</span> <span class="pre">true</span></code> 时，表示这个记号是一个运算符，此时 <code class="docutils literal notranslate"><span class="pre">op</span></code> 就存放这个具体的运算符，即 <code class="docutils literal notranslate"><span class="pre">+-*/()</span></code> 这六个字符中的任一个；当 <code class="docutils literal notranslate"><span class="pre">is_op</span> <span class="pre">==</span> <span class="pre">false</span></code> 时则表示这个记号是一个运算数，其值存放在 <code class="docutils literal notranslate"><span class="pre">num</span></code> 中。</p>
<p>表达式分析的第一步，词法分析要做的工作就是把一个字符串形式的中缀表达式中每一个不同的元素识别分解出来，变成一个从左向右存放的记号序列。现在我们还不需要考虑计算，只需单纯地分解和识别记号。假设读入的字符串只包含 <code class="docutils literal notranslate"><span class="pre">+-*/()0123456789</span></code> 这些字符和空白符（空格、换行、Tab），而空白符我们认为是可有可无的，一旦读到空白符直接舍弃即可。</p>
<p>词法分析本身并不难，但要注意 <code class="docutils literal notranslate"><span class="pre">+-</span></code> 这两个符号，它们有时候是加法和减法的运算符，需要单独分析成对应的运算符token，有时候是运算数的正负号，要和它后面的正整数组合起来形成正确的运算数token。例如表达式 <code class="docutils literal notranslate"><span class="pre">-3-(-4*(-5))</span></code>，这里面的第1、第3和第4个 <code class="docutils literal notranslate"><span class="pre">-</span></code> 是负号，而第2个 <code class="docutils literal notranslate"><span class="pre">-</span></code> 则是减法运算符。根据数学上对表达式格式的规定可以知道，整个表达式的第一个 <code class="docutils literal notranslate"><span class="pre">+-</span></code> 字符和跟在左括号 <code class="docutils literal notranslate"><span class="pre">(</span></code> 之后的 <code class="docutils literal notranslate"><span class="pre">+-</span></code> 字符是运算数的正负号（左括号之后的那个字符其实是括号内的子表达式的第一个字符），其他的是加减运算符。</p>
<p>这样就可以整理出词法分析的算法思路了，我们使用一个辅助变量 <code class="docutils literal notranslate"><span class="pre">sgn</span></code> 来表示下一个运算数的正负号，如果下一个运算数是正数就令其等于1，负数则等于-1。</p>
<ol class="arabic simple">
<li><p>初始化状态：令 <code class="docutils literal notranslate"><span class="pre">sgn</span></code> 为1；</p></li>
<li><p>从头到尾逐个字符扫描中缀表达式：</p>
<ul class="simple">
<li><p>如果是 <code class="docutils literal notranslate"><span class="pre">+-</span></code> 且是整个表达式的首字符或紧跟在 <code class="docutils literal notranslate"><span class="pre">(</span></code> 之后的字符，那么设置好相应的 <code class="docutils literal notranslate"><span class="pre">sgn</span></code> 值；否则记录一个运算符token并令 <code class="docutils literal notranslate"><span class="pre">sgn</span></code> 等于1；</p></li>
<li><p>如果是 <code class="docutils literal notranslate"><span class="pre">*/()</span></code> 则记录一个运算符token并令 <code class="docutils literal notranslate"><span class="pre">sgn</span></code> 等于1；</p></li>
<li><p>如果是数码字符，那么使用字符串转整数的atoi算法得到运算数的绝对值，乘以 <code class="docutils literal notranslate"><span class="pre">sgn</span></code> 后记录一个运算数token；</p></li>
<li><p>如果是别的字符则直接舍弃。</p></li>
</ul>
</li>
</ol>
<p>这个算法看起来简单，但是实际编程还是很有挑战的。由于算法竞赛很少遇到需要自己做词法分析的题目，所以我们直接给出函数代码，但还是建议自己先动手尝试一下，然后对照看懂这里给出的代码。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp"></span>

<span class="c1">// 解析表达式字符串为token序列</span>
<span class="c1">// expr: 表达式字符串</span>
<span class="c1">// tokens: 解析得到的token序列数组</span>
<span class="c1">// 返回值: 解析得到的token数量</span>
<span class="kt">int</span> <span class="nf">parse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">expr</span><span class="p">,</span> <span class="n">Token</span> <span class="n">tokens</span><span class="p">[]);</span>

<span class="kt">int</span> <span class="nf">parse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">expr</span><span class="p">,</span> <span class="n">Token</span> <span class="n">tokens</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// len: tokens下标，i: 字符下标</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">sgn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// num: 数值，sgn: 符号</span>
	<span class="kt">bool</span> <span class="n">start</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
			<span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">sgn</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="n">start</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">tokens</span><span class="p">[</span><span class="n">len</span><span class="p">].</span><span class="n">is_op</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="n">tokens</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">].</span><span class="n">op</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
					<span class="n">sgn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
			<span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
			<span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span>
			<span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>
				<span class="n">tokens</span><span class="p">[</span><span class="n">len</span><span class="p">].</span><span class="n">is_op</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">tokens</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">].</span><span class="n">op</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">start</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>
				<span class="n">sgn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">default</span><span class="o">:</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
					<span class="n">num</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
					<span class="k">while</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">]))</span>
						<span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
					<span class="n">tokens</span><span class="p">[</span><span class="n">len</span><span class="p">].</span><span class="n">is_op</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
					<span class="n">tokens</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">].</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">sgn</span><span class="p">;</span>
					<span class="n">sgn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">start</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="o">++</span><span class="n">i</span><span class="p">;</span>
				<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在实际应用中，词法分析结束后要进行语法分析。算法编程时如果题目确保输入的中缀表达式正确，那么就不需要了。不过语法分析中的括号匹配检查可以作为一个很好的编程练习。</p>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<p>设计一种简单的算法，利用一个栈来检查中缀表达式中的括号是否左右匹配。输入为一个中缀表达式字符串，如果其中左右括号是匹配的，就输出 <code class="docutils literal notranslate"><span class="pre">&quot;OK&quot;</span></code>，否则就输出 <code class="docutils literal notranslate"><span class="pre">&quot;Wrong&quot;</span></code>。编程实现并测试。</p>
<p>提示：纯粹做括号匹配检查不需要先做词法分析，可以直接基于中缀表达式的字符串来进行检查。</p>
<p>思考：能不能不使用栈，也不使用任何其他复杂的数据结构，仅使用基础数据类型来完成这一检查？如果能，请编程实现并测试。</p>
<p>附加：现在进一步要求在检查到表达式中左右括号不匹配时，能模仿C++编译器那样给出错误信息，指出错误发生的位置，例如输出像以下这样的错误信息：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Wrong:
2*(3+4))
       ^
</pre></div>
</div>
<p>或者</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Wrong:
2*((3+4)
  ^
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h2><span class="section-number">4.2.2.3. </span>后缀表达式的生成算法<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>根据中缀式生成后缀式是一个经典算法问题，它有一个看上去不难，要理解和记住却挺难，要在考场上一次性快速写对非常难的经典算法。这个后缀式生成算法使用两个token栈，一个是运算符栈 <code class="docutils literal notranslate"><span class="pre">s1</span></code>，另一个是中间结果栈 <code class="docutils literal notranslate"><span class="pre">s2</span></code>。算法结束时，<code class="docutils literal notranslate"><span class="pre">s2</span></code> 中存放的就是对应的后缀表达式。算法的具体过程如下：</p>
<ol class="arabic simple">
<li><p>初始化两个栈：运算符栈 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 和中间结果栈 <code class="docutils literal notranslate"><span class="pre">s2</span></code>。</p></li>
<li><p>从左到右的扫描中缀表达式的每一个记号 <code class="docutils literal notranslate"><span class="pre">token</span></code>，按下述逻辑完成处理：</p>
<ol class="arabic simple">
<li><p>若 <code class="docutils literal notranslate"><span class="pre">token</span></code> 是运算数，压入 <code class="docutils literal notranslate"><span class="pre">s2</span></code>；</p></li>
<li><p>若 <code class="docutils literal notranslate"><span class="pre">token</span></code> 是加减乘除四种运算符：</p>
<ul class="simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 为空或 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 栈顶元素为左括号或 <code class="docutils literal notranslate"><span class="pre">token</span></code> 的优先级高于 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 栈顶元素，则直接将 <code class="docutils literal notranslate"><span class="pre">token</span></code> 压入 <code class="docutils literal notranslate"><span class="pre">s1</span></code>；</p></li>
<li><p>否则将 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 栈顶元素弹出并压入 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 然后继续与下一个栈顶元素比较直至满足上述压栈条件后将 <code class="docutils literal notranslate"><span class="pre">token</span></code> 压入 <code class="docutils literal notranslate"><span class="pre">s1</span></code>。</p></li>
</ul>
</li>
<li><p>若 <code class="docutils literal notranslate"><span class="pre">token</span></code> 是左括号则直接压入 <code class="docutils literal notranslate"><span class="pre">s1</span></code>；</p></li>
<li><p>若 <code class="docutils literal notranslate"><span class="pre">token</span></code> 是右括号则依次弹出 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 的栈顶元素并压入 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 直到遇到第一个左括号，最后把这个左括号弹出 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 并抛弃。</p></li>
</ol>
</li>
<li><p>重复上述步骤直到中缀表达式的所有记号处理完毕。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 中剩余的所有元素依次弹出并压入 <code class="docutils literal notranslate"><span class="pre">s2</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s2</span></code> 中的元素按照 <em>从栈底到栈顶</em> 的顺序构成所要求的后缀表达式。</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>根据前面关于三种表达式形式的描述我们不难发现，三种形式的运算数顺序是一样的，所以算法的关键是遇到运算符时如何摆放。</p>
<p>当遇到加减乘除四种真正的运算符时，有两种情况直接压入 <code class="docutils literal notranslate"><span class="pre">s1</span></code>：</p>
<ol class="arabic simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 为空或者栈顶元素为左括号 <code class="docutils literal notranslate"><span class="pre">(</span></code>，这种情况表示当前这个运算符是整个式子或其中某一个由一对括号括起来的子式子的第一个运算，这种情况直接将运算符压栈即可；</p></li>
<li><p>如果当前这个运算符的优先级高于栈顶元素的优先级，说明当前这个运算符将会先运算，而根据弹栈压栈规则，在 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 越靠后的运算符在进入 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 中去的时候越靠前，所以这时候应该暂时先将其压入到 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 中，这样它在 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 中的位置就靠在后面。</p></li>
</ol>
<p>此外还剩一种情况就是当前运算符的优先级不高于 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 的栈顶元素，那么现在这个栈顶元素的运算应该在前，所以先将其弹出压入到 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 去，不断重复这个操作直到满足当前运算符的压栈条件。</p>
<p>最后就是遇到括号的处理了，其实无非是遇到右括号之后就把它对应的那一对括号中的子式子全部变成结果，放到 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 中去而已。</p>
</div>
<p>接下来就是实际编程时的技巧了。假设我们要处理的中缀表达式最多可以有100个记号，这些记号已经用前面所述的 <code class="docutils literal notranslate"><span class="pre">parse()</span></code> 函数完成了分析，形成了一个长度为 <code class="docutils literal notranslate"><span class="pre">len</span></code> 的记号数组 <code class="docutils literal notranslate"><span class="pre">tokens</span></code>，现在我们要编写一个函数 <code class="docutils literal notranslate"><span class="pre">postfix()</span></code> 来对这个中缀表达式记号数组进行处理，变成后缀表达式记号数组。</p>
<p>这个函数中要用到两个元素类型为 <code class="docutils literal notranslate"><span class="pre">Token</span></code> 的栈，当然可以用STL容器 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 来实现，但是事实上这并不是最佳方法，最佳的方法甚至不是自己实现一个栈，而是根本就用单纯的数组来模拟所需要的栈。请看下面的代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXTOKENS</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="c1">// 优先级比较</span>
<span class="c1">// op1 == op2: 返回0</span>
<span class="c1">// op1 &lt; op2 : 返回-1</span>
<span class="c1">// op1 &gt; op2 : 返回1</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">comp</span><span class="p">(</span><span class="kt">char</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">op1</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">op1</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="n">op2</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">op2</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 将中缀表达式token序列转换为后缀表达式token序列</span>
<span class="c1">// tokens: 中缀表达式token序列</span>
<span class="c1">// len: 中缀表达式token序列长度</span>
<span class="c1">// 返回值: 后缀表达式token序列长度</span>
<span class="c1">// 转换得到的后缀表达式token序列仍然存放在数组tokens中</span>
<span class="kt">int</span> <span class="nf">postfix</span><span class="p">(</span><span class="n">Token</span> <span class="n">tokens</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">postfix</span><span class="p">(</span><span class="n">Token</span> <span class="n">tokens</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Token</span> <span class="n">s1</span><span class="p">[</span><span class="n">MAXTOKENS</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="n">MAXTOKENS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_op</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
				<span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
				<span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
				<span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
					<span class="k">while</span> <span class="p">(</span><span class="n">len1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s1</span><span class="p">[</span><span class="n">len1</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">op</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span> <span class="o">&amp;&amp;</span>
						<span class="n">comp</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span><span class="p">,</span> <span class="n">s1</span><span class="p">[</span><span class="n">len1</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">op</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
						<span class="n">s2</span><span class="p">[</span><span class="n">len2</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="o">--</span><span class="n">len1</span><span class="p">];</span>
					<span class="n">s1</span><span class="p">[</span><span class="n">len1</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>
					<span class="n">s1</span><span class="p">[</span><span class="n">len1</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span>
					<span class="k">while</span> <span class="p">(</span><span class="n">len1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s1</span><span class="p">[</span><span class="n">len1</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">op</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span>
						<span class="n">s2</span><span class="p">[</span><span class="n">len2</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="o">--</span><span class="n">len1</span><span class="p">];</span>
					<span class="o">--</span><span class="n">len1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">default</span><span class="o">:</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">s2</span><span class="p">[</span><span class="n">len2</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">s2</span><span class="p">[</span><span class="n">len2</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="o">--</span><span class="n">len1</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">len2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Token</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">len2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们在这里简单地用两个数组 <code class="docutils literal notranslate"><span class="pre">s1,</span> <span class="pre">s2</span></code> 和两个栈长度变量 <code class="docutils literal notranslate"><span class="pre">len1,</span> <span class="pre">len2</span></code> 来模拟了栈，这种简单处理带来了许多编程上的方便。</p>
<p>如果将表示栈中元素数量的栈长度变量用做数组下标，那么它总是指向栈顶元素的后一个元素，所以 <code class="docutils literal notranslate"><span class="pre">s2[len2++]</span> <span class="pre">=</span> <span class="pre">...</span></code> 这样的简单赋值语句即可实现压栈，也可以用 <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">=</span> <span class="pre">s1[--len1]</span></code> 这样的方式实现弹栈并返回栈顶元素。二者结合起来就可以做到用一条赋值语句来实现从 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 中弹出并压入 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 中的操作：<code class="docutils literal notranslate"><span class="pre">s2[len2++]</span> <span class="pre">=</span> <span class="pre">s1[--len1]</span></code>。如果是单纯地弹栈那就更简单了，我们根本不需要真的去删除栈顶元素，只要把栈长度变量减一即可：<code class="docutils literal notranslate"><span class="pre">--len1</span></code> 就相当于弹掉了 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 的栈顶元素。</p>
<p>另外，由于最终的结果是按从栈底到栈顶的顺序存放在栈 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 中的，所以如果我们用了一个规范的栈，例如 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器，那么反而会让结果的获取变得麻烦。因为我们只能通过弹栈来逐个获取记号，所以得到的记号序列和真正后缀表达式的记号序列是反向的。这里我们用普通的数组来模拟栈，事情就变得简单了，我们直接用 <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code> 函数把这个假装自己是个栈的数组中的元素复制一份到原记号数组中去就可以了。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>当程序需要使用栈，而且栈的最大长度可以预期的情况下，经常使用这种数组加长度（也就是栈顶后下标）的方式来模拟栈。这种方式往往编程更简单、功能更灵活。</p>
</div>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<ol class="arabic">
<li><p>根据上述算法，手动将下列中缀表达式转为后缀表达式：</p>
<p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">3</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">+</span> <span class="pre">13</span> <span class="pre">*</span> <span class="pre">14</span> <span class="pre">-</span> <span class="pre">15</span> <span class="pre">/</span> <span class="pre">16</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">((2</span> <span class="pre">+</span> <span class="pre">3)</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">-</span> <span class="pre">5</span></code></p>
</li>
<li><p>理解上述算法和程序，在此基础上总结根据中缀表达式生成前缀表达式的算法并编程实现。</p></li>
</ol>
</div>
</div>
<div class="section" id="id5">
<h2><span class="section-number">4.2.2.4. </span>后缀表达式的计算算法<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>后缀表达式的计算算法就非常简单了，和前面所述的手工计算方法完全一致。</p>
<p>我们需要使用一个栈来存放计算的中间结果，请想一想这个栈的元素数据类型是什么？然后程序就从左到右地读取后缀表达式中每一个token，如果读到的是运算数就压入栈中，如果是运算符就从栈中连续弹出两个运算数然后进行计算，计算的结果压回栈中即可。这里要特别注意减法和除法是不满足交换律的，两个运算数有先后顺序。</p>
<p>事实上如果我们还是用数组加长度的方式来模拟栈，那么每一次运算都会变得非常简单。设中间结果栈的数组名为 <code class="docutils literal notranslate"><span class="pre">v</span></code>，长度变量为 <code class="docutils literal notranslate"><span class="pre">len</span></code>，那么当遇到运算的时候，假设是要做一次减法运算，只需要这样就可以了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">v</span><span class="p">[</span><span class="n">len</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">v</span><span class="p">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="o">--</span><span class="n">len</span><span class="p">;</span>
</pre></div>
</div>
<p>如果表达式是格式正确的，那么最终的运算结果，即表达式的值，在每一个token都处理完之后就是最终留在栈里的栈顶元素，而且此时栈里有且只有这一个元素。</p>
<p>如果每一个token都处理完了之后，栈里的元素数量不是一个，或者在运算过程中出现了弹空栈的情况，那么表达式一定是格式不正确。</p>
<div class="admonition- admonition">
<p class="admonition-title">思考</p>
<p>虽然算法问题一般不需要考虑表达式格式不正确的情况，但是我们还是有必要知道什么情况下运算结束后栈中元素数量大于一，什么情况下运算过程中会出现弹空栈，分别对应中缀表达式的哪些格式错误，请认真思考这个问题。</p>
</div>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<p>编写计算中缀表达式的函数，输入参数为一个中缀表达式token序列，数组加长度的形式，输出表达式的值，函数原型如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="nf">eval</span><span class="p">(</span><span class="n">Token</span> <span class="n">tokens</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../../400_basic_algo_design.html" title="5. 算法设计方法"
             >下一页</a> |</li>
        <li class="right" >
          <a href="321_stack_1.html" title="4.2.1. 栈：概念、stack容器和实现"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../300_basic_data_structure.html" ><span class="section-number">4. </span>基础数据结构</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../320_stack_queue.html" ><span class="section-number">4.2. </span>特殊线性表：栈和队列</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>