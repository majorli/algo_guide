
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>4.2.1. 栈：概念、stack容器和实现 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="4.2.2. 栈的应用：表达式求值" href="322_stack_2.html" />
    <link rel="prev" title="4.2. 特殊线性表：栈和队列" href="../320_stack_queue.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="322_stack_2.html" title="4.2.2. 栈的应用：表达式求值"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="../320_stack_queue.html" title="4.2. 特殊线性表：栈和队列"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../300_basic_data_structure.html" ><span class="section-number">4. </span>基础数据结构</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../320_stack_queue.html" accesskey="U"><span class="section-number">4.2. </span>特殊线性表：栈和队列</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.2.1. 栈：概念、stack容器和实现</a><ul>
<li><a class="reference internal" href="#id1">4.2.1.1. 栈的概念及基本操作</a></li>
<li><a class="reference internal" href="#stlstack">4.2.1.2. STL栈容器stack</a></li>
<li><a class="reference internal" href="#id2">4.2.1.3. 栈的编程实现</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="../320_stack_queue.html"
                        title="上一章"><span class="section-number">4.2. </span>特殊线性表：栈和队列</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="322_stack_2.html"
                        title="下一章"><span class="section-number">4.2.2. </span>栈的应用：表达式求值</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch03/sec02/321_stack_1.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="stack">
<h1><span class="section-number">4.2.1. </span>栈：概念、stack容器和实现<a class="headerlink" href="#stack" title="永久链接至标题">¶</a></h1>
<p>英语单词 stack 原本的意思是堆垛。想象这样一个仓库里的货物堆垛，它用来堆放一个一个的长方体标准货箱。当有新的货物要入库时，仓库工人用铲车将箱子堆放到堆垛的那个位置最方便？当然是最顶上了，一个一个箱子的依次向上堆就可以了。当货物要出库时，工人师傅又开着铲车进来取箱子，这时候取那个位置的箱子最方便呢？当然还是取最顶上的箱子了，一个一个箱子地依次向下取。这就是仓库里货物堆垛的规则。在这样的规则下，越先入库的货物就越被摆放在堆垛的下部，而越后入库的货物就会被越先取走出库。</p>
<div class="section" id="id1">
<h2><span class="section-number">4.2.1.1. </span>栈的概念及基本操作<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>超级重要的数据结构<strong>栈</strong>的英文名称就叫做 stack，又叫做<strong>后进先出表</strong>（LIFO），意思是 Last In First Out。它就是模仿仓库里的货箱堆垛来实现元素存取的一种特殊的线性表，是我们对它的元素存取方式进行了这样的限制：只允许在它的表尾添加元素，不能在任何其他位置添加；只允许读取表尾的元素，不允许读取任何其他位置的元素。通过这样的限制就实现了先加入栈的元素总是会被后读取，后添加进栈的元素会被先读取到，也就是所谓的先进后出规则。</p>
<p>栈作为一种特殊的线性表，有一些特殊的名称。栈的首元素所在元素称为<strong>栈底</strong>（bottom），尾元素称为<strong>栈顶元素</strong>，但通常会称其后一个位置为<strong>栈顶</strong>（top）。空栈没有栈顶元素，栈顶位置等于栈底位置。无论是用顺序表实现的栈还是用链表实现的栈，一般我们都用下面这样的方式来绘制栈的抽象的示意图：</p>
<img alt="../../_images/321_stack.png" src="../../_images/321_stack.png" />
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>有些教材可能直接把栈顶元素所在的位置称为栈顶，这只是习惯上的不同，实质上没有区别。但是这样做会导致空栈时没有栈顶位置，所以大多数教材都使用栈顶元素的后一个位置作为栈顶。但栈顶元素一定是指栈的尾元素。</p>
</div>
<p>栈必须至少实现两个操作：<strong>压栈</strong>（push）和<strong>弹栈</strong>（pop）。</p>
<p>所谓压栈，就是指向栈顶添加一个薪元素，这也是栈唯一允许的添加元素操作。压栈操作其实就是把新元素放到栈顶位置，成为新的栈顶元素，然后更新栈顶为新栈顶元素的后一个位置。</p>
<p>而弹栈，顾名思义，就是压栈的反向操作，即获取并删除栈顶元素。弹栈操作把当前的栈顶元素作为返回值返回给调用者，并从栈中删除这个元素，当然也要相应地更新栈顶。</p>
<p>压栈和弹栈操作的示意图如下：</p>
<img alt="../../_images/321_stack_push_pop.png" src="../../_images/321_stack_push_pop.png" />
<p>实际应用中有时候会不方便使用同时返回元素的弹栈操作。比如在C++语言中，受到语言本身的限制，如果栈是用动态内存分配来实现动态长度的，而元素是大规模的自定义结构类型，那么在弹栈的时候一定会销毁栈顶元素，而销毁了栈顶元素就无法以引用方式返回元素，只能以传值的方式返回一份原栈顶元素值的复制品，这样做是效率低下的。还有一种情况是程序本身需要使用栈顶元素，但是又不想把它从栈中弹掉。所以在使用C++语言编程时我们常把通常的弹栈操作分成两部分：一个是不返回栈顶元素的弹栈操作，单纯地弹掉栈顶元素而不返回它；另一个是被称为<strong>偷窥</strong>（peek）的操作，单纯地返回栈顶元素（往往是返回引用）而不弹掉它。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>STL的 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器就是这样的设计，它的 <code class="docutils literal notranslate"><span class="pre">pop()</span></code> 成员函数返回类型为 <code class="docutils literal notranslate"><span class="pre">void</span></code>，不返回任何东西。要访问栈顶元素但不弹掉时使用 <code class="docutils literal notranslate"><span class="pre">top()</span></code> 成员函数，它会返回栈顶元素的引用。STL的设计者一定是觉得偷窥这个词不好听。</p>
</div>
<p>栈原则上最少只需要提供压栈和弹栈两种操作，通常会再提供一个访问栈顶元素的功能即可。为了方便使用，往往还会提供一些辅助功能，比如空栈判断、获取长度等。</p>
<p>要自己实现一个栈其实非常简单，用数组或者单链表或者任何其他线性表数据结构作为其基础就很容易实现栈。事实上，STL库的 <code class="docutils literal notranslate"><span class="pre">vector</span></code> 容器或者 <code class="docutils literal notranslate"><span class="pre">list</span></code> 容器都有相当于压栈的成员函数 <code class="docutils literal notranslate"><span class="pre">push_back()</span></code>、相当于弹栈的成员函数 <code class="docutils literal notranslate"><span class="pre">pop_back()</span></code> 和相当于访问栈顶元素的成员函数 <code class="docutils literal notranslate"><span class="pre">back()</span></code>。所以这两个容器就可以直接拿来当做栈使用。但是如果我们需要的确实只是一个栈而不需要其他多余功能时，我们不建议使用这些容器，STL库提供了一个专门的栈容器 <code class="docutils literal notranslate"><span class="pre">stack</span></code>。为什么呢？因为 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器就是一个单纯的栈，相比顺序表或者双链表来说它速度更快、用法更简单。</p>
</div>
<div class="section" id="stlstack">
<h2><span class="section-number">4.2.1.2. </span>STL栈容器stack<a class="headerlink" href="#stlstack" title="永久链接至标题">¶</a></h2>
<p>STL库的栈容器 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 是一个标准的栈结构，它的用法非常简单。和其他任何STL库的东西一样，它使用命名空间 <code class="docutils literal notranslate"><span class="pre">std</span></code>，并且要先引入 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 库。</p>
<p><code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器的构造器很简单，它要么是什么参数都不需要的默认构造器，要么可以用一个别的序列容器来初始化它。例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stack1</span><span class="p">;</span>  <span class="c1">// 生成一个空栈，元素类型为int</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">letters</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span> <span class="c1">// 构造一个元素类型为char的vector，初始化为26个&#39;a&#39;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>   <span class="c1">// 将letters的内容改为26个小写字母</span>
        <span class="n">letters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">stack2</span><span class="p">(</span><span class="n">letters</span><span class="p">);</span> <span class="c1">// 生成一个元素类型为char的栈，并用letters的内容初始化</span>
</pre></div>
</div>
<p><strong>三大基本功能</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器提供了压栈、弹栈和访问栈顶元素三大基本功能，其中弹栈功能不返回栈顶元素，只是单纯地将其删除。对应三个成员函数如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>  <span class="c1">// 压栈，value_type是栈的元素类型</span>
<span class="kt">void</span> <span class="nf">pop</span><span class="p">();</span>                        <span class="c1">// 弹栈，删除栈顶元素</span>
<span class="n">value_type</span> <span class="o">&amp;</span><span class="n">top</span><span class="p">();</span>                 <span class="c1">// 访问栈顶元素，引用返回，故可用于修改栈顶元素</span>
</pre></div>
</div>
<p>这三个成员函数都非常的直观，一看就知道该怎样使用，后面我们会给出一个简单的示例。</p>
<p><strong>三种辅助功能</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器提供了三种辅助功能，空栈测试、获取长度和比较运算。和 <code class="docutils literal notranslate"><span class="pre">vector</span></code> 一样，它们分别用成员函数 <code class="docutils literal notranslate"><span class="pre">empty()</span></code>、<code class="docutils literal notranslate"><span class="pre">size()</span></code> 和六种大小比较运算符来实现，大小比较采用的是字典序规则。事实上这三种辅助功能是所有STL容器通用的，都一样，这里就不再细述了。</p>
<p>下面看一个简单的例子。例如我们定一个字符类型的栈，然后做如下操作，请设想一下会得到怎样的结果？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">s1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;F&#39;</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="n">s1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
                <span class="n">s1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请不运行上面的程序，直接写出运行结果。</p>
<p>要注意的是：<code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器一共就实现了这么几个功能，再没有别的功能了。非常的简洁，运行速度非常快，是一个纯粹的栈。如果在你的程序里，确实只需要这样一个纯粹的栈，请不要用其他容器，就用它。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器除了 <code class="docutils literal notranslate"><span class="pre">top()</span></code> 成员函数，没有任何其他方法可以访问到任何元素！没有方括号加下标值！没有迭代器！</p>
</div>
</div>
<div class="section" id="id2">
<h2><span class="section-number">4.2.1.3. </span>栈的编程实现<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>有时候程序中要使用栈，但是我们不想引入 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器，而是想自己实现。这也是非常简单的，栈既可以用顺序表来实现，也可以用单链表来实现，用链表实现的栈有时候也叫做链栈。</p>
<p>如果能预知在程序运行过程中栈的最大长度，那么我们往往更倾向于自己用数组来实现一个轻量级的栈而不是用 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器。假设栈的最大可能长度为1000个元素，那么用下面这样一个结构就可以定义出一个标准的栈来：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Stack</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">_elements</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">_top</span><span class="p">;</span>

        <span class="n">Stack</span><span class="p">()</span> <span class="p">{</span> <span class="n">_top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_top</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_top</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">T</span> <span class="o">&amp;</span><span class="n">peek</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_elements</span><span class="p">[</span><span class="n">_top</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">_elements</span><span class="p">[</span><span class="n">_top</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">T</span> <span class="o">&amp;</span><span class="n">pop</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_elements</span><span class="p">[</span><span class="o">--</span><span class="n">_top</span><span class="p">];</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面这一个结构就利用数组实现了一个简单的模板栈，最大支持存放1000个元素，数据类型可以是任意的，例如 <code class="docutils literal notranslate"><span class="pre">Stack&lt;int&gt;</span></code> 为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 型元素的栈。结构提供了五个成员函数，每一个都简单到只有一条语句。由于代码过于简单，就不给出注解了，请自行将其看懂。</p>
<p>大小比较运算这里并没有实现，如果要实现也不难，但是一般算法程序确实不太用得到。如果数据类型是明确固定的，甚至可以不用模板，直接在代码里写死即可，那就更加简单了。</p>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<p>仿照上面的代码，自己编写一个元素数据类型为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的简单栈，最多可容纳10000个元素，并且支持栈与栈之间的六种大小比较运算，比较规则为字典序，即：</p>
<ol class="arabic simple">
<li><p>从 <code class="docutils literal notranslate"><span class="pre">_elements[0]</span></code> 开始逐个向后比较两个栈中相同位置的元素，首次出现不同时，那个栈中的元素值小，就认为这个栈小；</p></li>
<li><p>若比较过的每一对相同位置的元素都等值，那么长度短的栈更小；</p></li>
<li><p>若每一对相同位置的元素都等值，且两个栈长度相同，则认为两个栈相等；</p></li>
<li><p>只要两个栈长度不相等，或者任意某一个位置上元素不等值，那么这两个栈就是不相等的。</p></li>
</ol>
<p>完成栈结构的编写后自行设法进行测试，确保栈的功能正确。</p>
</div>
<p>链栈的实现也不难，甚至不需要头部哑节点。但是链栈的栈顶指针无法表示栈的长度，所以我们另需一个单独的存放长度的成员变量。事实上，使用链栈一般都是为了应对程序运行过程中栈的长度无法预先确定的情况，比如在大规模的回溯搜索类算法中，解空间的树结构可能非常庞大（比如11皇后问题的解空间），难以用一个静态的数组来表示，如果要用C++的动态内存技术来实现动态数组那还不如直接使用链栈。</p>
<p>下面是一个简单的链栈结构，其中缺少了部分成员函数的代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Stack</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">_Node</span> <span class="p">{</span>
                <span class="n">T</span> <span class="n">_value</span><span class="p">;</span>
                <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">_Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
                <span class="n">_Node</span><span class="p">()</span> <span class="p">{</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
                <span class="n">_Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">_value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">};</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">_Node</span> <span class="o">*</span><span class="n">_top</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>

        <span class="n">Stack</span><span class="p">()</span> <span class="p">{</span> <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">_top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_size</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">T</span> <span class="o">&amp;</span><span class="n">top</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_top</span><span class="o">-&gt;</span><span class="n">_value</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="c1">// TODO 压栈</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">pop</span><span class="p">()</span>
        <span class="p">{</span>
                <span class="c1">// TODO 弹栈</span>
        <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>请注意，链表本身就是一种依赖动态内存管理的动态数据结构，因此现在每压栈一个新元素，都需要动态分配一个新的节点出来并压入栈顶。同理每弹栈一个元素，就需要释放掉栈顶元素所使用的动态内存。所以链栈就不能在弹栈时返回栈顶元素的引用了。这就是 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器那样设计操作方式的原因，我们在这里也采用了与之相同的方式。</p>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<p>将上述代码中缺失的压栈和弹栈成员函数补全，并进行测试。</p>
</div>
<p>不过坦白地说，如果程序要使用链栈，我们还是建议使用STL库的 <code class="docutils literal notranslate"><span class="pre">stack</span></code> 容器更好，不要自己动手去编程实现了。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="322_stack_2.html" title="4.2.2. 栈的应用：表达式求值"
             >下一页</a> |</li>
        <li class="right" >
          <a href="../320_stack_queue.html" title="4.2. 特殊线性表：栈和队列"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../300_basic_data_structure.html" ><span class="section-number">4. </span>基础数据结构</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../320_stack_queue.html" ><span class="section-number">4.2. </span>特殊线性表：栈和队列</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>