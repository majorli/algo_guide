
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.5.3. 归并排序 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.5.4. 快速排序" href="254_quick_sort.html" />
    <link rel="prev" title="3.5.2. 插入排序" href="252_insertion_sort.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="254_quick_sort.html" title="3.5.4. 快速排序"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="252_insertion_sort.html" title="3.5.2. 插入排序"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../250_sort_algos.html" accesskey="U"><span class="section-number">3.5. </span>基础排序算法</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>上一个主题</h4>
  <p class="topless"><a href="252_insertion_sort.html"
                        title="上一章"><span class="section-number">3.5.2. </span>插入排序</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="254_quick_sort.html"
                        title="下一章"><span class="section-number">3.5.4. </span>快速排序</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec05/253_merge_sort.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">3.5.3. </span>归并排序<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p><strong>归并排序</strong>是一种利用递归的思路设计的快速排序算法。归并排序的时间复杂度为 <span class="math notranslate nohighlight">\(O(n\log n)\)</span>，达到了理论上的时间复杂度下限。但它并不是速度最快的排序算法，快速排序、堆排序在平均情况下的实际运行速度都比归并排序要略快一些。然而归并排序在实际应用中是用途非常广泛非常实用的高速排序算法，原因有三：</p>
<ol class="arabic simple">
<li><p>归并排序的表现极其稳定，不受原序列有序程度的影响，对它来说没有什么最好情况、最差情况或者平均情况，一律是 <span class="math notranslate nohighlight">\(O(n\log n)\)</span> 时间效率。</p></li>
<li><p>归并排序适用于外部排序，例如存放在海量存储设备中的超大型数据库排序，基本上就是用的归并排序算法的外排序版本，而快速排序和堆排序都不太适合改造成外排序版本。</p></li>
<li><p>归并排序的编程非常简单，只要会归并过程就可以轻松写出一个正确的归并排序来（关于归并过程，请参考3.4.10.1小节）。</p></li>
</ol>
<p>归并排序是一种稳定的排序算法，它的缺点是有较大的内存空间使用，但是在算法竞赛问题中一般空间不太成为大问题。所以归并排序无论在算法竞赛问题中，还是在实践应用中都是非常重要的一种排序算法。</p>
<p><strong>归并排序的原理和实现</strong></p>
<p>归并排序的算法思路起源于对两个有序序列的归并过程的利用。假设要排序的序列可以分为前后两个部分，这两个部分各自都是有序的，例如整数序列 [1,3,4,5,1,2,6,7]，它的前4个数的子序列 [1,3,4,5] 和后4个数的子序列 [1,2,6,7] 各自都是有序子序列。那么对这个序列的排序就变得非常简单，只要用一次归并过程把前后两个有序子序列归并起来就可以了，这个过程是 <span class="math notranslate nohighlight">\(O(n)\)</span> 时间的。</p>
<p>当然，在实际编程中，要原地归并前后两个子序列不是不可以，但是过程会比较复杂。所以编程的时候采用新开辟一块空间用作临时数组，把两个子序列归并到这个临时数组里面去，归并完成后再把这个临时数组里已经有序的新序列复制回原数组的方法。这个过程利用C++语言的动态内存管理功能和块复制功能可以轻松的实现。</p>
<p>以整数排序为例，例如我们要归并一个数组中指定的两个连续的有序子序列，原数组为 <code class="docutils literal notranslate"><span class="pre">d[]</span></code>，要归并的两个连续子序列用三个位置变量 <code class="docutils literal notranslate"><span class="pre">l,</span> <span class="pre">r,</span> <span class="pre">mid</span></code> 表示，分别为含头不含尾的区域 <code class="docutils literal notranslate"><span class="pre">[l,</span> <span class="pre">mid)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">[mid,</span> <span class="pre">r)</span></code>，即前一子序列从 <code class="docutils literal notranslate"><span class="pre">d[l]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">d[mid-1]</span></code>，后一子序列从 <code class="docutils literal notranslate"><span class="pre">d[mid]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">d[r-1]</span></code>。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>计算机编程时遇到表示一个范围，一定要记住遵循“含头不含尾”的原则，相当于数学上的左闭右开区间。无论今后用什么语言编程，这是一个惯例。</p>
</div>
<p>我们可以先编写一个工具函数，用来实现上述的归并过程。在这个函数里，要用到C++动态内存管理功能和cstring库提供的内存块复制功能。对内存块操作不熟悉的可以回顾一下2.3节的内容，对C++动态内存管理不熟悉的请先回顾2.5节，若是归并过程也忘了的话，请复习3.4.10节。下面我们就直接给出数组中两个连续的有序子序列的归并过程工具函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="c1">// 归并函数</span>
<span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * 对数组 d 的 [l, mid) 和 [mid, r) 左右两个有序部分进行归并</span>
<span class="cm"> * d: 待归并的数组</span>
<span class="cm"> * l: 要归并的前半部分左端点</span>
<span class="cm"> * r: 要归并的右半部分右端点</span>
<span class="cm"> * mid: 要归并的左半部分右端点，同时也是右半部分左端点</span>
<span class="cm"> * 根据含头不含尾的规则，d[mid] 为右半部分的第一个元素，不含在左半部分中</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 动态申请归并过程使用的临时数组，长度为要归并的所有元素</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">];</span>
	<span class="c1">// 归并过程，参考3.4.10.1小节归并法的介绍</span>
	<span class="c1">// 将 d 数组中 [l, mid) 和 [mid, r) 两部分归并到临时数组 temp 中</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="k">else</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	<span class="c1">// 使用内存块复制快速将归并好的数据复制回原数组中的原位置</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="c1">// 用 new 命令申请的动态内存必须用完就销毁，有借有还</span>
	<span class="k">delete</span> <span class="p">[]</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>虽然不能寄希望于待排序的原序列总是可以分为前后两个有序子序列，但是至少我们现在可以这样想，假如有办法把原序列一分为二，然后分别先对前后两个子序列进行排序，这样我们不就可以在前后都排序完成后，一次归并把整个序列变成有序的了吗？这就是归并排序的基本思路。</p>
<p>二分序列很简单，只要算出中间位置就可以了。问题是用什么方法对前后两个子序列分别排序呢？如果用插入排序，那么前后两次的排序时间都是 <span class="math notranslate nohighlight">\(O(n^2)\)</span>，整个归并排序的时间复杂度也被限制在了 <span class="math notranslate nohighlight">\(O(n^2)\)</span> 了，这样做毫无意义。所以不能简单地利用其他排序方法来做这件事情，这里我们要借助递归的思路。基本的思想就是把原序列分成前后两半，分别对它们进行同样方法的排序。即在对前一半进行排序的时候，仍然将其分为前后两半，分别进行同样的排序。对后一半的排序也一样，对第二次细分出来的四个子序列也一样。这就构成了一个递归的过程，只要这个过程总有一天可以有一种特殊情况使得其不需要再进一步二分递归下去，可以直接返回结果，那么这个递归就可行。</p>
<p>幸运的是，我们知道如果一个子序列已经被细分到只剩一个元素了，那么单个元素天生有序，它就不需要再进一步递归地去排序了，我们直接不去处理它就可以了。这个就是上述递归的二分归并排序的终止条件。现在我们就可以写出归并排序的算法结构了，<span class="math notranslate nohighlight">\(A\)</span> 为要排序的序列，<span class="math notranslate nohighlight">\(l,r\)</span> 分别为序列中要排序部分的左右端点位置，按照含头不含尾的原则，表示要对范围 <span class="math notranslate nohighlight">\([l, r)\)</span> 区间内的元素 <span class="math notranslate nohighlight">\(A[l],\dots,A[r-1]\)</span> 进行排序：</p>
<div class="admonition- admonition">
<p class="admonition-title">归并排序算法</p>
<p><span class="math notranslate nohighlight">\(\text{MergeSort}(A, l, r):\)</span></p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(mid\leftarrow\lfloor(l+r)/2\rfloor\)</span></p>
<p><span class="math notranslate nohighlight">\(\text{IF  }mid-l\gt1\text{  THEN  MergeSort}(A, l, mid)\)</span></p>
<p><span class="math notranslate nohighlight">\(\text{IF  }r-mid\gt1\text{  THEN  MergeSort}(A, mid, r)\)</span></p>
<p><span class="math notranslate nohighlight">\(\text{Merge}(A, l, r, mid)\)</span></p>
</div></blockquote>
</div>
<p>其中的子算法 <span class="math notranslate nohighlight">\(\text{Merge}(A, l, r, mid)\)</span> 前面已经完成了代码编写，即归并过程的工具函数，所以编写这个程序就非常简单了吧。在编写代码之前，为了加深对递归过程的直观理解，我们先来看一个简单的实例，假设我们要对序列 [3, 2, 9, 1] 进行排序。</p>
<p>原序列长度为4，故分为 [3, 2] 和 [9, 1] 两个子序列并先后递归进行排序再进行归并</p>
<ol class="arabic simple">
<li><p>归并排序 [3, 2]，其长度为2，故分为 [3] 和 [2] 两个子序列并先后递归进行排序再进行归并</p>
<ol class="arabic simple">
<li><p>归并排序 [3]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并排序 [2]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并 [3] 和 [2]，得到子序列 [2, 3]</p></li>
</ol>
</li>
<li><p>归并排序 [9, 1]，其长度为2，故分为 [9] 和 [1] 两个子序列并先后递归进行排序再进行归并</p>
<ol class="arabic simple">
<li><p>归并排序 [9]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并排序 [1]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并 [9] 和 [1]，得到子序列 [1, 9]</p></li>
</ol>
</li>
<li><p>归并 [2, 3] 和 [1, 9]，得到 [1, 2, 3, 9]</p></li>
</ol>
<p>至此排序完成。对于长度不是2的幂次方的序列，其排序过程也是一样的，无非有些时候不同分支的结束情况会不同，这并不影响排序过程。例如对序列 [3, 2, 9, 1, 4] 进行排序：</p>
<p>原序列长度为5，按照除2取整得到的二分点为2，即分为 [3, 2] 和 [9, 1, 4] 两个子序列，先后递归排序再进行归并</p>
<ol class="arabic simple">
<li><p>归并排序 [3, 2]，其长度为2，故分为 [3] 和 [2] 两个子序列并先后递归进行排序再进行归并</p>
<ol class="arabic simple">
<li><p>归并排序 [3]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并排序 [2]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并 [3] 和 [2]，得到子序列 [2, 3]</p></li>
</ol>
</li>
<li><p>归并排序 [9, 1, 4]，其长度为3，故被分为 [9] 和 [1, 4] 两个子序列并先后递归进行排序再进行归并</p>
<ol class="arabic simple">
<li><p>归并排序 [9]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并排序 [1, 4]，其长度为2，分为 [1] 和 [4] 两个子序列先后进行递归排序再进行归并</p>
<ol class="arabic simple">
<li><p>归并排序 [1]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并排序 [4]，其长度为1，不做任何处理即结束</p></li>
<li><p>归并 [1] 和 [4]，得到子序列 [1, 4]</p></li>
</ol>
</li>
<li><p>归并 [9] 和 [1, 4]，得到子序列 [1, 4, 9]</p></li>
</ol>
</li>
<li><p>归并 [2, 3] 和 [1, 4, 9]，得到 [1, 2, 3, 4, 9]</p></li>
</ol>
<p>归并结束。</p>
<p>下面是归并排序的代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="c1">// 输出数组元素的辅助函数</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="c1">// 归并排序主函数</span>
<span class="kt">void</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">);</span>

<span class="c1">// 归并函数</span>
<span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">100000</span><span class="p">],</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">merge_sort</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">print</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 归并排序的主函数，将待排序数组二分为左右两部分，分别递归地进行排序并将结果归并</span>
<span class="cm"> * d: 待排序的数组</span>
<span class="cm"> * l: 待排序部分的左端点，包含 d[l]</span>
<span class="cm"> * r：待排序部分的右端点，不包含 d[r]</span>
<span class="cm"> * 根据含头不含尾的规则，待排序部分的长度即为 r - l</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 按含头不含尾的规则，将待排序部分二分为 [l, mid) 和 [mid, r) 两半</span>
	<span class="c1">// 两个部分恰好仍然是含头不含尾的规则，长度分为为 mid - l 和 r - mid</span>
	<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="c1">// 若左半部分长度大于1，则递归地对其进行归并排序</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
	<span class="c1">// 若右半部分长度大于1，则递归地对其进行归并排序</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">mid</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="c1">// 左右两部分递归地完成排序后，将二者进行归并，完成完整的排序</span>
	<span class="n">merge</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 对数组 d 的 [l, mid) 和 [mid, r) 左右两个有序部分进行归并</span>
<span class="cm"> * d: 待归并的数组</span>
<span class="cm"> * l: 要归并的前半部分左端点</span>
<span class="cm"> * r: 要归并的右半部分右端点</span>
<span class="cm"> * mid: 要归并的左半部分右端点，同时也是右半部分左端点</span>
<span class="cm"> * 根据含头不含尾的规则，d[mid] 为右半部分的第一个元素，不含在左半部分中</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 动态申请归并过程使用的临时数组，长度为要归并的所有元素</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">];</span>
	<span class="c1">// 归并过程，参考3.4.10.1小节归并法的介绍</span>
	<span class="c1">// 将 d 数组中 [l, mid) 和 [mid, r) 两部分归并到临时数组 temp 中</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="k">else</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	<span class="c1">// 使用内存块复制快速将归并好的数据复制回原数组中的原位置</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="c1">// 用 new 命令申请的动态内存必须用完就销毁，有借有还</span>
	<span class="k">delete</span> <span class="p">[]</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在许多算法书中归并排序的主函数会用另一种写法：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="n">merge</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这两种写法本质上是一样的，你能看明白吗？</p>
<p><strong>归并排序算法分析</strong></p>
<p>归并排序在每一次归并的时候，会用到和被归并部分长度相等的临时空间。但是每次归并结束后这些空间会被释放，所以临时空间的占用不用积累，最大的时候等于原序列所占的空间，即最后一次归并的时候。所以归并排序的空间复杂度为 <span class="math notranslate nohighlight">\(O(n)\)</span>。</p>
<p>从归并排序的过程可以看出，它对原序列中元素的有序程度完全没有感觉。无论原序列中的元素是不是有序、逆序，也不管其有序程度多大，算法总是不管不顾地进行不断二分不断归并，一次不会多一次不会少。因此归并排序的时间复杂度任何情况下都是一样的，无所谓最好、最差还是平均情况。</p>
<p>归并排序是一个非常典型的简单递归算法，其工作量可以用一个递推公式来表示。从算法的主过程可以看出，工作分为三部分，两次二分的递归调用和一次归并，递归的工作量各为原工作量的一半，归并的工作量为最多 <span class="math notranslate nohighlight">\(n\)</span> 次元素比较。所以如果假设整个排序过程的工作量为 <span class="math notranslate nohighlight">\(T(n)\)</span>，那么就有：</p>
<div class="math notranslate nohighlight">
\[T(n)=2T({n\over2})+n,T(1)=0\]</div>
<p>可以用迭代法，也可以用递归树的方法来求解这个递推方程。这里不需要考虑数据量 <span class="math notranslate nohighlight">\(n\)</span> 的取值情况，只需要假设它是2的幂次方就可以了，即假设 <span class="math notranslate nohighlight">\(n=2^k\)</span>，也就是说 <span class="math notranslate nohighlight">\(k=\log n\)</span>。对于不是2的幂次方的情况，我们在计算时间复杂度时就取恰好比它大的那个2的幂次方作为上界，比如对于 <span class="math notranslate nohighlight">\(n=6\)</span>，我们可以取 <span class="math notranslate nohighlight">\(n=8\)</span> 的情况作为它的上界，这并不会对结果的阶造成影响。</p>
<p>对所有基于二分的算法进行时间复杂度分析时，都可以这样只考虑 <span class="math notranslate nohighlight">\(n=2^k\)</span> 的情况。用迭代法计算如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
T(n)&amp;=T(2^k)=2T({n\over2})+n=2T(2^{k-1})+n\\
    &amp;=2[2T(2^{k-2})+{n\over2}]+n=2^2T(2^{k-2})+2n\\
    &amp;=2^2[2T(2^{k-3})+{n\over4}]+2n=2^3T(2^{k-3})+3n\\
    &amp;=\cdots\\
    &amp;=2^kT(1)+kn=kn\\
\therefore T(n)&amp;=O(n\log n)
\end{align}\end{split}\]</div>
<p>作为练习，大家可以试着用画递归树的方法来解一解这个递推方程。</p>
<p>最后要说明的是，归并排序是稳定的排序算法。为什么？还是请大家自己去思考。</p>
<p><strong>归并排序算法的优化</strong></p>
<p>归并排序的理论时间复杂度已经达到了最低限 <span class="math notranslate nohighlight">\(O(n\log n)\)</span>，在实际应用中，它会略微地比快速排序慢一些。那么在实践中能不能对它再进行一些改进呢？</p>
<p>前面我们说过，二分插入排序在数据量比较小的时候，实际运行速度会比利用递归的 <span class="math notranslate nohighlight">\(O(n\log n)\)</span> 算法还略快一些，原因是它没有递归调用带来的额外开销。那么我们能不能对归并排序做这样的优化，当待排序的子序列中元素少于一定的数量时，就不要再进一步二分和递归下去了，我们直接用二分插入算法完成这个子序列的排序就可以了。这样是不是能够让归并排序变得更加快一些呢？这个问题留给大家作为一次实验练习，请大家按照下面的要求完成实验。</p>
<p>实验目的：测试二分插入排序和归并排序的实际运行速度比较，并按照比较结果对二分归并排序进行优化尝试，评估优化效果。</p>
<p>实验步骤：</p>
<p>1、编写标准的归并排序和二分插入排序程序，输入格式为第一行一个整数 <span class="math notranslate nohighlight">\(n\)</span>，<span class="math notranslate nohighlight">\(0\lt n \lt 10^5\)</span>，第二行为 <span class="math notranslate nohighlight">\(n\)</span> 个int型范围内的整数，数和数之间用一个空格隔开。程序的输出均为一行，即已经排好序的 <span class="math notranslate nohighlight">\(n\)</span> 个输入整数，数和数之间以一个空格隔开。完成上述两个程序的编写并进行正确性测试。</p>
<p>2、在上述两个程序中，增加对排序部分的运行时间测定，测定运行时间的方法参考2.1节。此处需要注意三个问题：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>当数据量大时，输入和输出会占用许多时间，而且根据计算机环境的不同，可能会有很大的波动，测定排序时间不应包括输入和输出使用的时间。</p></li>
<li><p>整数排序算法的运行时间非常快，当数据量不大时，用毫秒会精度不够，无法比较，请设法使用微秒（百万分之一秒）为单位进行测速。</p></li>
<li><p>同样数据量的多次排序，运行时间也会有上下波动，为了测试精确，请设法尽量消除误差。</p></li>
</ol>
</div></blockquote>
<p>3、下载此工具软件：<a class="reference download internal" download="" href="../../_downloads/874bcd01820515e306f41ce9162f4109/randints.cpp"><code class="xref download docutils literal notranslate"><span class="pre">随机整数序列生成器</span></code></a>，自行编译成可执行程序。使用此工具，输入一个整数 <span class="math notranslate nohighlight">\(n\)</span>，就会按照上述的排序程序输入格式生成一批随机的整数，可以用作排序程序的输入。有两种使用方法：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>使用输出重定向功能将生成的数据保存在一个输入文件中，例如 <code class="docutils literal notranslate"><span class="pre">./randints</span> <span class="pre">&gt;</span> <span class="pre">s1.in</span></code> 即可将生成的数据保存到文件 <code class="docutils literal notranslate"><span class="pre">s1.in</span></code> 中，然后使用输入重定向功能，例如 <code class="docutils literal notranslate"><span class="pre">./merge_sort</span> <span class="pre">&lt;</span> <span class="pre">s1.in</span></code> 将这个输入文件作为排序程序的输入。</p></li>
<li><p>使用管道功能，即连续运行两个程序，并将第一个程序的输出直接输送给第二个程序用作输入，例如 <code class="docutils literal notranslate"><span class="pre">./randints</span> <span class="pre">|</span> <span class="pre">./merge_sort</span></code> 命令会先运行 <code class="docutils literal notranslate"><span class="pre">randints</span></code> 程序，然后运行 <code class="docutils literal notranslate"><span class="pre">merge_sort</span></code> 程序，并将前者的输出直接作为后者的输入。</p></li>
</ol>
<p>上述的输入输出重定向和管道功能无论是Linux系统的Terminal终端窗口还是Windows系统的cmd命令窗口都是支持的，唯一的不同是Windows系统下运行当前目录里的程序时不需要在程序名称之前加上表示当前目录的 <code class="docutils literal notranslate"><span class="pre">./</span></code>，直接用程序名就可以了，Linux下则必须有 <code class="docutils literal notranslate"><span class="pre">./</span></code>，包括管道命令的后一个程序也必须有。</p>
<p>对输入输出重定向和管道命令还有疑惑的可以参考这个网页：<a class="reference external" href="https://blog.csdn.net/u014532901/article/details/79742175">Linux命令中的管道和重定向</a></p>
</div></blockquote>
<p>4、从少到多地使用多种数据量对两种排序算法的运行速度进行测试，查看二分插入排序在数据量小的时候会不会快于归并排序，如果会则尝试找到分界点。注意，计算机程序运行的环境错综复杂，分界点不会是一个确定不变的数值，不同的计算机上分界点也会略有不同，但总应该会有一个比较靠谱的分界区域，大概在几百左右。</p>
<p>5、尝试利用找到的分界点对归并排序进行优化，编写程序，测试正确，并用上述方法测定运行速度，和标准的归并排序程序进行对比，得出实验结论。</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="254_quick_sort.html" title="3.5.4. 快速排序"
             >下一页</a> |</li>
        <li class="right" >
          <a href="252_insertion_sort.html" title="3.5.2. 插入排序"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../250_sort_algos.html" ><span class="section-number">3.5. </span>基础排序算法</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>