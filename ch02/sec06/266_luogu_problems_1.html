
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.6.6. 复杂排序技巧：排座椅（洛谷P1056） &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.6.7. 数组环形访问：玩具谜题（洛谷P1563）" href="267_luogu_problems_2.html" />
    <link rel="prev" title="3.6.5. 组合生成算法" href="265_choosing.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="267_luogu_problems_2.html" title="3.6.7. 数组环形访问：玩具谜题（洛谷P1563）"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="265_choosing.html" title="3.6.5. 组合生成算法"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../260_other_algos.html" accesskey="U"><span class="section-number">3.6. </span>基础组合算法与模拟算法</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>上一个主题</h4>
  <p class="topless"><a href="265_choosing.html"
                        title="上一章"><span class="section-number">3.6.5. </span>组合生成算法</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="267_luogu_problems_2.html"
                        title="下一章"><span class="section-number">3.6.7. </span>数组环形访问：玩具谜题（洛谷P1563）</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec06/266_luogu_problems_1.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="p1056">
<span id="index-0"></span><h1><span class="section-number">3.6.6. </span>复杂排序技巧：排座椅（洛谷P1056）<a class="headerlink" href="#p1056" title="永久链接至标题">¶</a></h1>
<p><strong>题目描述</strong></p>
<p>上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 <span class="math notranslate nohighlight">\(D\)</span> 对同学上课时会交头接耳。</p>
<p>同学们在教室中坐成了 <span class="math notranslate nohighlight">\(M\)</span> 行 <span class="math notranslate nohighlight">\(N\)</span> 列，坐在第 <span class="math notranslate nohighlight">\(i\)</span> 行第 <span class="math notranslate nohighlight">\(j\)</span> 列的同学的位置是 <span class="math notranslate nohighlight">\((i,j)\)</span>，为了方便同学们进出，在教室中设置了 <span class="math notranslate nohighlight">\(K\)</span> 条横向的通道，<span class="math notranslate nohighlight">\(L\)</span> 条纵向的通道。</p>
<p>于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 <span class="math notranslate nohighlight">\(2\)</span> 个会交头接耳的同学，那么他们就不会交头接耳了。</p>
<p>请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。</p>
<p><strong>输入格式</strong></p>
<p>第一行，有 <span class="math notranslate nohighlight">\(5\)</span> 个用空格隔开的整数，分别是 <span class="math notranslate nohighlight">\(M,N,K,L,D(2 \le N,M \le 1000,0 \le K \lt M,0 \le L \lt N,D \le 2000)\)</span>。</p>
<p>接下来的 <span class="math notranslate nohighlight">\(D\)</span> 行，每行有 <span class="math notranslate nohighlight">\(4\)</span> 个用空格隔开的整数。第 <span class="math notranslate nohighlight">\(i\)</span> 行的 <span class="math notranslate nohighlight">\(4\)</span> 个整数 <span class="math notranslate nohighlight">\(X_i,Y_i,P_i,Q_i\)</span>，表示坐在位置 <span class="math notranslate nohighlight">\((X_i,Y_i)\)</span> 与 <span class="math notranslate nohighlight">\((P_i,Q_i)\)</span> 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。</p>
<p>输入数据保证最优方案的唯一性。</p>
<p><strong>输出格式</strong></p>
<p>共两行。</p>
<p>第一行包含 <span class="math notranslate nohighlight">\(K\)</span> 个整数 <span class="math notranslate nohighlight">\(a_1,a_2,\ldots,a_K\)</span>，表示第 <span class="math notranslate nohighlight">\(a_1\)</span> 行和 <span class="math notranslate nohighlight">\(a_1+1\)</span> 行之间、第 <span class="math notranslate nohighlight">\(a_2\)</span> 行和 <span class="math notranslate nohighlight">\(a_2+1\)</span> 行之间、…、第 <span class="math notranslate nohighlight">\(a_K\)</span> 行和第 <span class="math notranslate nohighlight">\(a_K+1\)</span> 行之间要开辟通道，其中 <span class="math notranslate nohighlight">\(a_i \lt a_{i+1}\)</span>，每两个整数之间用空格隔开（行尾没有空格）。</p>
<p>第二行包含 <span class="math notranslate nohighlight">\(L\)</span> 个整数 <span class="math notranslate nohighlight">\(b_1,b_2,\ldots,b_L\)</span>，表示第 <span class="math notranslate nohighlight">\(b_1\)</span> 列和 <span class="math notranslate nohighlight">\(b_1+1\)</span> 列之间、第 <span class="math notranslate nohighlight">\(b_2\)</span> 列和 <span class="math notranslate nohighlight">\(b_2+1\)</span> 列之间、…、第 <span class="math notranslate nohighlight">\(b_L\)</span> 列和第 <span class="math notranslate nohighlight">\(b_L+1\)</span> 列之间要开辟通道，其中 <span class="math notranslate nohighlight">\(b_i \lt b_{i+1}\)</span>，每两个整数之间用空格隔开（列尾没有空格）。</p>
<p><strong>输入输出样例</strong></p>
<p>输入：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2
2 4
</pre></div>
</div>
<p><strong>说明/提示</strong></p>
<img alt="../../_images/266_p1056.png" src="../../_images/266_p1056.png" />
<p>上图中用符号*、※、+标出了 <span class="math notranslate nohighlight">\(3\)</span> 对会交头接耳的学生的位置，图中 <span class="math notranslate nohighlight">\(3\)</span> 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。</p>
<p><em>2008 年普及组第二题</em></p>
<p><strong>题解</strong></p>
<p>本题的算法思路是很简单的，但实际编程需要用到一些排序技巧，否则会变得比较复杂。</p>
<p>题目要求给出 <span class="math notranslate nohighlight">\(K\)</span> 条行通道和 <span class="math notranslate nohighlight">\(L\)</span> 条列通道，能够分隔开<em>“尽可能多”</em> 的交头接耳同学对，而且<em>“输入数据保证最优方案的唯一性”</em>，所以可以用一种非常简单粗暴的思路来解决问题（其实是一种贪心法的思路）：假设在所有行之间和列之间都开辟通道，计算出它们各自能隔离开的交头接耳同学对数，然后按照从多向少的原则，取 <span class="math notranslate nohighlight">\(K\)</span> 条行通道和 <span class="math notranslate nohighlight">\(L\)</span> 条列通道就是最优解了。</p>
<p>根据题目给出的数据范围可知，行、列通道可能的数量都是至少有1条，至多999条，用其下方的行号或左边的列号作为通道编号，则编号的范围就是1号到999号。故可以用两个长度为1000的数组来分别表示所有可能的行列通道，数组的下标就对应通道编号。</p>
<p>首先要计算每一条通道总共可以隔开的交头接耳学生对数，所以定义好通道数组后先初始化为全0，因为还不知道它们都能隔开多少对。随后在读入数据时，一边读取交头接耳学生对的行列坐标 <span class="math notranslate nohighlight">\((X,Y)-(P,Q)\)</span>，一边根据坐标值来判断出哪一条通道可以将其隔开，将相应通道的数组元素值加1。读完所有的学生对坐标后，这个统计工作就完成了。所以读入的学生对坐标并不需要保存下来，属于用过即扔的数据。</p>
<p>这里有一个需要注意的地方，题目并没有说输入数据中的交头接耳学生对坐标一定是左前右后的或下前上后的。换句话说，对于一左一右的情况，只能知道两位学生的行坐标相同 <span class="math notranslate nohighlight">\(X=P\)</span>，但不能保证 <span class="math notranslate nohighlight">\(Y\lt Q\)</span>，因此不能简单地以为此时通道编号就是 <span class="math notranslate nohighlight">\(Y\)</span> 号列通道，而应该是是 <span class="math notranslate nohighlight">\(\max\{Y,Q\}\)</span> 号列通道。对于一上一下的情况也是类似。在编程的时候可以使用algorithm库的 <code class="docutils literal notranslate"><span class="pre">min()</span></code> 函数来取最小值，不需要自己写判断语句或者三元表达式了，这是C++语言编程所推荐的方式。</p>
<p>对于每一套实际的测试数据，可能的行通道一共有 <span class="math notranslate nohighlight">\(M-1\)</span> 条，列通道 <span class="math notranslate nohighlight">\(N-1\)</span> 条。统计好它们各自能隔开的学生对数之后，需要对它们进行排序，然后分别取隔开学生对数最多的 <span class="math notranslate nohighlight">\(K\)</span> 条行通道和 <span class="math notranslate nohighlight">\(L\)</span> 条列通道就是最优解。听起来很简单，但是细想一下还是有一定的麻烦。</p>
<p>如果简单地对统计好的数组进行排序，排序结束之后就丢失了通道的编号信息了，比如我们确实可以得知隔开学生对数最多的通道到底隔开了几对交头接耳学生，但是却不知道这条通道是几号通道了。因此我们应该把通道编号（也就是数组的下标）一起带数据里去进行排序，而且这个附带进去的编号还不能影响排序结果，排的顺序仍然应该是按照“隔开的学生对数”的。这其实就是一个我们在排序这一节讲过的多关键字排序，主关键字是数组里原先统计好的数据，即“隔开的学生对数”，次关键字是“通道编号”，只有在主关键字相等的情况下才允许次关键字对局部的顺序产生影响。根据题目给出的取值范围，这两个关键字取值范围都不大，事实上都在1000以内，所以我们可以采用关键字拼接的技巧，把次关键字“通道编号”拼接到主关键字后面去，即数组元素的新值为原值乘1000再加上下标。</p>
<p>举例来说，如果2号通道可以隔开3对学生，那么就把对应数组元素的值拼接成 <span class="math notranslate nohighlight">\(3\times1000+2=3002\)</span>，如果4号通道不能隔开任何一对交头接耳学生，那么它对应的数组元素新值为 <span class="math notranslate nohighlight">\(0\times1000+4=4\)</span>，直接变成了通道号的值。请想一想，经过这样的拼接之后，是不是确实可以符合我们需要的排序规则要求了。</p>
<p>现在就可以对行通道数组的 <span class="math notranslate nohighlight">\([1,M)\)</span> 段、列通道数组的 <span class="math notranslate nohighlight">\([1,N)\)</span> 段进行排序了，使用algorithm库的 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 函数排序即可，这里不需要稳定性。</p>
<p>这里还有一个小小的却很实用的额外技巧，按照题意，解是从大向小取的，整数数组用 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 排的是升序，所以排完序之后取解需要从后向前取。这种逆向行驶的操作总是会让人不愉快，如果能够进行降序排序就更好了，我们只要排完序直接取前 <span class="math notranslate nohighlight">\(K\)</span> 个行通道和前 <span class="math notranslate nohighlight">\(L\)</span> 个列通道就好，这样的顺着习惯的方向取范围的代码写起来就非常舒适，不用多动一点脑筋。所以怎么让 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 对一段整数进行降序排序呢？</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>没有比“用相反数进行常规升序排序”更简单的数值排降序方法了，所以你懂得怎么做了吧。</p>
</div>
<p>当然了上面这个小技巧用不用都无所谓，如果对逆向行驶自觉得心应手的，不用也可以。</p>
<div class="admonition- admonition">
<p class="admonition-title">思考</p>
<p>上述的数据拼接处理还有一个有趣的副作用，在本题的情况下，很可能会让 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 函数运行地更快一些。这是为什么？请思考一下。</p>
</div>
<p>最后一步操作，是按照输出格式的要求对得到的解再进行一次排序。因为输出格式要求按顺序（升序）输出通道编号，所以在输出之前，需要把数据中的主关键字部分去掉，只留下次关键字，即通道编号，然后再排升序一次。这个操作很简单，直接除1000取余数即可。如果前面用了相反数排序，那么还需要再取一次相反数，把负数变回正数。此后按照题目所要求的格式输出结果即可。</p>
<p>下面是一种可以AC本题的代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>      <span class="c1">// 遵守C++代码惯例，用小写字母命名变量</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

        <span class="c1">// 所有可能的行、列通道，行通道用其下边一行的行号为编号，列通道用其左边一列的列号为编号</span>
        <span class="c1">// 行、列通道的编号最小的为1号，最大可能的为999号</span>
        <span class="c1">// 数组下标对应通道位置号，元素值为该位置的通道能隔开的交头接耳学生对数</span>
        <span class="kt">int</span> <span class="n">split_rows</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">},</span> <span class="n">split_cols</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>  <span class="c1">// 这些学生对的坐标值不需要保存</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="c1">// 行坐标相等，表示一左一右两位同学，用&quot;较小的列坐标&quot;号通道可以隔开</span>
                        <span class="n">split_cols</span><span class="p">[</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
                <span class="k">else</span>        <span class="c1">// 否则即为列坐标相等，表示一前一后，用&quot;较小的行坐标&quot;号通道可以隔开</span>
                        <span class="n">split_rows</span><span class="p">[</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 通道能隔开学生的对数 * 1000 + 通道编号，再取负数，则进行排序时，相当于双关键字排序</span>
        <span class="c1">// 主关键字为&quot;通道能隔开学生的对数&quot;，副关键字为&quot;通道编号&quot;</span>
        <span class="c1">// 取负数是为了实现绝对值的逆序排序</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">split_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">split_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">split_cols</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">split_cols</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">split_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">split_rows</span> <span class="o">+</span> <span class="n">m</span><span class="p">);</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">split_cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">split_cols</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
        <span class="c1">// 取前 k 个行通道和前 l 个列通道即得到最优解，接下来要对最优解按照通道位置编号再次排序</span>
        <span class="c1">// 故将元素值绝对值除1000取余，变为通道编号，再进行排序就符合了输出格式要求</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">split_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">split_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">split_cols</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">split_cols</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">split_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">split_rows</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">split_cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">split_cols</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 按照输出格式要求输出最优解，行末不能有空格</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">split_rows</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">split_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">split_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">split_cols</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>AC截图：</p>
<img alt="../../_images/266_p1056_ac.png" src="../../_images/266_p1056_ac.png" />
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="267_luogu_problems_2.html" title="3.6.7. 数组环形访问：玩具谜题（洛谷P1563）"
             >下一页</a> |</li>
        <li class="right" >
          <a href="265_choosing.html" title="3.6.5. 组合生成算法"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../260_other_algos.html" ><span class="section-number">3.6. </span>基础组合算法与模拟算法</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>