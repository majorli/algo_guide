
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.1.1. 最大公因数与最小公倍数 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.1.2. 和质数相关的基础算法" href="212_primes.html" />
    <link rel="prev" title="3.1. 简单数值算法" href="../210_basic_number_algos.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="212_primes.html" title="3.1.2. 和质数相关的基础算法"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="../210_basic_number_algos.html" title="3.1. 简单数值算法"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../210_basic_number_algos.html" accesskey="U"><span class="section-number">3.1. </span>简单数值算法</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.1.1. 最大公因数与最小公倍数</a><ul>
<li><a class="reference internal" href="#id2">3.1.1.1. 最大公因数</a></li>
<li><a class="reference internal" href="#id3">3.1.1.2. 最小公倍数</a></li>
<li><a class="reference internal" href="#id4">3.1.1.3. 互质判断</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="../210_basic_number_algos.html"
                        title="上一章"><span class="section-number">3.1. </span>简单数值算法</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="212_primes.html"
                        title="下一章"><span class="section-number">3.1.2. </span>和质数相关的基础算法</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec01/211_gcd_lcm.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">3.1.1. </span>最大公因数与最小公倍数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2><span class="section-number">3.1.1.1. </span>最大公因数<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>数学中一般用 <span class="math notranslate nohighlight">\(\gcd(a,b)\)</span> 表示两个整数 <span class="math notranslate nohighlight">\(a\)</span> 和 <span class="math notranslate nohighlight">\(b\)</span> 的最大公因数。显然，此运算满足交换律。</p>
<div class="math notranslate nohighlight">
\[\gcd(a,b)=\gcd(b,a)\]</div>
<p>求取两个正整数的最大公因数一般采用辗转相除法，也称为欧几里德法，是古希腊数学家欧几里德发现的一种用来快速计算两个整数的最大公因数的算法。这个算法非常快速，而且非常适合计算机算法实现。辗转相除法求最大公因数的原理来源于最大公因数的两个性质：</p>
<ol class="arabic simple">
<li><p>任何整数和0的最大公因数，它和它自己的最大公因数都就是这个整数自己。</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\gcd(a,0)=\gcd(a,a)=a\]</div>
<ol class="arabic simple" start="2">
<li><p>两个不相等的整数的最大公因数等于大数除以小数得到的余数和小整数的最大公因数。</p></li>
</ol>
<div class="math notranslate nohighlight">
\[a\gt b\implies \gcd(a,b)=\gcd(a \bmod b,b)\]</div>
<p>辗转相除法就是利用上面的两条性质，不断地用大数去除小数，把大数变成除得的余数，直到其中有一个数变为0，此时另一个数就是要求的最大公因数。举例说明如下。</p>
<div class="admonition- admonition">
<p class="admonition-title">示例</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\gcd(16, 12) = \gcd(4, 12) = \gcd(4, 0) = 4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\gcd(14, 3) = \gcd(2, 3) = \gcd(2, 1) = \gcd(0, 1) = 1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\gcd(48, 36) = \gcd(12, 36) = \gcd(12, 0) = 12\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\gcd(105, 21) = \gcd(0, 21) = 21\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\gcd(7, 7) = \gcd(0, 7) = 7\)</span></p></li>
</ol>
</div>
<p><strong>算法实现</strong></p>
<p>用一个循环条件是两数均不为0的循环即可实现辗转相除法。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
                        <span class="n">a</span> <span class="o">%=</span> <span class="n">b</span><span class="p">;</span>
                <span class="k">else</span>
                        <span class="n">b</span> <span class="o">%=</span> <span class="n">a</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<ol class="arabic simple">
<li><p>循环条件 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b)</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">!=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span> <span class="pre">!=</span> <span class="pre">0)</span></code>，也就是当 <code class="docutils literal notranslate"><span class="pre">a</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">b</span></code> 中的任何一个是0的时候，循环就结束了。</p></li>
<li><p>循环结束之后，<code class="docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b</span></code> 中肯定至少有一个等于0，最大公因数就是另一个数。为了简化程序，我们利用任何数加上零等于它自己的性质，直接把结果赋值为 <code class="docutils literal notranslate"><span class="pre">a+b</span></code> 即可，无需再去判断其中哪一个是0了。</p></li>
</ol>
</div>
<p>利用c++ 的三元运算，可以把上面这个函数的代码进一步简化。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">%=</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">b</span> <span class="o">%=</span> <span class="n">a</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>利用多个整数最大公因数的数学性质 <span class="math notranslate nohighlight">\(\gcd(a, b, c)=\gcd(\gcd(a,b),c)\)</span> 可以方便地循环调用上面的 <code class="docutils literal notranslate"><span class="pre">gcd()</span></code> 函数求出任意个正整数的最大公因数。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>以上算法仅对0和正整数有效，尽管对于绝大部分算法程序已经足够，但也可能出现需要处理负数的情况，请自行设法修改以适应负数。</p>
</div>
</div>
<div class="section" id="id3">
<h2><span class="section-number">3.1.1.2. </span>最小公倍数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>有了求最大公因数的方法之后，求最小公倍数 <span class="math notranslate nohighlight">\(\text{lcm}(a,b)\)</span> 的方法便呼之欲出了。根据整数论的知识，我们知道两个整数的最大公因数和最小公倍数之积等于两个整数之积。</p>
<div class="math notranslate nohighlight">
\[\text{lcm}(a,b)\cdot\gcd(a,b)=a\cdot b\]</div>
<p>写成C++程序，唯一要注意的是两个整数相乘的积可能会整数超限，所以用先除后乘的方法处理即可，代码如下。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">lcm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>和最大公因数的情况一样，多个数的最小公倍数也可以拆分成两两链式求解：<span class="math notranslate nohighlight">\(\text{lcm}(a,b,c)=\text{lcm}(\text{lcm}(a,b),c)\)</span>。也可以先求出所有数的最大公因数，然后利用数学规律“<span class="math notranslate nohighlight">\(n\)</span> 个数的最小公倍数等于它们的乘积除以它们的最大公因数的 <span class="math notranslate nohighlight">\(n-1\)</span> 次方”来求解。</p>
<div class="math notranslate nohighlight">
\[\text{lcm}(a_1,a_2,\dots,a_n)=\frac{a_1\cdot a_2\cdot\cdots\cdot a_n}{[\gcd(a_1,a_2,\dots,a_n)]^{n-1}}\]</div>
<p>第二种方法的编程实现技巧性比较强，并不是简单的相乘相除就可以的。</p>
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<p>编写一个程序，输入 <span class="math notranslate nohighlight">\(n\)</span> 正整数并求出它们的最大公因数和最小公倍数，其中 <span class="math notranslate nohighlight">\(2\le m\lt 10\)</span>。</p>
<p>输入共两行，第一行一个整数 <span class="math notranslate nohighlight">\(n\)</span>，第二行 <span class="math notranslate nohighlight">\(n\)</span> 个正整数 <span class="math notranslate nohighlight">\(a_1,\dots,a_n\)</span>，均小于100，相互之间用一个空格隔开。</p>
<p>输出一行，为两个正整数，先后为 <span class="math notranslate nohighlight">\(\gcd(a_1,\dots,a_n)\)</span> 和 <span class="math notranslate nohighlight">\(\text{lcm}(a_1,\dots,a_n)\)</span>，中间用一个空格隔开。</p>
</div>
</div>
<div class="section" id="id4">
<h2><span class="section-number">3.1.1.3. </span>互质判断<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>有了快速的最大公因数算法之后，判断两个整数是否互质成为一个极其简单的问题，只需判断它们的最大公因数是否为1即可。在通常情况下，这样的算法都是很简单很快速的，也可以用来在一系列整数中搜索互质数对。</p>
<p>然而如果是要在一个很大的范围内搜索互质数对或者计算互质数对的数量，例如将一百万个正整数两两配对一共有5×10<sup>11</sup>（五千亿）个数对，要在这中间统计所有互质数对，用循环穷举并计算最大公因数的方法是行不通的。遇到这类问题就要用到更加复杂和精心设计的算法了，这个问题留到后面的章节再讨论。</p>
<p>最后要说一下两个以上整数<strong>相互互质</strong>的概念，这是指所有数相互之间<strong>两两互质</strong>。检查多个整数是否相互互质需要对它们进行两两配对逐对检查，一旦发现一对不互质的数检查就可以结束了。许多人想当然地以为所有数的最大公因数为1就代表它们是相互互质的，其实这是错误的。例如 <span class="math notranslate nohighlight">\(\gcd(4,5,6)=1\)</span>，但是它们并不是。</p>
<p>下面是用来判断一个整数数组中的数是否互质的一个简单的函数。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">is_coprime</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="212_primes.html" title="3.1.2. 和质数相关的基础算法"
             >下一页</a> |</li>
        <li class="right" >
          <a href="../210_basic_number_algos.html" title="3.1. 简单数值算法"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../210_basic_number_algos.html" ><span class="section-number">3.1. </span>简单数值算法</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>