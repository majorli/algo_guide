
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.1.2. 和质数相关的基础算法 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.1.3. 回文数专题" href="213_palindrome_numbers.html" />
    <link rel="prev" title="3.1.1. 最大公因数与最小公倍数" href="211_gcd_lcm.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="213_palindrome_numbers.html" title="3.1.3. 回文数专题"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="211_gcd_lcm.html" title="3.1.1. 最大公因数与最小公倍数"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../210_basic_number_algos.html" accesskey="U"><span class="section-number">3.1. </span>简单数值算法</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.1.2. 和质数相关的基础算法</a><ul>
<li><a class="reference internal" href="#id2">3.1.2.1. 质数判断</a></li>
<li><a class="reference internal" href="#index-0">3.1.2.2. 埃氏筛法</a></li>
<li><a class="reference internal" href="#id4">3.1.2.3. 中国余数定理</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="211_gcd_lcm.html"
                        title="上一章"><span class="section-number">3.1.1. </span>最大公因数与最小公倍数</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="213_palindrome_numbers.html"
                        title="下一章"><span class="section-number">3.1.3. </span>回文数专题</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec01/212_primes.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">3.1.2. </span>和质数相关的基础算法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>本节所说的质数不考虑负数的情况，我们考虑的范围是所有大于等于2的正整数。</p>
<div class="section" id="id2">
<h2><span class="section-number">3.1.2.1. </span>质数判断<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>如何判断一个整数是不是质数？对于单个整数n，我们就用最简单的小学数学教的方法，从2开始到n-1为止逐个寻找它的因数，如果这中间找到了至少一个因数，那么n就是一个合数，否则它就是质数。当然了，数学老师教过我们，其实不需要一直找到n-1，只要找到那个其平方值大于等于n的数为止就可以了。</p>
<p>所以判断一个整数是不是质数的程序，核心就是一个从2开始的循环。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">is_prime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个方法运行起来速度其实还是很快的，如果程序中只是需要对某些整数进行判断，这个小函数就完全够用了。但是如果程序要求在一个很大范围内找出其中的所有质数，比如1,000,000,000以内的所有质数，那么逐个用这个函数来判断就不那么高效了。这种情况下我们常用一种叫做<strong>埃拉托斯特尼筛法（简称埃氏筛法、埃筛、素数筛）</strong>的算法来快速打出一张质数表。</p>
</div>
<div class="section" id="index-0">
<span id="id3"></span><h2><span class="section-number">3.1.2.2. </span>埃氏筛法<a class="headerlink" href="#index-0" title="永久链接至标题">¶</a></h2>
<p>埃氏筛法是由古希腊数学家埃拉托斯特尼（Eratosthenes）所提出的一种简单检定质数的算法。要得到大于2的自然数n以内的全部质数，只要把不大于 <span class="math notranslate nohighlight">\(\sqrt{n}\)</span> 的所有质数的倍数剔除，剩下的就是质数。</p>
<p>下面我们看看筛选100以内质数的过程，要筛出100以内的所有质数，需要从2的倍数开始筛，直到10的倍数就可以了。</p>
<p>首先筛除所有2的倍数（不包括2自己哦）：</p>
<img alt="../../_images/212_erato_2.jpg" src="../../_images/212_erato_2.jpg" />
<p>然后是所有3的倍数（当然也不包括3自己，以后都是这样，不再重复说明）：</p>
<img alt="../../_images/212_erato_3.jpg" src="../../_images/212_erato_3.jpg" />
<p>接下来4已经被筛掉了，所以跳过4，筛除所有5的倍数：</p>
<img alt="../../_images/212_erato_5.jpg" src="../../_images/212_erato_5.jpg" />
<p>6也已经被筛掉了，跳过，筛除7的倍数：</p>
<img alt="../../_images/212_erato_7.jpg" src="../../_images/212_erato_7.jpg" />
<p>8，9，10，都已经被筛掉了，要不要筛11的倍数呢？按照埃老先生的方法，11的平方已经超过100，所以算法已经可以结束了，不需要筛11的倍数。那么我们用图来看看实际的情况如何：</p>
<img alt="../../_images/212_erato_11.jpg" src="../../_images/212_erato_11.jpg" />
<p>果然，所有11的倍数都已经被筛掉了。算法到此结束，看看剩下还留着的数有哪些？</p>
<img alt="../../_images/212_erato.jpg" src="../../_images/212_erato.jpg" />
<p>剩下的确实就是100以内所有的质数了！</p>
<p>这个算法实现起来也很简单，需要提供一个足够大的 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 型数组作为质数表。先把0号和1号元素初始化为 <code class="docutils literal notranslate"><span class="pre">false</span></code>，2号到n号的所有元素初始化为 <code class="docutils literal notranslate"><span class="pre">true</span></code>。然后从2开始进行筛选，将表中所有的2的倍数号的元素赋值为 <code class="docutils literal notranslate"><span class="pre">false</span></code>，表中剩下的最小的数字就是3，它不能被更小的数整除，所以3是质数。再将表中所有的3的倍数号元素赋值为 <code class="docutils literal notranslate"><span class="pre">false</span></code>……依此类推，如果表中剩余的最小的数是m，那么m就是质数，接下来就将表中所有m的倍数号元素赋值为 <code class="docutils literal notranslate"><span class="pre">false</span></code>。像这样反复操作，直到那个其平方值大于n的数为止，因为从它开始，所有的合数肯定已经都被筛选掉了。（希望大家能去想一想为什么？）</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>一般来说一个程序里只要打一张质数表就够了，我们可以把这张表定义为一个全局的数组。但是相对于通常的做法，我更喜欢在这张表里用 <code class="docutils literal notranslate"><span class="pre">true</span></code> 表示合数，用 <code class="docutils literal notranslate"><span class="pre">false</span></code> 表示质数，因为全局变量会自动初始化为全0，也就是全 <code class="docutils literal notranslate"><span class="pre">false</span></code>，这样的话，我们的埃筛打表函数里就不需要手动把数组所有元素初始化为 <code class="docutils literal notranslate"><span class="pre">true</span></code> 了，要知道这个步骤需要一个大循环来完成，如果表很大还是挺费时间的。</p>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>另一个可以提高效率的小窍门：每次用质数 <span class="math notranslate nohighlight">\(p\)</span> 来进行筛选时，不需要从 <span class="math notranslate nohighlight">\(2p\)</span> 开始，直接从 <span class="math notranslate nohighlight">\(p^2\)</span> 开始筛就可以了，因为从 <span class="math notranslate nohighlight">\(2p\)</span> 到 <span class="math notranslate nohighlight">\((p-1)p\)</span> 这些个倍数其实都已经被前面的质数筛过了。</p>
</div>
<p>下面是一个用了我的小窍门的“反”埃筛打表程序。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">seive</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">erato</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seive</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">seive</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span>
			<span class="n">seive</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">seive</span><span class="p">[</span><span class="o">++</span><span class="n">p</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="hll">	<span class="n">erato</span><span class="p">(</span><span class="mi">120</span><span class="p">);</span>
</span>	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">120</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="hll">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seive</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span>			<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d%c&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">cnt</span> <span class="o">%</span> <span class="mi">20</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">There&#39;re %d primes from 2 to 120.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">思考</p>
<p>如果要打一个从某个整数 <span class="math notranslate nohighlight">\(m\gt2\)</span>，而不是从2开始的质数表，当然你可以坚持从2开始，但是为了节省一点空间和时间，你可以怎样改进这个算法？</p>
</div>
<p>埃氏筛子的时间复杂度是 <span class="math notranslate nohighlight">\(O(n\log\log n)\)</span>，这已经非常非常接近 <span class="math notranslate nohighlight">\(O(n)\)</span> 了，绝大多数情况下都不会出现问题。但是对于那些极大的数据规模，例如 <span class="math notranslate nohighlight">\(n\ge10^9\)</span>，再加上如果程序的其他部分也是相当耗时的复杂算法，那么普通的埃筛还是有可能TLE的。这时候一种叫做欧拉线性筛的 <span class="math notranslate nohighlight">\(O(n)\)</span> 筛法就闪亮登场了。</p>
<p>欧拉线性筛是一种 <span class="math notranslate nohighlight">\(O(n)\)</span> 的质数筛选算法，是最为高效率的质数筛。它虽是对埃氏筛法的一种优化改进，但这个算法本身的目的并非是单纯地为了筛选质数，它主要用于高效计算所谓的<strong>积性函数</strong>，即满足性质 <span class="math notranslate nohighlight">\(f(a\cdot b)=f(a)\cdot f(b)\)</span> 的函数，例如同样以欧拉命名的欧拉函数 <span class="math notranslate nohighlight">\(\varphi(n)\)</span> 就是一个积性函数，它用于求解与正整数n互质的正整数（包括1）的个数。但它是一个不完全的积性函数，只有当两个正整数m和n互质时，它才满足 <span class="math notranslate nohighlight">\(\varphi(n\cdot m)=\varphi(m)\cdot\varphi(n)\)</span>。</p>
<p>对于线性筛，目前我们不要求掌握，以后在高级数论算法的时候再讨论。目前我们要知道的是：</p>
<ol class="arabic simple">
<li><p>欧拉线性筛是一种最高效的质数筛法，它的平均速度比埃氏筛子快3到4倍，但是它要比埃氏筛法多用至少一倍的内存。</p></li>
<li><p>欧拉线性筛在数据量较小的时候，由于大量使用取模运算，速度甚至会比埃氏筛子慢。</p></li>
<li><p>因此欧拉线性筛一般不用于打质数表，通常情况下需要打质数表的算法就不多，绝大多数时候用埃氏筛子已经足够了。</p></li>
<li><p>欧拉线性筛的主要用途是快速计算积性函数。</p></li>
</ol>
<p>如果有兴趣，可以跳转到线性筛和欧拉函数的相关章节：<a class="reference internal" href="../../ch05/sec01/511_euler_seive.html#ref-511"><span class="std std-ref">欧拉线性筛和欧拉函数</span></a>。</p>
</div>
<div class="section" id="id4">
<h2><span class="section-number">3.1.2.3. </span>中国余数定理<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>中国余数定理，又叫孙子定理，是用于求解一元线性同余方程组的一种算法。用数学语言来讲，中国余数定理给出了一元线性同余方程组有解的判定方法，并且在有解的情况下获得解的一种构造法。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>在数学语言里，整数 <span class="math notranslate nohighlight">\(a\)</span> 除以整数 <span class="math notranslate nohighlight">\(m\)</span> 的余数等于 <span class="math notranslate nohighlight">\(r\)</span> 记作 <span class="math notranslate nohighlight">\(a\equiv r\pmod m\)</span>。把整数运算的数值范围限制在 <span class="math notranslate nohighlight">\([0,m)\)</span> 范围之内，一旦某数超过这个范围就将其除以 <span class="math notranslate nohighlight">\(m\)</span> 并用得到的余数来代替它，这样的运算称为<strong>模m的运算</strong>。</p>
</div>
<p>所谓一元线性同余方程组是指整数域内的这样一个方程组：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
x\equiv a_1\pmod {m_1}\\
x\equiv a_2\pmod {m_2}\\
\vdots\\
x\equiv a_n\pmod {m_n}
\end{cases}\end{split}\]</div>
<p>中国余数定理说，如果方程组中的模 <span class="math notranslate nohighlight">\(m_1,m_2,\dots,m_n\in\Bbb{Z}\)</span> 两两互质，那么对于任意的 <span class="math notranslate nohighlight">\(a_1,a_2,\dots,a_n\in\Bbb{Z}\)</span>，上面这个方程组有解。而且可以用下面的方法来构造出解。</p>
<p>设 <span class="math notranslate nohighlight">\(M=\prod_{i=1}^n{m_i}=m_1\cdot m_2\cdot\cdots\cdot m_n\)</span>，并设 <span class="math notranslate nohighlight">\(M_i=M/m_i,(i=1,2,\dots,n)\)</span>，即 <span class="math notranslate nohighlight">\(M_i\)</span> 是除了 <span class="math notranslate nohighlight">\(m_i\)</span> 以外其他所有n-1个模的乘积。再设 <span class="math notranslate nohighlight">\(t_i\)</span> 是 <span class="math notranslate nohighlight">\(M_i\)</span> 的模 <span class="math notranslate nohighlight">\(m_i\)</span> 运算下的倒数，即 <span class="math notranslate nohighlight">\(t_i\cdot M_i\equiv 1\pmod {m_i}\)</span>。那么上面这个方程组的通解就是：</p>
<div class="math notranslate nohighlight">
\[x=kM+\sum_{i=1}^n{a_it_iM_i}=kM+a_1t_1M_1+a_2t_2M_2+\cdots+a_nt_nM_n,(k\in\Bbb{Z})\]</div>
<p>如果把解限制在模 <span class="math notranslate nohighlight">\(M\)</span> 运算的意义下，那么就只有一个确定的解，<span class="math notranslate nohighlight">\(x=\sum_{i=1}^n{a_it_iM_i} \pmod M\)</span>。</p>
<p>这么说肯定太抽象了，下面来看一个简单的具体例子大家就明白这一大堆数学符号是在做什么了。这是最经典的一类题，最常见的一组数据，小学奥数的时候就做过这组数据的题。</p>
<div class="admonition- admonition">
<p class="admonition-title">例题</p>
<p>某学校每个班的学生人数为40到60人不等，有一个班的学生分组做实验，如果每组三人就多两人，每组五人就多三人，每组七人就多四人，问这个班有多少学生?</p>
</div>
<p>此题用的是最经典的三模组 <span class="math notranslate nohighlight">\(m_1=3,m_2=5,m_3=7\)</span>，显然它们两两互质，对应的余数分别是 <span class="math notranslate nohighlight">\(a_1=2,a_2=3,a_3=4\)</span>。按照中国余数定理，通解一定存在，但在题目规定的40到60之间这个范围内有没有解可不一定，这一点一定要清楚！</p>
<p>先计算出构造通解所需的常数：<span class="math notranslate nohighlight">\(M=3\times 5\times 7=105,M_1=5\times 7=35,M_2=3\times 7=21,M_3=3\times 5=15\)</span>。</p>
<p>然后我们要找出 <span class="math notranslate nohighlight">\(M_1,M_2,M_3\)</span> 的这样一些倍数，使得它们各自除以 <span class="math notranslate nohighlight">\(m_1=3,m_2=5,m_3=7\)</span> 之后的余数都等于1。经过简单的计算可以找到，<span class="math notranslate nohighlight">\(2M_1=70,M_2=21,M_3=15\)</span> 就满足这一要求，它们分别除以3、5、7后得到的余数都是1。</p>
<p>接下来我们就可以按照公式来得到通解了：<span class="math notranslate nohighlight">\(x=105k+2\times70+3\times21+4\times15=263+105k,(k\in\Bbb{Z})\)</span>。</p>
<p>最后，根据题意找出在40和60之间的那个特殊解，容易看出来，当 <span class="math notranslate nohighlight">\(k=-2\)</span> 的时候，<span class="math notranslate nohighlight">\(x=263-2\times105=53\)</span> 满足题目要求，再增加一个105或减少一个105都会超出题目要求的人数范围。所以本题的答案是53人。</p>
<p>可见中国余数定理构造同余方程组的解的方法本身就是一个典型的算法。虽然对于三五七这样一组简单的模来说，似乎解题过程反而复杂了，但是它定义了一套完好的计算过程，每一步都可以用固定的方法进行计算，最后在有限步之内得出正确答案，所以这个定理特别适合用计算机程序来实现。具体怎么实现视具体题目而定，应该不难，重点是理解定理的使用方法。但是有下面几点需要特别关注。</p>
<ul class="simple">
<li><p>有时候题目会给出不满足两两互质的模组，因此有必要在程序开始时进行互质判断。如果模组不满足两两互质那么可能要用到更加复杂的同余方程组求解方法，有兴趣的可以自行寻找“同余方程组”相关的资料进行学习。但是这样的题目不多，而且大多数情况下遇到这样的模组，完全可以用循环测试公倍数的方法来解决。</p></li>
<li><p>如果模的数量非常多，或者模本身数值很大，那么参数 <span class="math notranslate nohighlight">\(M\)</span> 和 <span class="math notranslate nohighlight">\(M_i\)</span> 可能会很大，注意数据超限问题。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(M_i\)</span> 很大，那么在从1倍开始逐个寻找满足条件的倍数时可以利用余数运算的规则，先计算出 <span class="math notranslate nohighlight">\(M_i\)</span> 除以 <span class="math notranslate nohighlight">\(m_i\)</span> 的余数 <span class="math notranslate nohighlight">\(r_i\)</span>，然后去寻找满足 <span class="math notranslate nohighlight">\(t_ir_i\equiv1\pmod{m_i}\)</span> 的倍数 <span class="math notranslate nohighlight">\(t_i\)</span>，想一想这是为什么？</p></li>
<li><p>最后最重要的一点，在题目给出的解的取值范围内，可能有1个解，也可能无解，也可能有多个解！千万注意！！此类题目最容易WA的点就在这里。</p></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="213_palindrome_numbers.html" title="3.1.3. 回文数专题"
             >下一页</a> |</li>
        <li class="right" >
          <a href="211_gcd_lcm.html" title="3.1.1. 最大公因数与最小公倍数"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../210_basic_number_algos.html" ><span class="section-number">3.1. </span>简单数值算法</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>