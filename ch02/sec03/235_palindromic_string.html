
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.3.5. 回文字符串 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.3.6. C++ string简介" href="236_cpp_string_intro.html" />
    <link rel="prev" title="3.3.4. 子串搜索及KMP算法" href="234_substr_kmp.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="236_cpp_string_intro.html" title="3.3.6. C++ string简介"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="234_substr_kmp.html" title="3.3.4. 子串搜索及KMP算法"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../230_basic_string_algos.html" accesskey="U"><span class="section-number">3.3. </span>简单字符串处理</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.3.5. 回文字符串</a><ul>
<li><a class="reference internal" href="#id2">3.3.5.1. 回文串的判断</a></li>
<li><a class="reference internal" href="#id3">3.3.5.2. 最长回文子串（蛮力、动态规划和中心扩展）</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="234_substr_kmp.html"
                        title="上一章"><span class="section-number">3.3.4. </span>子串搜索及KMP算法</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="236_cpp_string_intro.html"
                        title="下一章"><span class="section-number">3.3.6. </span>C++ string简介</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec03/235_palindromic_string.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><span class="section-number">3.3.5. </span>回文字符串<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>我们在前面简单数值算法时曾经讲过回文的概念，当时我们主要着眼于回文整数的相关问题，现在我们要重点讲一讲回文字符串的问题。</p>
<p>我们已经知道了回文的概念，所以回文字符串当然就是从左到右念和从右到左念完全一样的字符串，比如 <code class="docutils literal notranslate"><span class="pre">&quot;level&quot;</span></code>。在这一节，我们先解决最基本的问题，怎样判断一个字符串是否为回文串。然后我们要解决一个经典的回文串问题：最大回文子串。</p>
<p>解决最大回文子串问题的方法有很多，我们先通过蛮力法来了解一些基本知识，然后学习一种比较容易理解和编程的方法：中心扩展法，它的时间复杂度是 <span class="math notranslate nohighlight">\(O(n^2)\)</span>。由于中心扩展法编程比较简单，不使用什么复杂的数据结构，消耗空间仅为常数级的 <span class="math notranslate nohighlight">\(O(1)\)</span>，时间上也能满足绝大多数题目的要求，所以是非常好用的一种算法，需要认真学习掌握。</p>
<p>最大回文子串问题的另一个 <span class="math notranslate nohighlight">\(O(n^2)\)</span> 时间算法是一种动态规划法，但根据在LeetCode网站实测的结果，它的实际运行时间是中心扩展法的20多倍，而且空间复杂度同样高达 <span class="math notranslate nohighlight">\(O(n^2)\)</span>，因此我们只打算对它进行一个简单的原理介绍。希望能够让大家对五大算法设计方法中最灵活最难掌握的动态规划法有一个初步的认识，当然有兴趣的话也可以自己动手试一试。</p>
<p>而最经典的最大回文子串问题解法是一个叫做Manacher算法的方法，通常习惯用谐音称呼它为<strong>马拉车算法</strong>。这个算法非常高明，非常精妙，时间复杂度低至 <span class="math notranslate nohighlight">\(O(n)\)</span>，但是这个算法非常复杂，非常难掌握。不太指望能在考场上又快又正确地写出马拉车算法程序来，所以我们将在后面的章节再详细介绍马拉车算法，现阶段能熟练掌握中心扩展算法即可。</p>
<div class="section" id="id2">
<h2><span class="section-number">3.3.5.1. </span>回文串的判断<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>我们在前面3.1.3节回文数专题中曾经学过判断回文整数的方法，通过把整数前后反转然后判断是否和原数相等即可判断原数是否为回文数。现在我们要判断一个字符串是不是回文串，当然我们可以延续这一思路，先将原字符串所有字符前后反转生成一个新字符串，然后比较新字符串和原字符串是否相等即可。但是这种方法不够好，既浪费时间又浪费空间。</p>
<p>要知道字符串这种东西和整数有一个很大的区别，字符串可以用位置索引来直接获取其中每一个位置上的字符，而整数每一位上的数码却没有那么容易地想取就能取到。我们可以利用字符串这一特性，用两个不同的位置指针分别指向首字符和尾字符。这样就可以直接比较首字符和尾字符是否相同，如果相同那么让首位置后移一个字符，尾位置前移一个字符继续比较，直到两个位置交错而过（此时字符串为回文串）或者在二者交错之前就发现有字符不同（这就说明不是回文串）。这个简单的过程应该很好理解吧，下面直接出代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="kt">bool</span> <span class="nf">is_palin</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">is_palin_p</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">81</span><span class="p">];</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%80s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s is%sa palindromic string.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">is_palin_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot; not &quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">is_palin</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">--</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">is_palin_p</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">left</span><span class="o">++</span><span class="p">)</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">right</span><span class="o">--</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个简单的程序里面提供了两个版本的判断函数，<code class="docutils literal notranslate"><span class="pre">is_palin()</span></code> 函数使用了数组加下标的形式来访问C-string中指定位置的字符，而指针版的 <code class="docutils literal notranslate"><span class="pre">is_palin_p()</span></code> 函数则采用两个字符型指针来一前一后地迭代访问字符。</p>
<div class="admonition- admonition">
<p class="admonition-title">补充</p>
<p>数组版和指针版，二者的运行效果是完全一样的，但是有些人会说，指针迭代版本的速度更快一些。这是有道理的。如果用数组加下标的方式来访问某个字符，例如 <code class="docutils literal notranslate"><span class="pre">s[i]</span></code>，那么程序要计算指针加法 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">i</span></code>，然后能找到这个字符所在的内存地址从而取得这个字符；如果使用指针，那么指针本身就是地址，直接就可以访问这个字符。所以数组版在取字符的时候会比指针版多计算一次指针加法，这就是指针迭代版本速度更快一些的原因。</p>
<p>不过在实际应用中，大家完全不用担心这一点点的速度差距。在现代计算机芯片的强大运算能力和现代C++编译器的强大优化能力下，这点速度差异微不足道，尤其是在使用C-string这种本身就以速度见长的表示方式时，二者几乎没有任何差别。除非字符串的长度非常巨大，数十甚至数百万位。</p>
<p>对于速度相对较慢的C++ string，差异就会略大一些。为此C++提供了一种叫做string迭代器 <code class="docutils literal notranslate"><span class="pre">string::iterator</span></code> 的东西来代替原先的指针用以快速访问字符串中的字符，这东西其实就是包装过的指针，我们在下一节会进行介绍。即使这家伙光类型名就这么长，用起来也挺麻烦，但在对运行速度要求极严格的场合还是很有必要的。不过我们要知道，即使是C++ string，也要在字符串长度达到万这个级别的时候二者之间才会有可感知的速度差异。</p>
</div>
</div>
<div class="section" id="id3">
<h2><span class="section-number">3.3.5.2. </span>最长回文子串（蛮力、动态规划和中心扩展）<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>接下来我们要尝试解决“最长回文子串”这个经典的回文串问题：找出非空字符串S中最长的回文子串。如果答案有多个，那么要的是从左往右第一个。</p>
<p>注意：这个问题必然有解，因为单字符的字符串都是回文串，所以对于任何非空字符串，至少有长度为1的回文子串。</p>
<p>一、蛮力法</p>
<p>蛮力法，就是暴力枚举S的每一个子串，判断其是否为回文串。枚举时按照子串长度从大到小的顺序，这样第一个找到的回文子串就是长度最大的了。</p>
<p>暴力枚举需要用到两层嵌套循环。设S的长度为n，外层循环是子串长度L，从n到1的逆向循环。内层循环是从左到右所有具有长度L的子串，即从 <code class="docutils literal notranslate"><span class="pre">S[0:L]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">S[n-L:n]</span></code>。在内层循环里逐个对这些子串进行回文串判断，只要找到一个就是答案，就直接退出所有循环。显然这是一个 <span class="math notranslate nohighlight">\(O(n^3)\)</span> 的算法。</p>
<p>在实际编程时，我们当然不会傻到真的每次复制出子串来进行回文串判断。为了尽量提高运行效率，我们一般都会修改一下上面讲过的那种回文串判断函数，让函数接受一左一右两个指针，然后对这两个指针所指定的范围进行判断。这样在程序里我们就不需要来来回回地进行子串复制，只要操作一对位于原字符串S上的指针就可以实现判断了。下面是这个蛮力法的程序：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>

<span class="kt">bool</span> <span class="nf">is_palin</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">right</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">100010</span><span class="p">];</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%100009s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="kt">clock_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>	<span class="c1">// 用来指示待判断子串的头尾字符的一对指针</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// 外层循环，子串长度len，从sz到1</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>			<span class="c1">// 左指针从s的头部开始</span>
		<span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">// 根据len计算出右指针</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">right</span><span class="p">)</span>	<span class="c1">// 循环条件为右指针处的字符不为&#39;\0&#39;，右端抵达&#39;\0&#39;表示没有长len的子串了</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_palin</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>		<span class="c1">// 找到一个回文子串，马上退出循环</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="o">++</span><span class="n">left</span><span class="p">;</span>		<span class="c1">// 否则左右指针分别后移一个字符继续判断</span>
				<span class="o">++</span><span class="n">right</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="c1">// while循环结束后若右指针处不是&#39;\0&#39;说明找到回文子串了，那就退出外层循环，搜索结束</span>
		<span class="c1">// 否则说明本轮没有找到回文子串，那就继续外循环，len减1继续暴搜</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">right</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="n">putchar</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">left</span><span class="o">++</span><span class="p">));</span>	<span class="c1">// 一定会有解，所以放心地输出即可</span>
	<span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;time elapsed = %ld ms.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">CLOCKS_PER_SEC</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">is_palin</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">left</span><span class="o">++</span><span class="p">)</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">right</span><span class="o">--</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为了观察算法的运行速度，我在程序里加入了测运行时长的功能，并随机生成了五个测试点数据，分别是长度为10、100、1000、10000、100000的五个字符串。运行结果如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./mps_bf &lt; mps_1.in
A
time elapsed = 0 ms.

$ ./mps_bf &lt; mps_2.in
LJL
time elapsed = 0 ms.

$ ./mps_bf &lt; mps_3.in
MOM
time elapsed = 2 ms.

$ ./mps_bf &lt; mps_4.in
MLVLM
time elapsed = 228 ms.

$ ./mps_bf &lt; mps_5.in
LMLXLML
time elapsed = 22888 ms.
</pre></div>
</div>
<p>可以看到，当字符串长度为10000个字符时，速度已经相当慢了。最后一个测试点字符串长达10万个字符时，运行时间超过了22秒。这样的算法如果用于实际解题肯定是要吃到TLE的。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>蛮力的算法本身虽然不值一提，但是在程序代码里却是用了许多C-string处理的常用技巧。比如指针代替位置、双指针指定子串、循环时用字符是否为 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> 作为循环条件等，都是早期纯C语言阶段就积累起来的C-string处理最为常用也是最为重要的技巧。</p>
<p>在算法竞赛中，由于C++ string的速度确实比较慢，所以现在还是有许多人宁愿使用功能较弱、风险和难度都较大的传统C-string来进行字符串处理。如果你也希望能熟练掌控C-string，那么get这些技能是必不可少的。</p>
<p>务必请认真地读懂这个程序，遇到不太懂的，可以自己尝试着改一改没有看懂的地方，运行一下看看会发生什么变化。这是一种读懂别人程序的重要方法。</p>
</div>
<p>二、动态规划法</p>
<p>下面简单介绍一下动态规划的解法，这个解法的时间复杂度和空间复杂度都是 <span class="math notranslate nohighlight">\(O(n^2)\)</span>，而且是比较慢的二阶算法，如果用来解实际的算法题，很可能还是会超时。所以我们对这个算法不做编程的要求，只需理解它的思路。</p>
<p>所谓动态规划，简单的来说就是通过列表格的方法，从简单的立即可知的情况开始，由简到难地逐步递推出所有情况下的解。这么说可能还比较模糊，不容易懂，没关系，我们现在先看最长回文子串问题怎么用动态规划的方法来求解，以后我们还会有专门的章节来详细介绍动态规划法。</p>
<p>对于任意一个长度为n的非空字符串S，首先我们定义一个 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 型函数 <span class="math notranslate nohighlight">\(P(i,j)\)</span>：</p>
<div class="math notranslate nohighlight">
\[\begin{split}P(i,j)=\begin{cases}\text{true}&amp;\text{如果 }S[i] ~ S[j]\text{ 是回文子串}\\ \text{false}&amp;\text{如果 }S[i] ~ [j]\text{ 不是回文子串}\end{cases},(0 \le i \le j \le n-1)\end{split}\]</div>
<p>如果我们能够对所有的 <span class="math notranslate nohighlight">\(0 \le i \le j \le n-1\)</span> 计算出 <span class="math notranslate nohighlight">\(P(i,j)\)</span> 的值，那么当然就能求出最长回文子串了。但是使用暴力枚举的方法来计算所有 <span class="math notranslate nohighlight">\(P(i,j)\)</span> 的值是不行的，因为这正是蛮力法所做的事情。</p>
<p>我们现在要用列表和递推的方法来求解这个函数。我们这样考虑，假如已经知道了从 <code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">S[j]</span></code> 这一段是不是回文串，那么对于“包围”它的那一段，即从 <code class="docutils literal notranslate"><span class="pre">S[i-1]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">S[j+1]</span></code> 是不是也很容易判断了呢？当然很容易！如果 <code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">S[j]</span></code> 不是回文子串，那么包围它的那一段肯定也不会是回文子串；如果 <code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">S[j]</span></code> 是回文子串，那么包围它的那一段是不是回文子串取决于两头的字符 <code class="docutils literal notranslate"><span class="pre">S[i-1]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">S[j+1]</span></code> 是不是相同。也就是说我们可以根据 <span class="math notranslate nohighlight">\(P(i,j)\)</span> 的值轻松地推出 <span class="math notranslate nohighlight">\(P(i-1,j+1)\)</span> 的值：</p>
<div class="math notranslate nohighlight">
\[P(i-1, j+1) = (P(i, j) = \text{true}) \land (S[i-1] = S[j+1])\]</div>
<p>换个方向说，如果我们想计算某一个函数值 <span class="math notranslate nohighlight">\(P(i,j)\)</span>，我们可以通过 <span class="math notranslate nohighlight">\(P(i+1,j-1)\)</span> 的值来推导：</p>
<div class="math notranslate nohighlight">
\[P(i, j) = (P(i+1, j-1)=\text{true}) \land (S[i] = S[j])\]</div>
<p>注意这里要满足 <span class="math notranslate nohighlight">\(j-1\ge i+1\)</span>，即 <span class="math notranslate nohighlight">\(j-i\ge2\)</span>，子串长度需要大于2。也就是说，像 <span class="math notranslate nohighlight">\(P(i,i)\)</span> 和 <span class="math notranslate nohighlight">\(P(i,i+1)\)</span> 这样的函数值不能用这个递推公式计算，它们需要作为函数的初始值实现计算好。幸亏长度为1和2的子串是否回文串是很容易判断的。我们已经知道，所有长度为1的单字符子串都是回文的，而长度为2的子串可以通过一次循环很轻松的判断完成。</p>
<p>所以我们就可以用列表的方式来求解所有的函数值：</p>
<img alt="../../_images/235_mps.001.png" src="../../_images/235_mps.001.png" />
<p>表中对角线上的函数值都为true，对角线左下方的三角形区域是没有用的，那里 <span class="math notranslate nohighlight">\(i\gt j\)</span>，我们需要求的是对角线右上方的三角区域里所有的值。还可以发现，这个表里每一条斜线上的所有函数值对应的子串长度都是相等的，对角线上都是长度为1的单字符子串，而右上角的 <span class="math notranslate nohighlight">\(P(0,n-1)\)</span> 则代表原字符串S本身。</p>
<p>所以我们可以用一个二维数组 <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">p[n][n]</span></code> 来构成这张表。初始时把对角线上的所有元素设置为true，然后计算从 <code class="docutils literal notranslate"><span class="pre">p[0][1]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">p[n-2][n-1]</span></code> 这条对角线上的所有函数值，接下来就可以从下到上一条斜线一条斜线地计算出所有的函数值了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</pre></div>
</div>
<p>计算完成之后，再从右上角开始从上到下一条斜线一条斜线的检查有没有true，找到的第一个等于true的函数值，利用它对应的行号 <code class="docutils literal notranslate"><span class="pre">i</span></code> 和列号 <code class="docutils literal notranslate"><span class="pre">j</span></code> 就可以找到那个最长回文子串了。</p>
<p>建议大家用几个短一点的字符串（长度10个字符以内）手动计算这张表格来完成这个算法试试。当然了，有兴趣自己编一下程序也是极好的一种编程锻炼。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>在正规的动态规划法术语里，这种可以由问题的简单情况解来逐步推出更复杂情况下的解的函数叫做<strong>优化函数</strong>，最简单情况下的解叫做优化函数的<strong>初值</strong>，程序里一般都用数组来完成列表计算，这样的表叫做<strong>动态规划表</strong>或<strong>备忘录</strong>。</p>
<p>虽然动态规划法在解决最长回文子串问题时显得相当笨拙，但是在很多其他问题的求解上展现出强大的能力，比如著名的背包问题等，以后我们会详细讲解。</p>
</div>
<p id="index-0">三、中心扩展法</p>
<p><strong>中心扩展法</strong>是我们重点要介绍，需要重点掌握的一种最长回文子串查找算法。它的时间复杂度虽然也是 <span class="math notranslate nohighlight">\(O(n^2)\)</span>，但是它的运行效率非常之高，在实践中已经相当接近于 <span class="math notranslate nohighlight">\(O(n)\)</span> 时间了。而且它的原理和编程都很简单，是一种非常实用的算法。</p>
<p>所谓中心扩展法，就是指以某处为中心，向两边<strong>尽最大可能地</strong>等距离扩展来寻找回文子串。我们从回文串的特点可以看到，任何回文串都是有一个中心，两边呈中心对称的。对称中心有两种：</p>
<p>一种是以某个字符为中心，形成长度为奇数的回文串。例如 <code class="docutils literal notranslate"><span class="pre">&quot;aba&quot;</span></code> 就是这样一个回文串，它以字符 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 为中心，长度为3。这种回文子串的最小长度为1，也就是每一个单个字符本身，例如 <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code> 就是一个回文子串。</p>
<p>另一种是以两个相邻字符之间的空隙为中心，形成长度为偶数的回文串。例如 <code class="docutils literal notranslate"><span class="pre">&quot;abba&quot;</span></code> 以中间相邻的两个 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 之间的空隙为中心，长度为4。这一种回文子串的最小长度为0，也就是相邻两个字符就不相同的情况。</p>
<p>例如字符串 <code class="docutils literal notranslate"><span class="pre">&quot;abbacdc&quot;</span></code>，其中每一个字符本身就是一个长度为1的回文子串，另外在第2和第3个字符 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 中间的空隙处向两边扩展可以得到一个长度为4的回文子串 <code class="docutils literal notranslate"><span class="pre">&quot;abba&quot;</span></code>，以倒数第二个字符 <code class="docutils literal notranslate"><span class="pre">'d'</span></code> 为中心向两边扩展可以得到一个长度为3的回文子串 <code class="docutils literal notranslate"><span class="pre">&quot;cdc&quot;</span></code>。</p>
<p>对于一个任意给定的长度为n的非空字符串S，我们在所有可能的中心处进行上述扩展，就可以像在一个数列中寻找最大数一样简单地找到最长回文子串了。在这样一个字符串中，一共有2n-1个中心，分别是n个字符本身，以及它们之间的n-1个空隙。</p>
<p>以字符串 <code class="docutils literal notranslate"><span class="pre">&quot;abbacdc&quot;</span></code> 为例，它的长度为7，共有以下13个扩展中心：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 1 2 3 4 5 6
a b b a c d c
^ ^ ^ ^ ^ ^ ^   7个字符本身都是扩展中心，可以扩展长度为奇数的回文子串
 ^ ^ ^ ^ ^ ^    6个字符之间的空隙也是扩展中心，可以扩展长度为0或偶数的回文子串
</pre></div>
</div>
<p>整个算法可以分成两个部分，一个是算法的主流程本身，它需要调用一个中心扩展子算法。</p>
<p>先看中心扩展子算法。中心扩展子算法的功能是给定一个中心，然后尽最大可能地向左右两边等距离扩展，找到以此为中心的最长的回文子串。我们知道，中心有字符和字符间隙两种。对于每一个字符位置 <code class="docutils literal notranslate"><span class="pre">i</span></code>，<code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 指定了一个字符型中心，<code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">S[i+1]</span></code> 则指定了一个字符间隙型中心。所以我们可以用两个位置变量 <code class="docutils literal notranslate"><span class="pre">left</span></code> 和 <code class="docutils literal notranslate"><span class="pre">right</span></code> 来作为中心扩展子算法的参数，<code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">==</span> <span class="pre">right</span></code> 表示以字符 <code class="docutils literal notranslate"><span class="pre">S[left]</span></code> 为中心进行扩展，<code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">==</span> <span class="pre">left</span> <span class="pre">+</span> <span class="pre">1</span></code> 则表示以 <code class="docutils literal notranslate"><span class="pre">S[left]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">S[right]</span></code> 之间的间隙为中心进行扩展。</p>
<p>扩展的过程就比较简单了，从比较 <code class="docutils literal notranslate"><span class="pre">S[left]</span></code> 是否等于 <code class="docutils literal notranslate"><span class="pre">S[right]</span></code> 开始循环。每次比较二者如果相等，就把 <code class="docutils literal notranslate"><span class="pre">left</span></code> 减1（向左扩展1个字符）、<code class="docutils literal notranslate"><span class="pre">right</span></code> 加1（向右扩展一个字符），继续比较。直到出现二者不相等，或者某一端超出字符串的范围为止。</p>
<p>按照上面的循环规则，当循环结束的时候 <code class="docutils literal notranslate"><span class="pre">left</span></code> 和 <code class="docutils literal notranslate"><span class="pre">right</span></code> 所指向的位置以内（但不包含它们所指向的字符）就是能扩展到的最长回文子串，长度为 <code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">-</span> <span class="pre">left</span> <span class="pre">-</span> <span class="pre">1</span></code>。</p>
<p>以字符为中心进行扩展时，第一轮循环时由于 <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">==</span> <span class="pre">right</span></code> 一定成立，所以两端一定相等，扩展至少能尝试一步，得到的长度至少为1。</p>
<p>例如在 <code class="docutils literal notranslate"><span class="pre">abbacdc</span></code> 中，以两个 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 之间的间隙为中心扩展，循环结束后 <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">=</span> <span class="pre">-1,</span> <span class="pre">right</span> <span class="pre">=</span> <span class="pre">4</span></code>，得到回文子串 <code class="docutils literal notranslate"><span class="pre">abba</span></code>，长度为 <code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">-</span> <span class="pre">left</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">4</span></code>；如果以第1个字符 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 和第2个字符 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 之间的间隙为中心进行扩展，那么第一轮循环就出现了两端不等，循环直接结束，<code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">right</span> <span class="pre">=</span> <span class="pre">1</span></code>，长度为0。</p>
<p>下面我们可以尝试总结这个子算法的伪码描述：</p>
<div class="admonition- admonition">
<p class="admonition-title">中心扩展子算法</p>
<p><span class="math notranslate nohighlight">\(\text{Expand}(S,left,right):\)</span></p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(\text{WHILE  }left \ge 0 \text{  AND  } right \lt \text{ Len}(S) \text{  AND  } S[left]=S[right] \text{  DO:}\)</span></p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(left\leftarrow left-1\)</span></p>
<p><span class="math notranslate nohighlight">\(right\leftarrow right+1\)</span></p>
</div></blockquote>
<p><span class="math notranslate nohighlight">\(\text{RETURN  }right-left-1\)</span></p>
</div></blockquote>
</div>
<p>算法的主流程就只需要从头到尾的遍历每一个字符 <code class="docutils literal notranslate"><span class="pre">S[i]</span></code>，并对它先后进行两次扩展：一次调用 <span class="math notranslate nohighlight">\(\text{Expand}(S,i,i)\)</span> 进行以该字符本身为中心的扩展，另一次调用 <span class="math notranslate nohighlight">\(\text{Expand}(S,i,i+1)\)</span> 进行以它和它后一个字符之间的间隙为中心的扩展。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>对于最后一个字符 <code class="docutils literal notranslate"><span class="pre">S[n-1]</span></code> 的情况，也可以放心地调用 <span class="math notranslate nohighlight">\(\text{Expand}(S,i,i+1)\)</span>，因为此时右指针已经超过限制，所以中心扩展子算法的循环根本不会进入，直接会返回 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">(n-1)</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">0</span></code>。</p>
</div>
<p>先后两次扩展，会得到先后两个长度，为了得到对应的子串，我们还需要根据长度来推算出子串的起始位置。首先我们分情况进行考虑：</p>
<p>1、以字符 <code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 为中心进行扩展时，设得到的回文子串长度为 <span class="math notranslate nohighlight">\(l_1\)</span>，它一定为奇数且至少为1，可以表示为 <span class="math notranslate nohighlight">\(l_1=2k+1\)</span>，其中 <span class="math notranslate nohighlight">\(k\)</span> 是0或正整数。子串应该是在 <code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 前后各有 <span class="math notranslate nohighlight">\(k\)</span> 个字符，像下面这个样子：</p>
<div class="math notranslate nohighlight">
\[\underbrace{S[i-k]\cdots S[i-1]}_{\text{从}i-k\text{到}i-1\text{共}k\text{个字符}} S[i]\underbrace{S[i+1]\cdots S[i+k]}_{\text{从}i+1\text{到}i+k\text{共}k\text{个字符}}\]</div>
<p>它的左端字符位置为 <span class="math notranslate nohighlight">\(i-k=i-\frac{l_1-1}{2}\)</span>。</p>
<p>2、以字符 <code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">S[i+1]</span></code> 之间的间隙为中心进行扩展时，设得到的回文子串长度为 <span class="math notranslate nohighlight">\(l_2\)</span>，它是一个偶数或零，即 <span class="math notranslate nohighlight">\(l_2=2k\)</span>，<span class="math notranslate nohighlight">\(k\)</span> 也是0或正整数。子串应该是从 <code class="docutils literal notranslate"><span class="pre">S[i]</span></code> 开始向前有 <span class="math notranslate nohighlight">\(k\)</span> 个字符，从 <code class="docutils literal notranslate"><span class="pre">S[i+1]</span></code> 开始向后也有 <span class="math notranslate nohighlight">\(k\)</span> 个字符的样子：</p>
<div class="math notranslate nohighlight">
\[\underbrace{S[i-k+1]\cdots S[i]}_{\text{从}i-k+1\text{到}i\text{共}k\text{个字符}}\underbrace{S[i+1]\cdots S[i+k]}_{\text{从}i+1\text{到}i+k\text{共}k\text{个字符}}\]</div>
<p>左端字符位置为 <span class="math notranslate nohighlight">\(i-k+1=i-(\frac{l_2}{2}-1)\)</span>。</p>
<p>在数学上这是两个不同的公式，但是在用C++语言编程的时候，却可以利用整数除法的性质统一起来。我们知道C++的整数除法是直接删除小数部分进行取整的，即向下取整。所以对于偶数 <span class="math notranslate nohighlight">\(l_2\)</span>，如果用C++整数除法来计算 <span class="math notranslate nohighlight">\(\frac{l_2-1}{2}\)</span>，结果恰等于 <span class="math notranslate nohighlight">\(\frac{l_2}{2}-1\)</span>：</p>
<div class="math notranslate nohighlight">
\[\left\lfloor\frac{l_2-1}{2}\right\rfloor=\left\lfloor\frac{2k-1}{2}\right\rfloor=\left\lfloor\frac{2(k-1)+1}{2}\right\rfloor=\lfloor(k-1)+0.5\rfloor=k-1=\frac{l_2}{2}-1\]</div>
<p>于是我们就可把两种情况的公式统一为 <span class="math notranslate nohighlight">\(i-\frac{L-1}{2}\)</span>，其中 <span class="math notranslate nohighlight">\(L\)</span> 是扩展返回的回文子串长度。于是我们在循环中对每一个字符位置 <code class="docutils literal notranslate"><span class="pre">i</span></code> 进行两次中心扩展后，得到的两个长度中只需抛弃较小者，选其较大者参与最大长度的竞争即可，这无非就是找最大值这种简单的事情了。循环完毕最长回文子串就得到了。</p>
<p>完整的C++代码如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">100010</span><span class="p">];</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%100009s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="kt">clock_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="c1">// len1, len2: 以s[i]为中心和以s[i]s[i+1]中间的空隙为中心进行的两次中心扩展得到的回文子串长度</span>
	<span class="c1">// len1最小为1，因为单个字符s[i]肯定是回文串</span>
	<span class="c1">// len2最小为0，如果s[i] != s[i+1]，那么len2就等于0</span>
	<span class="c1">// len：取len1和len2中的大者</span>
	<span class="c1">// maxlen：保存下来的到目前为止找到的最长回文子串长度</span>
	<span class="c1">// left：保存下来的到目前为止找到的最长回文子串的起始位置（左端点）</span>
	<span class="c1">// maxlen初始为1，left初始为0，表示至少字符s[0]肯定是一个回文子串</span>
	<span class="kt">int</span> <span class="n">len1</span><span class="p">,</span> <span class="n">len2</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">maxlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len1</span> <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>		<span class="c1">// 以s[i]为中心进行扩展</span>
		<span class="n">len2</span> <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>	<span class="c1">// 以s[i]和s[i+1]中间的空隙为中心进行扩展</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">len1</span> <span class="o">&gt;</span> <span class="n">len2</span> <span class="o">?</span> <span class="nl">len1</span> <span class="p">:</span> <span class="n">len2</span><span class="p">;</span><span class="c1">// 取两次扩展得到的回文子串长度中的大者</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">maxlen</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">// 若len大于已知的最长回文子串，则更新maxlen和left</span>
			<span class="n">maxlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="c1">// 假设len来自于len1，表示以s[i]为中心的长度为len的子串为</span>
			<span class="c1">//     目前已知的最长回文子串，此时len必为奇数，最小值为1</span>
			<span class="c1">//     设len = len1 = 2 * k + 1，(k=0,1,2,...)</span>
			<span class="c1">//     那么此回文子串为s[i-k]...s[i]...s[i+k]</span>
			<span class="c1">//     即第一个字符的位置为left = i - k = i - (len - 1) / 2</span>
			<span class="c1">// 假设len来自于len2，表示以s[i]和s[i+1]为中心的长度为len的子串为</span>
			<span class="c1">//     目前已知的最长回文子串，此时len必为偶数。由于len1至少为1，</span>
			<span class="c1">//     而现在len2比len1更大，所以len最小值为2</span>
			<span class="c1">//     设len = len2 = 2 * k，(k=1,2,...)</span>
			<span class="c1">//     那么此回文子串为s[i-k+1]...s[i]s[i+1]...s[i+k]</span>
			<span class="c1">//     即第一个字符的位置为i - k + 1 = i - (k - 1)</span>
			<span class="c1">//     因为len为偶数，利用C++整数除法只取商的特性，有：</span>
			<span class="c1">//     (len - 1) / 2 = (2*k - 1) / 2 = k - 1</span>
			<span class="c1">//     所以这种情况下，同样有left = i - (len - 1) / 2</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">maxlen</span><span class="o">--</span><span class="p">)</span> <span class="n">putchar</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="o">++</span><span class="p">]);</span>	<span class="c1">// 从s[left]开始连续输出maxlen个字符</span>
	<span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;time elapsed = %ld ms.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">CLOCKS_PER_SEC</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// left &gt;= 0：表示左边的端点还在字符串s范围内</span>
	<span class="c1">// s[right]：利用C-string最后一个字符后面是结束标志&#39;\0&#39;的特点，只要s[right] != 0，就表示还在</span>
	<span class="c1">//           字符串s的范围之内。</span>
	<span class="c1">// s[left] == s[right]：扩展的两端相等，所以还可以进一步尝试扩展</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">left</span><span class="p">;</span>		<span class="c1">// 进一步扩展左端点</span>
		<span class="o">++</span><span class="n">right</span><span class="p">;</span>	<span class="c1">// 进一步扩展右端点</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// 能扩展到的最长回文子串长度</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同样的我们在这个程序里添加了测量运行时间的功能，同样用和前面一样的五个测试点数据进行测试，结果如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./mps_ex &lt; mps_1.in
A
time elapsed = 0 ms.

$ ./mps_ex &lt; mps_2.in
LJL
time elapsed = 0 ms.

$ ./mps_ex &lt; mps_3.in
MOM
time elapsed = 0 ms.

$ ./mps_ex &lt; mps_4.in
MLVLM
time elapsed = 0 ms.

$ ./mps_ex &lt; mps_5.in
LMLXLML
time elapsed = 1 ms.
</pre></div>
</div>
<p>意不意外？惊不惊喜？十万个字符长度的字符串，整个过程只用了1毫秒！其他都在1毫秒以内。即使用了目前最快的 <span class="math notranslate nohighlight">\(O(n)\)</span> 时间的马拉车算法，在平均情况下也不能比中心扩展法有明显的改进了。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>当然在最坏情况（所有字符全部相同，比如 <code class="docutils literal notranslate"><span class="pre">&quot;aaaaa&quot;</span></code>）而且字符串长度很长时，二者还是有速度差异的。但是马拉车算法太难记住太难考场盲写了，所以通常来说还是中心扩展算法更加实用。在普及、提高这两个阶段，也很少出现非用马拉车算法不可的题目。所以大家一定要牢牢掌握中心扩展算法并且能自行编程实现。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="236_cpp_string_intro.html" title="3.3.6. C++ string简介"
             >下一页</a> |</li>
        <li class="right" >
          <a href="234_substr_kmp.html" title="3.3.4. 子串搜索及KMP算法"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../230_basic_string_algos.html" ><span class="section-number">3.3. </span>简单字符串处理</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>