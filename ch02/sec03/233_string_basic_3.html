
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.3.3. 字符串处理基础知识(III) &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.3.4. 子串搜索及KMP算法" href="234_substr_kmp.html" />
    <link rel="prev" title="3.3.2. 字符串处理基础知识(II)" href="232_string_basic_2.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="234_substr_kmp.html" title="3.3.4. 子串搜索及KMP算法"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="232_string_basic_2.html" title="3.3.2. 字符串处理基础知识(II)"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../230_basic_string_algos.html" accesskey="U"><span class="section-number">3.3. </span>简单字符串处理</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.3.3. 字符串处理基础知识(III)</a><ul>
<li><a class="reference internal" href="#id1">3.3.3.1. 字典序</a></li>
<li><a class="reference internal" href="#c-string">3.3.3.2. C-string小结</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="232_string_basic_2.html"
                        title="上一章"><span class="section-number">3.3.2. </span>字符串处理基础知识(II)</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="234_substr_kmp.html"
                        title="下一章"><span class="section-number">3.3.4. </span>子串搜索及KMP算法</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec03/233_string_basic_3.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="iii">
<h1><span class="section-number">3.3.3. </span>字符串处理基础知识(III)<a class="headerlink" href="#iii" title="永久链接至标题">¶</a></h1>
<p>这一节我们对字符串处理的其他几个重要的基本知识点进行说明。</p>
<div class="section" id="id1">
<h2><span class="section-number">3.3.3.1. </span>字典序<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>在计算机编程语言里，字符串都是可以比较“大小”的，或者更准确地说，字符串是可以有序的。我们知道，实数也是有序的，实数的序依据的是数值的大小。字符串本身并没有大小的区别，比如 <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;world&quot;</span></code> 这两个字符串谁大谁小呢？因此字符串的序依据的不是某个数值的大小，而是依据组成字符串的字符在字符表中的顺序，称为<strong>字典序</strong>。</p>
<p>在算法编程的环境里使用的字符表是ASCII码表，共有127个字符，包括了数字、大小写字母、常见的标点符号、算术运算符号、空白符（空格、换行、tab）和其他一些控制字符，另外还有一个非常特别的空字符 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>，对应的数值编号为0，在C-string里用作字符串结尾标志。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>C语言在标准库 <code class="docutils literal notranslate"><span class="pre">cstdio</span></code>、<code class="docutils literal notranslate"><span class="pre">cstring</span></code>、<code class="docutils literal notranslate"><span class="pre">cstdlib</span></code> 中都定义了一个宏 <code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">NULL</span> <span class="pre">0</span></code>，如果引入过这几个库之一就可以用 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 来代替 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>。但C++语言认为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 这个用法有很麻烦的多义性，比如它可以用来表示整数0、可以表示空字符、也可以用来表示空指针，所以不推荐使用这个符号。</p>
<p>在字符串处理时如果要表示空字符，建议还是使用 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>，如果要表示空指针，则应该用 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> 这个符号。</p>
</div>
<p>字符在字符表中的顺序由它们在码表里的编码的大小来确定。所以空字符是最小的字符。在ASCII编码表中，常见的用于字符串的字符顺序如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&#39;\0&#39; &lt; &#39;\t&#39; &lt; &#39;\n&#39; &lt; &#39; &#39; &lt; &#39;0&#39; &lt; ... &lt; &#39;9&#39; &lt; &#39;A&#39; &lt; ... &lt; &#39;Z&#39; &lt; &#39;a&#39; &lt; ... &lt; &#39;z&#39;
</pre></div>
</div>
<p>这是大多数字符串处理问题需要用到的字符顺序关系，完整的ASCII码表可以查询相关资料。知道了字符的编码顺序之后就很容易理解字符串的字典序规则了，规则一共就三条：</p>
<ol class="arabic simple">
<li><p>按照从左到右的顺序逐个比较两个字符串相同位置上的字符大小，直到找到第一个字符不同的位置或有一个字符串结束。</p></li>
<li><p>第一个字符不同的位置上，哪个字符串的字符小这个字符串的字典序就小；如果有一个字符串结束了还没有找到字符不相等的位置，那么短的那个字符串的字典序小（对于C-string，短者更小的规则是天然适应的，因为短的那个字符串在结尾处有一个天然最小的空字符）。</p></li>
<li><p>如果一直没有找到字符不同的位置，而且两个字符串同时结束，那么二者的字典序相等（这也就是两个字符串长度相同、每一个位置上的字符都相等）。</p></li>
</ol>
<p>按照这一套比较规则，我们可以举几个例子：<code class="docutils literal notranslate"><span class="pre">&quot;ABCD&quot;</span> <span class="pre">&lt;</span> <span class="pre">&quot;BCD&quot;</span></code>，<code class="docutils literal notranslate"><span class="pre">&quot;AB&quot;</span> <span class="pre">&lt;</span> <span class="pre">&quot;ab&quot;</span></code>，<code class="docutils literal notranslate"><span class="pre">&quot;X&quot;</span> <span class="pre">&lt;</span> <span class="pre">&quot;XYZ&quot;</span></code>，<code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span> <span class="pre">&lt;</span> <span class="pre">&quot;world&quot;</span></code>。可见对于纯英文字母构成的字符串，它们的排列规则和英语词典中单词的排列规则是一致的，这也是字典序这个名称的由来。但如果是纯数字字符构成的整数形式的字符串，却并不是和它们对应的数值顺序一致的，例如 <code class="docutils literal notranslate"><span class="pre">&quot;87&quot;</span> <span class="pre">&lt;</span> <span class="pre">&quot;9&quot;</span></code>，而整数87显然比9大。这一点一定要记住。</p>
<p><code class="docutils literal notranslate"><span class="pre">cstring</span></code> 标准库提供 <code class="docutils literal notranslate"><span class="pre">strcmp()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">strncmp()</span></code> 两个函数用于C-string的字典序比较。C++ string则简单粗暴地直接使用六种关系运算符 <code class="docutils literal notranslate"><span class="pre">==,</span> <span class="pre">!=,</span> <span class="pre">&lt;,</span> <span class="pre">&gt;,</span> <span class="pre">&lt;=,</span> <span class="pre">&gt;=</span></code>。</p>
</div>
<div class="section" id="c-string">
<h2><span class="section-number">3.3.3.2. </span>C-string小结<a class="headerlink" href="#c-string" title="永久链接至标题">¶</a></h2>
<p>现在我们对字符串处理的一些基本概念和最基本的一些操作都已经学完了。字符串是一类重要的信息类型，字符串处理是计算机信息处理中最为重要的技术之一。从概念本身来讲，字符串就是由一连串连续字符构成的信息串，只是不同的编程语言对于字符串的表示形式各有不同，其内在本质都是相同的。</p>
<p>在C++语言来说，C-string和C++ string类都是其表示字符串的形式。从C语言继承而来的C-string最大的优势是速度快，所以现在许多的程序还在坚持使用C-string来进行字符串处理。常用的C-string处理都采用 <code class="docutils literal notranslate"><span class="pre">cstring</span></code> 库中的C语言标准库函数，前面已经看到过许多，在 <code class="docutils literal notranslate"><span class="pre">cstdio</span></code> 库中也提供了几套用于字符和C-string输入输出的库函数。这些库函数最大的特点也是速度非常的快，如果用C-string来进行字符串处理，就离不开这些库函数的使用。下面对它们进行一个小结。</p>
<p><strong>8个C-string常用库函数</strong></p>
<p>与C-string基本处理相关的库函数全部由 <code class="docutils literal notranslate"><span class="pre">cstring</span></code> 库提供，使用前必须先引入该库。</p>
<p>1、获取C-string <code class="docutils literal notranslate"><span class="pre">s</span></code> 的实际长度。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>2、获取C-string <code class="docutils literal notranslate"><span class="pre">s</span></code> 的实际长度，但以 <code class="docutils literal notranslate"><span class="pre">maxlen</span></code> 为上限，即如果长度超过 <code class="docutils literal notranslate"><span class="pre">maxlen</span></code> 则返回 <code class="docutils literal notranslate"><span class="pre">maxlen</span></code> 的值。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">maxlen</span><span class="p">);</span>
</pre></div>
</div>
<p>3、将C-string <code class="docutils literal notranslate"><span class="pre">src</span></code> 的内容复制到C-string <code class="docutils literal notranslate"><span class="pre">dst</span></code> 中，返回值就是指向 <code class="docutils literal notranslate"><span class="pre">dst</span></code> 的指针。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">src</span><span class="p">);</span>
</pre></div>
</div>
<p>需注意，此函数复制时并不考虑 <code class="docutils literal notranslate"><span class="pre">dst</span></code> 的长度是否足够，因此可能引起超限错误，需要程序员自己确保足够的空间。</p>
<p>4、将C-string <code class="docutils literal notranslate"><span class="pre">src</span></code> 中最多 <code class="docutils literal notranslate"><span class="pre">len</span></code> 个字符复制到C-string <code class="docutils literal notranslate"><span class="pre">dst</span></code> 中，返回值就是指向 <code class="docutils literal notranslate"><span class="pre">dst</span></code> 的指针。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">strncpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>需注意，若 <code class="docutils literal notranslate"><span class="pre">src</span></code> 的实际长度超过 <code class="docutils literal notranslate"><span class="pre">len</span></code>，那么复制之后不会自动在 <code class="docutils literal notranslate"><span class="pre">dst</span></code> 中添加空字符 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> 作为结尾标志，因此这种情况下 <code class="docutils literal notranslate"><span class="pre">dst</span></code> 不保证有正确的结尾。</p>
<p>5、比较 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 的字典序，若二者相等，则返回0；若 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 先于（小于）<code class="docutils literal notranslate"><span class="pre">s2</span></code> 则返回一个负数；若 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 后于（大于）<code class="docutils literal notranslate"><span class="pre">s2</span></code> 则返回一个正数。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">strcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">);</span>
</pre></div>
</div>
<p>6、比较 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 的字典序，返回值的规则和 <code class="docutils literal notranslate"><span class="pre">strcmp()</span></code> 函数相同，但是最多只比较前 <code class="docutils literal notranslate"><span class="pre">n</span></code> 个字符。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">strncmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>7、将 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 的内容拼接到 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 的后面，返回指向 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 的指针。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">strcat</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">s2</span><span class="p">);</span>
</pre></div>
</div>
<p>需注意：此函数并不考虑 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 中的长度是否足够，因此可能引起超限错误，需要程序员自己确保足够的空间。</p>
<p>8、将 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 中最多 <code class="docutils literal notranslate"><span class="pre">n</span></code> 个字符拼接到 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 的后面，返回指向 <code class="docutils literal notranslate"><span class="pre">s1</span></code> 的指针。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">strncat</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>C-string输入输出</strong></p>
<p>与C-string的输入输出相关的库函数都在 <code class="docutils literal notranslate"><span class="pre">cstdio</span></code> 库中提供，使用前必须先引入该库。</p>
<p>1、<code class="docutils literal notranslate"><span class="pre">scanf()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">printf()</span></code></p>
<p>此二者是最为常用的C-string输入输出函数，占位符为 <code class="docutils literal notranslate"><span class="pre">%s</span></code>。在输入时，可以添加长度限制 <code class="docutils literal notranslate"><span class="pre">%ns</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">n</span></code> 是一个整数，表示最多读入 <code class="docutils literal notranslate"><span class="pre">n</span></code> 个字符，不包括最后的结尾标志符 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>。因此这个长度限制至少应该要比实际的字符数组长度小1。例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">81</span><span class="p">];</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%80s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>  <span class="c1">// 请注意这里限制的长度是80而不是81</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;You entered: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>优点：功能强大灵活，可以和多个别的数据同时输入输出。例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">81</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">age</span><span class="p">;</span>

<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%80s %hu&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">);</span>  <span class="c1">// 请注意这里限制的长度是80而不是81</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;NAME is %s, AGE = %hu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
</pre></div>
</div>
<p>缺点：<code class="docutils literal notranslate"><span class="pre">scanf()</span></code> 只能输入以“单词”为单位的字符串，即字符串中不能出现空白符（空格、tab、换行）。例如上面那个例子中，如果要输入的名字是Bill Gates，那么就会出错，<code class="docutils literal notranslate"><span class="pre">s</span></code> 只会读到Bill就结束了。</p>
<p>2、<code class="docutils literal notranslate"><span class="pre">gets()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">puts()</span></code></p>
<p>这两个函数称为“按行”读写字符串的一对函数。顾名思义，按行读写就是一行一行的读和写，所谓“行”就是以换行符 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 为间隔的字符串，中间允许有空格、tab等任何只要不是 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 的字符。</p>
<p>先看按行输入字符串的函数 <code class="docutils literal notranslate"><span class="pre">gets()</span></code>，它的函数原型是：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">gets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
<p>这个函数从标准输入设备stdin，通常就是键盘，读取一行字符，存放于 <code class="docutils literal notranslate"><span class="pre">str</span></code> 并自动在末尾添加空字符 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> 以标志字符串结尾。它的返回值就是 <code class="docutils literal notranslate"><span class="pre">str</span></code>。这个函数在按行读入字符串之后，会自动把最后的换行符 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 舍弃掉。</p>
<p>按行输出字符串的函数 <code class="docutils literal notranslate"><span class="pre">puts()</span></code> 的函数原型是：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">puts</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>它将字符串 <code class="docutils literal notranslate"><span class="pre">s</span></code> 输出到标准输出设备stdout，通常就是终端窗口。它会自动在字符串输出完成后再额外输出一个换行符 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，这也就是它被称为按行输出函数的原因。</p>
<p>下面这个简单的程序是一个复读机程序，它可以不断地复制你输入的每一行文字，直到遇到一个空行（只含一个换行符的行）：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">gets</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>看上去很好用，对不对？在过去的好时光里，<code class="docutils literal notranslate"><span class="pre">gets()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">puts()</span></code> 是非常好用深受程序员欢迎的一对按行读写字符串的函数。然而现在我们却要强烈建议大家不要使用这一对函数，为什么呢？如果我们去编译上面这个简单的小程序，十有八九会得到这样一句警告：<code class="docutils literal notranslate"><span class="pre">warning:</span> <span class="pre">this</span> <span class="pre">program</span> <span class="pre">uses</span> <span class="pre">gets(),</span> <span class="pre">which</span> <span class="pre">is</span> <span class="pre">unsafe.</span></code>。意思是：这个程序使用了不安全的 <code class="docutils literal notranslate"><span class="pre">gets()</span></code> 函数。</p>
<p>更有甚者，有些环境（例如苹果的MacOS）下编译时可能不会发出这条警告，而是在运行程序的时候才会出现。这样搞程序就不可能通过测试了。而且，虽然现在算法竞赛使用的C++98标准还可以使用这一对函数，但从C++11开始干脆就已经从 <code class="docutils literal notranslate"><span class="pre">cstdio</span></code> 库中删除了这一对函数。</p>
<p>为什么会这样呢？如果你对C-string处理非常熟悉，或者对编程时的常见bug非常熟悉的话，可能已经猜到了原因：<code class="docutils literal notranslate"><span class="pre">gets()</span></code> 函数对读入的字符串长度没有限制！它会傻傻地一直读直到遇见第一个换行符为止，并把所有读入的字符都存放到参数 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*str</span></code> 所指向的内存里，不管是不是超限。这个漏洞已经多次被黑客利用来植入病毒、蠕虫等有害代码。所以，我们不要使用这对函数，这里对它们进行介绍只是为了让大家认识它们，毕竟还有不少算法书里会用它们，遇到的时候能看懂就可以了。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>任何时候不要在你的程序中使用 <code class="docutils literal notranslate"><span class="pre">gets()</span></code> 和与之配套的 <code class="docutils literal notranslate"><span class="pre">puts()</span></code> 函数。如果程序需要按行读写字符串，那么使用下面介绍的这一对 <code class="docutils literal notranslate"><span class="pre">fgets()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fputs()</span></code> 函数。</p>
</div>
<p>3、<code class="docutils literal notranslate"><span class="pre">fgets()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fputs()</span></code></p>
<p>这一对函数是用来替代前面所述的不安全的 <code class="docutils literal notranslate"><span class="pre">gets()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">puts()</span></code> 的。它们的功能同样是按行读写字符串，但和前面那一对函数有所不同。</p>
<p>按行读取字符串函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">fgets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>现在这个函数有三个参数，第一个参数 <code class="docutils literal notranslate"><span class="pre">str</span></code> 指向要读入的字符串；第二个参数 <code class="docutils literal notranslate"><span class="pre">size</span></code> 是读字符量的上限，每次读取最多读 <code class="docutils literal notranslate"><span class="pre">size-1</span></code> 个字符，因为后面还要有一个位置放结尾空字符；第三个参数 <code class="docutils literal notranslate"><span class="pre">stream</span></code> 是输入设备，如果是标准输入设备键盘就直接写stdin，如果是从某个文件读入那么就是这个文件的指针（打开文件时返回的指针，很多教科书上管这个东西叫文件的<strong>句柄</strong>）。</p>
<p>与之配套的按行输出字符串函数是：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fputs</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>这个函数现在除了要输出的字符串 <code class="docutils literal notranslate"><span class="pre">s</span></code> 以外也多了一个 <code class="docutils literal notranslate"><span class="pre">stream</span></code> 参数，猜猜也知道这是表示输出设备的参数，如果是标准输出设备终端窗口就直接写stdout，如果是写入到某个文件那么就是这个文件的句柄。</p>
<p><code class="docutils literal notranslate"><span class="pre">fputs</span></code> 函数不像它的前任 <code class="docutils literal notranslate"><span class="pre">puts()</span></code> 函数那样会在输出字符串之后自动添加一个换行。<code class="docutils literal notranslate"><span class="pre">puts()</span></code> 会这么做是因为它是和 <code class="docutils literal notranslate"><span class="pre">gets()</span></code> 配套使用的，由于 <code class="docutils literal notranslate"><span class="pre">gets()</span></code> 函数在读入完成后会自动删除行末的换行符，所以 <code class="docutils literal notranslate"><span class="pre">puts()</span></code> 觉得它有责任添加回去。但是 <code class="docutils literal notranslate"><span class="pre">fputs()</span></code> 函数是和 <code class="docutils literal notranslate"><span class="pre">fgets()</span></code> 配套的，<code class="docutils literal notranslate"><span class="pre">fgets()</span></code> 在输入完成后并不会删除行尾的换行符！如果字符串末尾是一个换行符，那么这个换行符会被保留在字符串里面！所以 <code class="docutils literal notranslate"><span class="pre">fputs()</span></code> 就觉得自己没必要画蛇添足去加一个换行。</p>
<p>现在我们可以把上面这个复读机程序改写为安全的版本了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="c1">// size=数组长度80，无需减1，但每次最多读79个字符</span>
                <span class="n">fputs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fgets()</span></code> 读入的字符串，末尾很可能是一个换行符。如果我们认为换行符不是我们要的字符串的一部分，那么就需要自己编写代码来删除这个可能存在的 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，代码如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="n">str</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>4、<code class="docutils literal notranslate"><span class="pre">getchar()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">putchar()</span></code></p>
<p>这一对函数是用来输入和输出单个字符的。请注意是单个字符，而不是字符串，它们的参数和返回值是 <code class="docutils literal notranslate"><span class="pre">int</span></code>：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">getchar</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">getchar()</span></code> 函数从标准输入设备读入一个单个的字符。这个函数没有参数，返回类型是 <code class="docutils literal notranslate"><span class="pre">int</span></code>。实际上，正常情况下返回的 <code class="docutils literal notranslate"><span class="pre">int</span></code> 型数值其实是一个 <code class="docutils literal notranslate"><span class="pre">char</span></code>，取值范围是0到255，所以正常情况下可以安全地将其赋值给一个 <code class="docutils literal notranslate"><span class="pre">char</span></code> 型变量，例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>   <span class="c1">// 从标准输入设备读取一个字符给 ch</span>
</pre></div>
</div>
<p>那么为什么这个库函数的设计者要把返回类型定义为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 呢？这是为了应对“不正常”的情况，通常是指读到输入结束了，例如键盘上输入了Ctrl-D（Windows系统下是Ctrl-Z）或者是读到输入文件的末尾了，也有可能是读入过程出错了。这种时候需要返回一个标志性的数值来表示读入出现了异常，这个标志显然不能和任何ASCII字符相同。在 <code class="docutils literal notranslate"><span class="pre">cstdio</span></code> 库中定义了这样一个标志 <code class="docutils literal notranslate"><span class="pre">EOF</span></code>，其值通常是-1，这就在 <code class="docutils literal notranslate"><span class="pre">int</span></code> 型的范围之内了。所以如果 <code class="docutils literal notranslate"><span class="pre">getchar()</span></code> 返回了 <code class="docutils literal notranslate"><span class="pre">EOF</span></code>，那么表示输入该结束了。</p>
<p>与之相对应的是单个字符输出函数 <code class="docutils literal notranslate"><span class="pre">putchar()</span></code>。这个函数以ASCII字符的方式输出它的参数 <code class="docutils literal notranslate"><span class="pre">c</span></code> 到标准输出设备，正常情况下仍然返回 <code class="docutils literal notranslate"><span class="pre">c</span></code> 的值。异常情况，通常是输出设备故障等出错情况时，返回 <code class="docutils literal notranslate"><span class="pre">EOF</span></code>。</p>
<p>比如下面这个程序，就是用这一对函数实现的另一个版本的复读机程序：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// copy.cpp - a very simple but very powerful tool</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="n">putchar</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个复读机程序比前面两个版本都更加完善。前两个版本的复读机都以遇到一个空行为输入结束标志，所以如果输入中确实需要有空行就不行了。但是这个版本通过判断是否读到 <code class="docutils literal notranslate"><span class="pre">EOF</span></code> 来判断输入是否结束，所以可以适用于任何格式的ASCII文本输入。把这个程序编译一下，可执行文件命名为copy，结合输入输出重定向功能，它可以有以下用途：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">./copy</span></code>：按行复读从键盘输入的任何文本，在Linux/MacOS/Unix系统下，输入Ctrl-D表示输入结束，在Windows系统下则是输入Ctrl-Z表示输入结束。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./copy</span> <span class="pre">&lt;</span> <span class="pre">aaa.txt</span></code>：在终端屏幕上输出文本文件aaa.txt的内容。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./copy</span> <span class="pre">&gt;</span> <span class="pre">bbb.txt</span></code>：通过键盘输入多行文本，将输入的内容照原样保存到文本文件bbb.txt中，同样地以Ctrl-D或Ctrl-Z来结束输入。这就是一个最最简单的文本编辑器了。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./copy</span> <span class="pre">&lt;</span> <span class="pre">ccc</span> <span class="pre">&gt;</span> <span class="pre">ddd</span></code>：复制文件ccc为ddd，这就是一个文件复制工具，神奇的是它不仅限于能复制ASCII字符构成的文本文件，而是能复制任何文件！</p></li>
</ul>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p><code class="docutils literal notranslate"><span class="pre">getchar()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">putchar()</span></code> 是C++语言中速度最快的输入输出函数，比 <code class="docutils literal notranslate"><span class="pre">cin</span> <span class="pre">&gt;&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cout</span> <span class="pre">&lt;&lt;</span></code> 快，比 <code class="docutils literal notranslate"><span class="pre">scanf()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">printf()</span></code> 快，比任何其他输入输出方法都要快！如果遇到单个字符输入输出的情况，请务必使用它们。</p>
</div>
<p>由于 <code class="docutils literal notranslate"><span class="pre">getchar()</span></code> 的速度实在太快，所以有人很喜欢抛弃其他输入方法，基于 <code class="docutils literal notranslate"><span class="pre">getchar()</span></code> 来自行编写一些快速的输入函数，称之为“快读”。例如下面这个程序利用一个自定义的整数快读函数 <code class="docutils literal notranslate"><span class="pre">readint()</span></code> 来连续读取5个整数，然后用反转顺序依次输出：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">readint</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ch</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="n">neg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>	<span class="c1">// 是否负数的标志</span>
	<span class="c1">// 先读完输入缓存中的所有无效字符，直到出现0-9的数字符或正负号+，-</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">&gt;</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">!=</span> <span class="sc">&#39;+&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="n">neg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">neg</span> <span class="o">?</span> <span class="o">-</span><span class="nl">n</span> <span class="p">:</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个快读函数的强大之处是它可以剔除所有不构成一个 <code class="docutils literal notranslate"><span class="pre">int</span></code> 型数值的字符，所以我们的输入甚至可以是这样的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1 abc22efg333   hello +4444 world-55555
</pre></div>
</div>
<p>上面的输入，程序会从这一串杂乱的文本中挑出五个合法整数，然后得到下面的输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-55555
4444
333
22
1
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>然而在实际解决问题时，输入的格式是多种多样的。一味迷信快读，需要给每一个不同的程序编写各自不同的快读函数，这会增加许多代码量，更有可能引入意想不到的bug。例如我们前面这个 <code class="docutils literal notranslate"><span class="pre">readint()</span></code> 函数，如果遇到输入中有连续的正负号，<code class="docutils literal notranslate"><span class="pre">+++12++123</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">----</span></code> 这样的情况时，就会出问题。</p>
<p>而且在这个世界上几乎没有用 <code class="docutils literal notranslate"><span class="pre">scanf()</span></code> 输入数据会TLE的算法编程题。偶尔遇到用 <code class="docutils literal notranslate"><span class="pre">cin</span> <span class="pre">&gt;&gt;</span></code> 会出问题的题目，改成 <code class="docutils literal notranslate"><span class="pre">scanf()</span></code> 一定没问题。</p>
<p>所以，编写快读函数可以作为锻炼编程技巧、探究输入输出细节知识的一种练习，但是绝不推荐在实际解题时使用！</p>
</div>
<p>5、<code class="docutils literal notranslate"><span class="pre">fgetc()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fputc()</span></code></p>
<p>最后是一对最不常用的单字符输入输出函数，它们用来从文件中读入单个字符和将单个字符写入文件中去：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fgetc</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">fputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>它们和 <code class="docutils literal notranslate"><span class="pre">getchar()</span></code>、<code class="docutils literal notranslate"><span class="pre">putchar()</span></code> 的区别就是多了一个文件句柄参数，表示要从那个文件里读、要向哪个文件里写，其他都是一模一样的。实际上 <code class="docutils literal notranslate"><span class="pre">getchar()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">putchar()</span></code> 就是用它们俩来实现的，因为标准输入设备stdin和标准输出设备stdout本身也是文件句柄。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>   <span class="c1">// 这其实就是 ch = getchar();</span>
<span class="n">fputc</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>   <span class="c1">// 这其实就是 putchar(ch);</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="234_substr_kmp.html" title="3.3.4. 子串搜索及KMP算法"
             >下一页</a> |</li>
        <li class="right" >
          <a href="232_string_basic_2.html" title="3.3.2. 字符串处理基础知识(II)"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../230_basic_string_algos.html" ><span class="section-number">3.3. </span>简单字符串处理</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>