
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.2.5. 差分法（洛谷P3397） &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.2.6. 尺取法（洛谷P1147）" href="226_two_points.html" />
    <link rel="prev" title="3.2.4. 前缀和" href="224_prefix_sum.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="226_two_points.html" title="3.2.6. 尺取法（洛谷P1147）"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="224_prefix_sum.html" title="3.2.4. 前缀和"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../220_basic_online_algos.html" accesskey="U"><span class="section-number">3.2. </span>简单在线统计</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.2.5. 差分法（洛谷P3397）</a><ul>
<li><a class="reference internal" href="#id1">3.2.5.1. 线性差分</a></li>
<li><a class="reference internal" href="#id2">3.2.5.2. 二维差分（洛谷P3397）</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="224_prefix_sum.html"
                        title="上一章"><span class="section-number">3.2.4. </span>前缀和</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="226_two_points.html"
                        title="下一章"><span class="section-number">3.2.6. </span>尺取法（洛谷P1147）</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec02/225_diff.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="p3397">
<span id="index-0"></span><h1><span class="section-number">3.2.5. </span>差分法（洛谷P3397）<a class="headerlink" href="#p3397" title="永久链接至标题">¶</a></h1>
<p><strong>差分法</strong>是一种极其常用的算法技巧，是普及组和提高组试题中的常考知识点。一维的线性差分题常常出现在普及组和提高组Day1的试题中，二维差分和树上差分则是提高组Day2的常见题型。</p>
<div class="section" id="id1">
<h2><span class="section-number">3.2.5.1. </span>线性差分<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p><strong>线性差分</strong>用于简化处理数列上的一系列区间修改，它是基于前缀和来实现的。在学会了线性差分后将其扩展到二维情形是不难的。另外还有一种针对树结构的<strong>树上差分</strong>，我们将在后面学过树结构后再介绍。本节就先介绍最基本的一维线性差分，简称<strong>差分</strong>。</p>
<div class="admonition- admonition">
<p class="admonition-title">数学</p>
<p>差分本身是一个数学概念，它应用在离散函数，也就是通常所说的数列上，用来表示每一对前后项之间的差。最常用的叫做<strong>前向差分</strong>，也就是通常所说的差分。数列 <span class="math notranslate nohighlight">\(\{a_n\}\)</span> 中第 <span class="math notranslate nohighlight">\(i\)</span> 项上的差分等于它的后一项减去它自己的差，记作 <span class="math notranslate nohighlight">\(\Delta a_i=a_{i+1}-a_i\)</span>，可以理解为从当前项前进到后一项时数值的改变量。对于数列的尾项，由于它没有后项了，所以尾项没有差分。</p>
<p>这样的话，一个项数为n的数列，它的差分数列项数为n-1。例如数列 [2,5,3,4]，它的差分数列就是 [3,-2,1]。</p>
<p>可以看到，差分数列反映了原数列中数值的变化波动过程，但是由于前向差分数列并不知道原数列的首项是什么，所以不能从它倒推出原数列，只能得出波动情况。在实际应用中，有时候为了让差分数列能完整再现原数列，会在原数列首项之前虚拟一个等于零的项 <span class="math notranslate nohighlight">\(a_0=0\)</span>，这样差分数列就会从 <span class="math notranslate nohighlight">\(\Delta a_0=a_1-a_0=a_1\)</span> 开始。这样数列和它的差分就有了一致的项数，而差分的首项就是数列的首项，从差分可以逐步还原整个原数列。</p>
<p>例如上面举的那个例子，加上虚拟的 <span class="math notranslate nohighlight">\(a_0=0\)</span> 之后它的差分就变成了 [2,3,-2,1]。</p>
</div>
<p>数列的区间修改处理是指对指定子区间里的所有元素进行相同的增减修改。例如数列 [1,2,3,4]，对其从首项到第3项的子区间做加1处理之后，变成 [2,3,4,4]。然后再对从第2项到第3项的子区间做加2处理，变成 [2,5,6,4]。最后再对第2项到第4项的子区间做减1处理，数列最终变成 [2,4,5,3]。这就是所谓的多次区间修改。</p>
<p>用最普通的模拟法也可以完成上述操作，只要每次都按照修改要求对指定区间中的元素循环完成规定的加减就可以了。但是如果数列很大，每次修改的区间长度都很长，而且整套操作下来修改的次数又非常之多的话，简单模拟效率就很低。假设修改次数为 <span class="math notranslate nohighlight">\(m\)</span>，修改区间的平均长度为 <span class="math notranslate nohighlight">\(n\)</span>，那么简单模拟的时间复杂度为 <span class="math notranslate nohighlight">\(O(mn)\)</span>，这样的时间效率，数据量稍大就要等着TLE了。因此我们需要利用差分来优化整个操作过程，差分在这里可以理解为反向运用前缀和的技巧，通过计算前缀和来构造出数据，它可以把时间复杂度降低到 <span class="math notranslate nohighlight">\(O(m+n)\)</span>。</p>
<p>差分，其实是把区间操作改成点上的操作。要实现这种改变，第一步要做的事情是：在每次修改时导致数据发生改变的起点（修改区间的左端点）和数据不再改变的起点（修改区间右端点之后的第一个位置，如果右端点是整个数列的终点，那么就忽略这个点）这两个特殊点上记录数据的改变情况，最终形成一张“修改指令表”。</p>
<p>这张重要的“修改指令表”有一个听上去很酷的名字，叫做<strong>差分表</strong>，在编程时通常用一个数组来表示，就叫<strong>差分数组</strong>。差分数组的长度应该至少为原数列的项数，初始值必须为全0。让我们用上面所举的那个例子来看看怎样一步步地生成差分数组，假设原数列保存在数组 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">data[4]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4</span> <span class="pre">}</span></code> 中，差分数组定义并初始化为 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">diff[4]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">0</span> <span class="pre">}</span></code> （请注意我们这次没有把数组的0号元素空出来，而是从0号元素开始存放实际数据了）。下面演示怎样处理三次区间修改：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>第1次修改：对从第1个到第3个数的子区间做加1操作

           区间左端点 L = 0，右端点 R = 2，加数 P = 1

           本次修改数据发生改变的起点为 L = 0，因此在差分数组相应位置上执行此修改 diff[0] += 1

           本次修改数据不再改变的起点为 R+1 = 3，因此在差分数组相应位置上执行此修改的反操作 diff[3] -= 1

           第1次修改处理完成，差分数组变成 { 1, 0, 0, -1 }

第2次修改：对从第2个到第3个数的子区间做加2操作

           区间左端点 L = 1，右端点 R = 2，加数 P = 2

           本次修改数据发生改变的起点为 L = 1，因此在差分数组相应位置上执行此修改 diff[1] += 2

           本次修改数据不再改变的起点为 R+1 = 3，因此在差分数组相应位置上执行此修改的反操作 diff[3] -= 2

           第1次修改处理完成，差分数组变成 { 1, 2, 0, -3 }

第1次修改：对从第2个到第4个数的子区间做加1操作

           区间左端点 L = 1，右端点 R = 3，加数 P = -1

           本次修改数据发生改变的起点为 L = 1，因此在差分数组相应位置上执行此修改 diff[1] += -1 (即减1)

           本次修改数据不再改变的起点为 R+1 = 4，超出范围，忽略

           第1次修改处理完成，差分数组变成 { 1, 1, 0, -3 }
</pre></div>
</div>
<p>处理完所有区间修改之后，我们得到了差分表 <code class="docutils literal notranslate"><span class="pre">{1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-3}</span></code>。乍看上去好像很难理解这样一张差分表有什么用处。确实，它还不能马上应用，后面还有一步重要的操作要做，那就是对它做前缀和处理。这个例子的数据很简单，我们手工计算一下就可以很简单地得到它的前缀和 <code class="docutils literal notranslate"><span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">-1}</span></code>。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>到这里为止，请大家暂停一下先不要继续往下阅读。先对照例子中的原数列和最终结果数列，再对照一下我们得到的差分前缀和，想一想它的每一项代表了什么意思？然后对照差分的数学意义想一想差分表里的每一项又代表什么意思？再想一想为什么能得到这张神奇的差分表？如果能想明白这三个问题，那么线性差分的原理就彻底搞懂了，以后也不会再忘了这个算法技巧了。</p>
</div>
<p>是的，现在差分表里每个位置上的数，就表示原数列相应位置的数的最终改变量。现在只需要简单得把差分数组里的每一个数 <code class="docutils literal notranslate"><span class="pre">diff[i]</span></code> 一一加到原数组相应位置 <code class="docutils literal notranslate"><span class="pre">data[i]</span></code> 上去就完成了整个多次区间修改操作。在这个例子里最后一步的操作是这样的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   data: { 1, 2, 3, 4  }
+) diff: { 1, 2, 2, -1 }
-------------------------
   data: { 2, 4, 5, 3  }
</pre></div>
</div>
<p>这正是我们所要的正确结果。</p>
<p>如果原数列一共有 <span class="math notranslate nohighlight">\(n\)</span> 个数，区间修改一共进行了 <span class="math notranslate nohighlight">\(m\)</span> 次，那么处理每一次修改要用2次加法，总共 <span class="math notranslate nohighlight">\(2m\)</span> 次，差分数组求前缀和要用 <span class="math notranslate nohighlight">\(n\)</span> 次加法，最后差分加到数据上去也是 <span class="math notranslate nohighlight">\(n\)</span> 次加法。总共执行 <span class="math notranslate nohighlight">\(2m+2n\)</span> 次加法，时间复杂度 <span class="math notranslate nohighlight">\(O(m+n)\)</span>。</p>
<p>下面是这个一维线性差分的示例程序，请运行测试一下并看懂整个程序。注意这个程序里数据从数组0号元素开始存放，注意原地做前缀和处理的代码。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1000</span><span class="p">],</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>		<span class="c1">// n: 输入数据总量</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>		<span class="c1">// m: 区间修改的次数</span>
	<span class="c1">// 循环读入每次修改的左右端点和改变量，记录改变点</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="n">diff</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">diff</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 原地完成diff差分数组的前缀和处理</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

	<span class="c1">// 用差分数组对位完成数据修改</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="c1">// 输出结果</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%4d&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>实际编程进行差分时，往往会在把数组的长度开大一些，在实际的尾项之后再虚拟一个等于0的项。这样，在遇到差分区间的右端点R为实际的尾项时，程序可以不必要进行额外的判断，而是像通常那样在R+1项上设置差分结束标志，程序代码因此会简洁很多。</p>
<p>类比一下可以发现，这个小技巧其实与处理前缀和时用的那个小技巧是异曲同工的，即在实际的首项前面留出一个虚拟的等于0的0号项，从而使得程序中不必担心数组下标越界。</p>
<p>当然了，要不要使用这样的技巧对程序的结果是不会有影响的，你完全可以选择不用，但是我们的建议是：用！有时候为了方便，甚至可以前后都增设一个虚拟的项！</p>
</div>
<div class="admonition- admonition">
<p class="admonition-title">思考</p>
<p>学会一维线性差分了，你能不能把它拓展到矩阵的多次子区域修改呢？也就是说拓展为二维差分算法。在继续到下一节之前请务必先思考并尝试一下。</p>
</div>
</div>
<div class="section" id="id2">
<h2><span class="section-number">3.2.5.2. </span>二维差分（洛谷P3397）<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>学会了一维线性差分后，要把这种技巧推广到二维区域的差分上就很方便了。我们只需要把m×n的二维区域视为由m个长度为n的一维区域由上至下铺设而成的就可以了。在它的一个左上角为 <span class="math notranslate nohighlight">\((r_1,c_1)\)</span>，右下角为 <span class="math notranslate nohighlight">\((r_2,c_2)\)</span> 的长方形子区域内做整体增减处理，增减量为 <span class="math notranslate nohighlight">\(d\)</span>。这只不过是在从第 <span class="math notranslate nohighlight">\(r_1\)</span> 行到第 <span class="math notranslate nohighlight">\(r_2\)</span> 行这几个一维数列上做相同的一维线性差分而已，差分区间为 <span class="math notranslate nohighlight">\([c_1,c_2]\)</span>，差值为 <span class="math notranslate nohighlight">\(d\)</span>。</p>
<p>例如我们有一块5×5的区域要做连续数次二维差分，它的差分表初始状态当然还是为全零：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0  0  0  0  0
0  0  0  0  0
0  0  0  0  0
0  0  0  0  0
0  0  0  0  0
</pre></div>
</div>
<p>现在要对第2行第3列到第4行第4列的区域做加2操作，那么我们就对第2行到第4行的三行分别都做一次一维线性差分，得到如下的差分表：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0  0  0  0  0
0  0  2  0 -2
0  0  2  0 -2
0  0  2  0 -2
0  0  0  0  0
</pre></div>
</div>
<p>再来一次从第1行第1列到第2行第4列的减1差分：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-1  0  0  0  1
-1  0  2  0 -1
 0  0  2  0 -2
 0  0  2  0 -2
 0  0  0  0  0
</pre></div>
</div>
<p>最后来一次从第4行第2列到第5行第5列的加3差分，这次由于差分的最后一列是末尾列，所以它的结尾处理就被忽略掉了：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-1  0  0  0  1
-1  0  2  0 -1
 0  0  2  0 -2
 0  3  2  0 -2
 0  3  0  0  0
</pre></div>
</div>
<p>为了得出在整个区域上做过二维差分之后的结果，我们对差分表的每一行做一次一维前缀和即可。比如上面这个经历了三次差分后的5×5区域，它最终的结果是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-1 -1 -1 -1  0
-1 -1  1  1  0
 0  0  2  2  0
 0  3  5  5  3
 0  3  3  3  3
</pre></div>
</div>
<p>非常简单，对不对？接下来我们看一个二维差分最典型的问题，地毯覆盖问题，大约是NOIP提高组Day2第一题的难度要求。</p>
<p id="index-1">地毯（洛谷P3397）</p>
<p><strong>题目描述</strong></p>
<p>在 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">n</span></code> 的格子上有 <code class="docutils literal notranslate"><span class="pre">m</span></code> 个地毯。</p>
<p>给出这些地毯的信息，问每个点被多少个地毯覆盖。</p>
<p><strong>输入格式</strong></p>
<p>第一行，两个正整数 <code class="docutils literal notranslate"><span class="pre">n、m</span></code>。意义如题所述。</p>
<p>接下来 <code class="docutils literal notranslate"><span class="pre">m</span></code> 行，每行两个坐标 <code class="docutils literal notranslate"><span class="pre">(x1,y1)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(x2,y2)</span></code>，代表一块地毯，左上角是 <code class="docutils literal notranslate"><span class="pre">(x1,y1)</span></code>，右下角是 <code class="docutils literal notranslate"><span class="pre">(x2,y2)</span></code>。</p>
<p><strong>输出格式</strong></p>
<p>输出 <code class="docutils literal notranslate"><span class="pre">n</span></code> 行，每行 <code class="docutils literal notranslate"><span class="pre">n</span></code> 个正整数。</p>
<p>第 <code class="docutils literal notranslate"><span class="pre">i</span></code> 行第 <code class="docutils literal notranslate"><span class="pre">j</span></code> 列的正整数表示 <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> 这个格子被多少个地毯覆盖。</p>
<p><strong>输入输出样例</strong></p>
<p>输入：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>5 3
2 2 3 3
3 3 5 5
1 2 1 4
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 1 1 1 0
0 1 1 0 0
0 1 2 1 1
0 0 1 1 1
0 0 1 1 1
</pre></div>
</div>
<p><strong>说明/提示</strong></p>
<p>【样例解释】</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 0 0 0 0         0 0 0 0 0        0 1 1 1 0
0 1 1 0 0         0 1 1 0 0        0 1 1 0 0
0 1 1 0 0    -&gt;   0 1 2 1 1   -&gt;   0 1 2 1 1
0 0 0 0 0         0 0 1 1 1        0 0 1 1 1
0 0 0 0 0         0 0 1 1 1        0 0 1 1 1
</pre></div>
</div>
<p>【数据范围】</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">20%</span></code> 的数据，有 <code class="docutils literal notranslate"><span class="pre">n&lt;=50，m&lt;=100</span></code>。</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">100%</span></code> 的数据，有 <code class="docutils literal notranslate"><span class="pre">n&lt;=1000，m&lt;=1000</span></code>。</p>
<p><strong>题意分析</strong></p>
<p>说实话这题基本上属于模板题，实在没有什么可分析的，就是一个单纯的二维差分，每次的差都是加一。唯一需要注意的是请在看题时千万看清楚，输入的坐标 <code class="docutils literal notranslate"><span class="pre">(x1,y1)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(x2,y2)</span></code>，是行号在前还是列号在前。在样例解释的第三步是可以看得出来的。</p>
<p>下面是AC代码。因为最大可能的数据量为1000行1000列，有可能超过局部变量的内存限制，为了方便起见所以采用了全局变量。另外，为了方便，数组的行列都多开了一些，从 <code class="docutils literal notranslate"><span class="pre">field[1][1]</span></code> 开始存放差分表。并且差分表的上下前后都留出了虚拟的全0行列，使得我们无论在做差分还是在做前缀和的时候都能够肆无忌惮，不需要额外的数组下标越界判断。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">field</span><span class="p">[</span><span class="mi">1010</span><span class="p">][</span><span class="mi">1010</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y2</span><span class="p">);</span>
		<span class="n">y2</span><span class="o">++</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">x2</span><span class="p">;</span> <span class="n">row</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">field</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">y1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="n">field</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span>
			<span class="n">field</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="n">field</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d%c&quot;</span><span class="p">,</span> <span class="n">field</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">],</span> <span class="n">col</span> <span class="o">==</span> <span class="n">n</span> <span class="o">?</span> <span class="sc">&#39;\n&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后看一下AC结果，可以看出来几个数据量大的测试点上，运行所花的时间还是比较长的，有超过100ms的测试点。可见如果不用差分法的技巧，解这类问题将会有多么可怕。</p>
<img alt="../../_images/225_p3397.png" src="../../_images/225_p3397.png" />
<div class="admonition- admonition">
<p class="admonition-title">练习</p>
<p>求多个整数取值范围中出现次数最多的整数。</p>
<p>给定多个整数取值范围 <span class="math notranslate nohighlight">\([L_i, R_i]\)</span>，找出在所有这些范围内出现次数最多的那个整数，如果这样的整数有多个的话就指其中最小的那个。例如：</p>
<blockquote>
<div><p>输入: L1 = 1, R1 = 4;</p>
<blockquote>
<div><p>L2 = 3, R2 = 5;</p>
<p>L3 = 4, R3 = 8;</p>
</div></blockquote>
<p>输出: 4</p>
<p>解释: 在给出的三个取值范围中，4一共出现了3次，每个范围里都有4，而其他整数都不到3次，所以答案是4。</p>
<p>输入: L1 = 1, R1 = 6;</p>
<blockquote>
<div><p>L2 = 3, R2 = 5;</p>
<p>L3 = 2, R3 = 8;</p>
</div></blockquote>
<p>输出: 3</p>
<p>解释: 在给出的三个取值范围中，3,4,5都一共出现了3次，同是出现次数最多的，按照题目要求取最小的那个，所以答案是3。</p>
</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="226_two_points.html" title="3.2.6. 尺取法（洛谷P1147）"
             >下一页</a> |</li>
        <li class="right" >
          <a href="224_prefix_sum.html" title="3.2.4. 前缀和"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../220_basic_online_algos.html" ><span class="section-number">3.2. </span>简单在线统计</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>