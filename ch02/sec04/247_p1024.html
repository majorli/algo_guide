
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.4.7. 一元三次方程求解（洛谷P1024） &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.4.8. 二分法例题：跳石头（洛谷P2678）" href="248_p2678.html" />
    <link rel="prev" title="3.4.6. 二分迭代法求方程根" href="246_cubic_root.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="248_p2678.html" title="3.4.8. 二分法例题：跳石头（洛谷P2678）"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="246_cubic_root.html" title="3.4.6. 二分迭代法求方程根"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../240_rec_bin.html" accesskey="U"><span class="section-number">3.4. </span>递归与二分</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.4.7. 一元三次方程求解（洛谷P1024）</a><ul>
<li><a class="reference internal" href="#index-0">3.4.7.1. 快速多项式算法</a></li>
<li><a class="reference internal" href="#id2">3.4.7.2. 多项式方程的根：奇穿偶不穿</a></li>
<li><a class="reference internal" href="#index-1">3.4.7.3. 洛谷P1024问题题解</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="246_cubic_root.html"
                        title="上一章"><span class="section-number">3.4.6. </span>二分迭代法求方程根</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="248_p2678.html"
                        title="下一章"><span class="section-number">3.4.8. </span>二分法例题：跳石头（洛谷P2678）</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec04/247_p1024.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="p1024">
<h1><span class="section-number">3.4.7. </span>一元三次方程求解（洛谷P1024）<a class="headerlink" href="#p1024" title="永久链接至标题">¶</a></h1>
<p>要完成洛谷P1024题“一元三次方程求解”，我们需要灵活应用二分迭代法，利用题目中给出的额外条件设计出合理的迭代过程。另外我们还需要学习一些和多项式有关的预备知识</p>
<div class="section" id="index-0">
<span id="id1"></span><h2><span class="section-number">3.4.7.1. </span>快速多项式算法<a class="headerlink" href="#index-0" title="永久链接至标题">¶</a></h2>
<p>一个n阶多项式在数学上的定义为这样一个式子：<span class="math notranslate nohighlight">\(P(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n\)</span>。现在给定任意实数 <span class="math notranslate nohighlight">\(x\)</span>，要计算这个多项式的值。最简单的蛮力计算法为了计算出每一项 <span class="math notranslate nohighlight">\(a_1x,a_2x^2,\dots,a_nx^n\)</span>，共需要做 <span class="math notranslate nohighlight">\(1+2+\cdots+n\)</span> 次乘法，这显然是 <span class="math notranslate nohighlight">\(O(n^2)\)</span> 时间的。我们现在已经很有经验了，一看就知道这个方法不好，因为重复计算非常的多。</p>
<p>第二种方法可以这样，我们先建立一个长度为n的数组，然后从头到尾分别计算和存放 <span class="math notranslate nohighlight">\(x,x^2,\dots,x^n\)</span> 的值，这个计算过程中后一个值可以用前一个值乘上 <span class="math notranslate nohighlight">\(x\)</span> 来得到（有点类似计算前缀和，或许我们可以给它取个名字叫前缀积），一共需要n-1次乘法，然后再各自乘上自己对应的系数，这样整个计算过程需要进行2n-1次乘法。这就快了许多，但是还不够快！而且增加了空间使用，所以还不是我们真正要学习掌握的最好算法。</p>
<p>那么最好的算法怎么来计算多项式呢？我们先来看具体的例子，再来归纳出一个一般的算法。</p>
<p>零阶多项式，也就是常数多项式 <span class="math notranslate nohighlight">\(P(x)=a_0\)</span>，这个不需要计算。</p>
<p>一阶多项式 <span class="math notranslate nohighlight">\(P(x)=a_0+a_1x\)</span>，这个没法简化。按照常规，先计算 <span class="math notranslate nohighlight">\(a_1x\)</span>，然后加上常数项系数 <span class="math notranslate nohighlight">\(a_0\)</span> 即可，一共需要进行1次乘法。</p>
<p>二阶多项式 <span class="math notranslate nohighlight">\(P(x)=a_0+a_1x+a_2x^2\)</span>，我们可以先在后面两项中提出一个 <span class="math notranslate nohighlight">\(x\)</span>，整理成 <span class="math notranslate nohighlight">\(P(x)=a_0+x(a_1+a_2x)\)</span>。现在我们可以先计算括号中的值 <span class="math notranslate nohighlight">\(P_1=a_1+a_2x\)</span>，这是一个一阶多项式。接下来原式就变成了 <span class="math notranslate nohighlight">\(P(x)=a_0+P_1x\)</span>，这还是一个一阶多项式。通过这种方法，我们用2次乘法就完成了二阶多项式的求值。</p>
<p>同理，三阶多项式也可以分解成3个一阶多项式的求值：</p>
<div class="math notranslate nohighlight">
\[P(x)=a_0+a_1x+a_2x^2+a_3x^3=a_0+(a_1+a_2x+a_3x^2)x=a_0+(a_1+(a_2+a_3x)x)x\]</div>
<p>用这个方法，我们可以把任何一个n阶多项式 <span class="math notranslate nohighlight">\(P(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n\)</span> 分解成n个一阶多项式的求值：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
P_1 &amp;= a_{n-1}+a_nx\\
P_2 &amp;= a_{n-2}+P_1x\\
       &amp;\vdots\\
P_n &amp;= a_0+P_{n-1}x\\
P(x)   &amp;= P_n
\end{align}\end{split}\]</div>
<p>整个计算过程只需要n次乘法，这是目前最快的实数多项式求值算法，可以描述成下面这样的算法框架：</p>
<div class="admonition- admonition">
<p class="admonition-title">快速多项式求值算法</p>
<p><span class="math notranslate nohighlight">\(\text{Polynomial}(a_0,a_1,\cdots,a_n,x):\)</span></p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(P\leftarrow a_n\)</span></p>
<p><span class="math notranslate nohighlight">\(\text{FOR  } i \leftarrow n-1 \text{  TO  } 0 \text{  DO}\)</span></p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(P \leftarrow a_i + P\cdot x\)</span></p>
</div></blockquote>
<p><span class="math notranslate nohighlight">\(\text{RETURN  }P\)</span></p>
</div></blockquote>
</div>
<p>在本节后面的程序代码中我们讲看到用这个算法计算三阶多项式的C++函数。</p>
</div>
<div class="section" id="id2">
<h2><span class="section-number">3.4.7.2. </span>多项式方程的根：奇穿偶不穿<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>接下来我们要了解多项式方程 <span class="math notranslate nohighlight">\(P(x)=0\)</span> 的根的性质。这部分为高中数学内容，初中阶段属于数学竞赛知识，若看不懂无需强求，可以跳过。如果能有所了解，记住结论就更好了。</p>
<p>设 <span class="math notranslate nohighlight">\(P(x)\)</span> 为任意n阶多项式，根据代数定理，它对应的多项式方程 <span class="math notranslate nohighlight">\(P(x)=0\)</span>，通常称为一元n次方程的，可能有0到n个不同的实数根。也就是说，它可以无解也可以有解，如果有解，它可能只有1个实根，也可能有2个不同的实根，……，最多可以有n个不同的实根，都有可能。</p>
<p>假设我们可以把方程通过多项式因式分解变形成下面这样的形式：</p>
<div class="math notranslate nohighlight">
\[P(x)=(x-x_1)^{m_1}(x-x_2)^{m_2}\cdots(x-x_k)^{m_k}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(1\le k \le n\)</span>，<span class="math notranslate nohighlight">\(x_1,x_2,\dots,x_k\)</span> 是 <span class="math notranslate nohighlight">\(k\)</span> 个互不相等的常数，<span class="math notranslate nohighlight">\(m_1,m_2,\dots,m_k\ge1\)</span> 且满足 <span class="math notranslate nohighlight">\(m_1+m_2+\cdots+m_k=n\)</span>。</p>
<p>这样，这个方程就有 <span class="math notranslate nohighlight">\(k\)</span> 个不同的实根 <span class="math notranslate nohighlight">\(x_1,x_2,\dots,x_k\)</span>。整数 <span class="math notranslate nohighlight">\(m_1,m_2\dots,m_k\)</span> 称为对应的根的<strong>重数</strong>，根 <span class="math notranslate nohighlight">\(x_i\)</span> 称为方程的一个 <span class="math notranslate nohighlight">\(m_i\)</span> 重根，其中重数为1的根称为<strong>单根</strong>，重数大于1的称为<strong>重根</strong>。</p>
<p>例如：方程 <span class="math notranslate nohighlight">\(x^2-4x+3=0\)</span> 有两个根 <span class="math notranslate nohighlight">\(x_1=1\)</span> 和 <span class="math notranslate nohighlight">\(x_2=3\)</span>，这个方程可以变形成 <span class="math notranslate nohighlight">\((x-1)(x-3)=0\)</span>，所以 <span class="math notranslate nohighlight">\(x_1\)</span> 和 <span class="math notranslate nohighlight">\(x_2\)</span> 都是方程的单根。方程 <span class="math notranslate nohighlight">\(x^2-2x+1=0\)</span>，经过整理可以变形为 <span class="math notranslate nohighlight">\((x-1)^2=0\)</span>，它只有一个2重根 <span class="math notranslate nohighlight">\(x_{1,2}=2\)</span>。</p>
<p>再如：方程 <span class="math notranslate nohighlight">\(x^3-6x^2+11x-6=0\)</span> 可以因式分解成 <span class="math notranslate nohighlight">\((x-1)(x-2)(x-3)=0\)</span>，它有三个单根 <span class="math notranslate nohighlight">\(x_1=1,x_2=2,x_3=3\)</span>。方程 <span class="math notranslate nohighlight">\((x-1)^2(x-3)=0\)</span> 有一个单根 <span class="math notranslate nohighlight">\(x_1=3\)</span> 和一个2重根 <span class="math notranslate nohighlight">\(x_{2,3}=1\)</span>。而方程 <span class="math notranslate nohighlight">\((x+2)^3=0\)</span> 则只有一个3重根 <span class="math notranslate nohighlight">\(x_{1,2,3}=-2\)</span>。</p>
<div class="admonition- admonition">
<p class="admonition-title">补充</p>
<p>事实上，并不是所有多项式都可以因式分解成上面这样完美的形式的，比如 <span class="math notranslate nohighlight">\(x^3+8\)</span> 在实数域内就只能分解成 <span class="math notranslate nohighlight">\((x+2)(x^2-2x+4)\)</span>。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>这里牵涉到一个特别容易被误解的概念：重根，即重数大于1的根。在代数学上，一个m重根并不是一个根，而是m个根，只不过这m个根的数值相等！这一基本概念一定要记住，非常重要。</p>
</div>
<div class="admonition- admonition">
<p class="admonition-title">补充之后的补充</p>
<p>有人可能听说过“代数学基本定理”这个东西，代数学这一条特别特别重要的基本定理说：一元n次方程一定恰好有n个根，其中重根按重数计为多个根。</p>
<p>那么无解的方程，比如 <span class="math notranslate nohighlight">\(x^2+2=0\)</span> 怎么算？那些不能完美因式分解的方程又要怎么算？比如刚才提到过，<span class="math notranslate nohighlight">\(x^3+8=0\)</span> 就只能因式分解为 <span class="math notranslate nohighlight">\((x+2)(x^2-2x+4)=0\)</span>，似乎只有一个单根 <span class="math notranslate nohighlight">\(x_1=-2\)</span>。事实上，我们前面一直在描述的都是针对<strong>实数根</strong>而言的，初中所学的实数并不是数的全部，在实数以外还有<strong>虚数</strong>，实数和虚数还能组合成<strong>复数</strong>。代数学基本定理所说的恰有n个根是指一定恰好有n个复数根。</p>
</div>
<p>接下来是我们真正要关心的问题：一元n次方程 <span class="math notranslate nohighlight">\(P(x)=0\)</span> 的实根，能不能用二分迭代法求解？</p>
<p>根据前面一节的介绍，一个方程的根能不能使用二分迭代法求解，有“范围”、“连续”、“单调”三个条件。其中求解的取值范围这个条件，一般是作为条件在问题中明确给出的，或是不言而喻的。而多项式函数 <span class="math notranslate nohighlight">\(y=P(x)\)</span> 经过一些高等玄学的证明，也早已知道了在实数域内都是连续的。问题的关键在于单调性条件，严格地说，在包含一个根的某个前后相邻区间内，函数 <span class="math notranslate nohighlight">\(y=P(x)\)</span> 是否单调？这种某个数 <span class="math notranslate nohighlight">\(x_0\)</span> 的前后相邻区间，数学上叫做 <span class="math notranslate nohighlight">\(x_0\)</span> 的<strong>邻域</strong>，指区间 <span class="math notranslate nohighlight">\([x_0-\delta,x_0+\delta]\)</span>。<span class="math notranslate nohighlight">\(\delta\)</span> 是一个任意的正实数，称为邻域的<strong>宽度</strong>。很不幸的是，这里确实存在某些根在它的任何邻域里函数 <span class="math notranslate nohighlight">\(y=P(x)\)</span> 都不单调的情况。情况一共有两种：</p>
<p>有些根 <span class="math notranslate nohighlight">\(x_i\)</span>，总能找到一个正数 <span class="math notranslate nohighlight">\(d\)</span>，使得在它的任何宽度小于 <span class="math notranslate nohighlight">\(d\)</span> 的邻域内函数 <span class="math notranslate nohighlight">\(y=P(x)\)</span> 都是单调的。不失一般性，我们假设函数单调递增。那么对于任意正数 <span class="math notranslate nohighlight">\(\delta\)</span>，只要 <span class="math notranslate nohighlight">\(\delta\le d\)</span>，就都满足 <span class="math notranslate nohighlight">\(P(x_i-\delta)\lt P(x_i)=0\)</span> 和 <span class="math notranslate nohighlight">\(P(x_i+\delta)\gt P(x_i)=0\)</span>，所以函数的图像在这个根附近就是“穿 <span class="math notranslate nohighlight">\(x\)</span> 轴而过”的。同时我们知道，只要确定能确定任何一个小于等于 <span class="math notranslate nohighlight">\(d\)</span> 的宽度，就可以把这个宽度的邻域作为求值范围来进行二分迭代求解。</p>
<p>另一种不太友好的情况就是，某些根 <span class="math notranslate nohighlight">\(x_j\)</span>，在其任何一个邻域内函数 <span class="math notranslate nohighlight">\(y=P(x)\)</span> 都不单调，此时函数图像在这个根处和 <span class="math notranslate nohighlight">\(x\)</span> 轴相切，而不是穿过，如下图：</p>
<img alt="../../_images/247_p1024.png" src="../../_images/247_p1024.png" />
<p>例如 <span class="math notranslate nohighlight">\(y=x^2\)</span> 的图像就在 <span class="math notranslate nohighlight">\(x=0\)</span> 处和 <span class="math notranslate nohighlight">\(x\)</span> 轴相切。这种根就没法用二分迭代法来求解。</p>
<p>那么怎么判断一个根是穿过 <span class="math notranslate nohighlight">\(x\)</span> 轴的那种呢还是与之相切的那种？经过一些现在可以忽略不谈的玄学分析，我们有以下结论：凡是重数为偶数的重根都是和 <span class="math notranslate nohighlight">\(x\)</span> 轴相切的根，单根和重数为奇数的根则都是穿 <span class="math notranslate nohighlight">\(x\)</span> 轴而过的那种根。</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>这在高中数学里是一个必备知识，有一个很好记的别名，叫做<strong>“奇穿偶不穿”</strong>。</p>
</div>
<p>另外，从上面这个结论我们又可以得到一个重要的推论：<em>如果一元n次方程恰有n个不同的实根，那么所有这些实根在其邻域内多项式函数都是单调的，可以用二分迭代法求解。</em></p>
<p>接下来，我们就可以开始做题了。</p>
</div>
<div class="section" id="index-1">
<span id="id3"></span><h2><span class="section-number">3.4.7.3. </span>洛谷P1024问题题解<a class="headerlink" href="#index-1" title="永久链接至标题">¶</a></h2>
<p><strong>题目描述</strong></p>
<p>有形如：<span class="math notranslate nohighlight">\(ax^3+bx^2+cx^1+dx^0=0\)</span> 这样的一个一元三次方程。给出该方程中各项的系数( <span class="math notranslate nohighlight">\(a,b,c,d\)</span> 均为实数)，并约定该方程存在三个不同实根(根的范围在 <span class="math notranslate nohighlight">\(-100\)</span> 至 <span class="math notranslate nohighlight">\(100\)</span> 之间)，且根与根之差的绝对值 <span class="math notranslate nohighlight">\(\ge 1\)</span>。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 <span class="math notranslate nohighlight">\(2\)</span> 位。</p>
<p>提示：记方程 <span class="math notranslate nohighlight">\(f(x)=0\)</span>，若存在 <span class="math notranslate nohighlight">\(2\)</span> 个数 <span class="math notranslate nohighlight">\(x_1\lt x_2\)</span> 使得 <span class="math notranslate nohighlight">\(f(x_1) \cdot f(x_2)&lt;0\)</span>，则在 <span class="math notranslate nohighlight">\((x_1,x_2)\)</span> 之间一定有一个根。</p>
<p><strong>输入格式</strong></p>
<p>一行，<span class="math notranslate nohighlight">\(4\)</span> 个实数 <span class="math notranslate nohighlight">\(A,B,C,D\)</span>。</p>
<p><strong>输出格式</strong></p>
<p>一行，<span class="math notranslate nohighlight">\(3\)</span> 个实根，并精确到小数点后 <span class="math notranslate nohighlight">\(2\)</span> 位。</p>
<p><strong>输入输出样例</strong></p>
<p>输入：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1 -5 -4 20
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-2.00 2.00 5.00
</pre></div>
</div>
<p><strong>题目解析</strong></p>
<p>这是一个典型的二分迭代法求根问题。题目已经明确了要求的是一元三次方程，而且保证了有3个不同的实根。根据前面的预备知识，这三个根都是单根，都是穿 <span class="math notranslate nohighlight">\(x\)</span> 轴的可以二分迭代求解的根。</p>
<p>但是题目没有明确给出每一个根附近的单调邻域，只是给了一个大的范围，三个根都在区间[-100,100]上。可是即然要二分迭代，那么单调的求根范围是必须要有的。经过仔细看题，我们发现有这样一个条件：根与根之差的绝对值 <span class="math notranslate nohighlight">\(\ge 1\)</span>。那么在任何一个长度为1的闭区间里，根的分布一共有四种情况：</p>
<ol class="arabic simple">
<li><p>如果左端点为一个根，那么唯一有可能右端点还是一个根，这样就在左右端点处各有一个根，共2个根；</p></li>
<li><p>左端点或右端点，某一个端点处有一个根；</p></li>
<li><p>左右端点都不是根，但是二者的函数值异号，那么在区间内部必有一个根；</p></li>
<li><p>左右端点都不是根，且二者的函数值同号，那么整个区间上无根。</p></li>
</ol>
<p>这就好办了。我们可以把整个[-100,100]区间划分为200个长度为1的小区间：[-100,-99], [-99,-98], … ,[99,100]，然后从左到右逐一地分析它们的情况，如果有根就求出来并记录下来。整个过程在三个根全部求出的时候就可以结束了。</p>
<p>对于任意一个小区间[m,m+1]，我们进行下面的分析：</p>
<ol class="arabic simple">
<li><p>如果左端点是一个根，那么记录下这个根，并进入下一轮循环。因为如果左端点为根，那么下一个根至少是本区间右端点，但是本区间右端点可以交给下一个区间作为它的左端点去处理，所以此处可以直接进入下一轮循环。但要注意这里有一个小漏洞，至于是什么小漏洞我们留到程序里再说明，请在看到最后的程序之前自己先思考一下是个什么漏洞。</p></li>
<li><p>如果左端点不是根，那么判断右端点。如果右端点是根，记录下之后，将循环跳到下下个区间。因为如果本区间的右端点是根，那么下一个根至少是下一个区间的右端点，也就是下下个区间的左端点，所以可以直接跳过下一个区间而进入下下个区间。</p></li>
<li><p>如果两个端点处都不是根，那么按二分迭代法的标准做法，先判断区间内有无根存在（同时可以完成增减性判断），若有根则二分迭代求出来。</p></li>
</ol>
<p>好了，下面是就是代码了。对了，你知道前面所说的那个小漏洞是什么了吗？你知道该怎样补上这个漏洞吗？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="k">const</span> <span class="kt">double</span> <span class="n">EPS</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">ACC</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_zero</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">EPS</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">EPS</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">double</span> <span class="nf">poly</span><span class="p">(</span><span class="kt">double</span> <span class="n">e</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

<span class="kt">double</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">double</span> <span class="n">e</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">left</span><span class="p">,</span> <span class="kt">double</span> <span class="n">right</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inc</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf %lf %lf %lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="kt">double</span> <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="c1">// 三个解</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// 已经获得的解个数</span>
	<span class="kt">double</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">,</span> <span class="n">rvalue</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="n">inc</span><span class="p">;</span>	<span class="c1">// 是否递增</span>
	<span class="c1">// 共有200个长度为1的子区间，分别为[-100,-99], ..., [99,100]</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
		<span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">lvalue</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_zero</span><span class="p">(</span><span class="n">lvalue</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 左端点是一个解</span>
			<span class="n">s</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>	<span class="c1">// 记录解</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// 已找到3个解，直接退出求解过程</span>
			<span class="c1">// 若左端点是一个解，那么下一个解至少是右端点</span>
			<span class="c1">// 但是右端点是下一个区间的左端点，所以可以直接</span>
			<span class="c1">// 跳转到下一轮循环去，在下一轮循环中会先检查这</span>
			<span class="c1">// 个点的，本轮循环就不用管了</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// 现在已经排除了左端点为解的情况，再来判断右端点</span>
		<span class="n">rvalue</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_zero</span><span class="p">(</span><span class="n">rvalue</span><span class="p">))</span> <span class="p">{</span>	<span class="c1">// 右端点是一个解</span>
			<span class="n">s</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>	<span class="c1">// 记录解</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// 已找到3个解，直接退出求解过程</span>
			<span class="c1">// 若右端点是一个解，那么下一个可能的解至少是</span>
			<span class="c1">// 下一个区间的右端点，也是下下个区间的左端点</span>
			<span class="c1">// 所以可以直接跳过下一个区间，进入下下轮</span>
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// 现在已经排除了两个端点处是解的情况，可以进行本区间有无解了</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lvalue</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rvalue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">inc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>	<span class="c1">// 本区间递增，有一解</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lvalue</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rvalue</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">inc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>	<span class="c1">// 本区间递减，有一解</span>
		<span class="k">else</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="c1">// 左右端点值同号，本区间内无解</span>
		<span class="c1">// 现在可以确定本区间内有一个根了，调用二分迭代法求根</span>
		<span class="n">s</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">inc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 上述算法过程在一种特殊条件下会遗漏一个根：</span>
	<span class="c1">// 如果最后两个根是99.0和100.0，最后一个区间[99,100]会在判断到左端点是</span>
	<span class="c1">// 一个根后就continue，然后整个算法过程结束，最后一个根100.0会被遗漏。</span>
	<span class="c1">// 会遗漏最后一个根的唯有这一种情况，被遗漏的根必是100.0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">100.0</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2lf %.2lf %.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 要计算的多项式可以进行如下变形：</span>
<span class="cm"> * P(x) = e[0] + e[1] * x + e[2] * x^2 + e[3] * x^3</span>
<span class="cm"> *      = e[0] + x * (e[1] + e[2] * x + e[3] * x^2)</span>
<span class="cm"> *      = e[0] + x * (e[1] + x * (e[2] + e[3] * x))</span>
<span class="cm"> * 所以，我们可以这样来进行循环计算：</span>
<span class="cm"> * P_0(x) = e[3]</span>
<span class="cm"> * P_1(x) = e[2] + P_0(x) * x</span>
<span class="cm"> * P_2(x) = e[1] + P_1(x) * x</span>
<span class="cm"> * P_3(x) = e[0] + P_2(x) * x</span>
<span class="cm"> * 最后得到的 P(x) = P_3(x)，只需要进行3次乘法</span>
<span class="cm"> * 注意：题目中的参数 a, b, c, d 对应的是 e[3], e[2], e[1], e[0]</span>
<span class="cm"> */</span>
<span class="kt">double</span> <span class="nf">poly</span><span class="p">(</span><span class="kt">double</span> <span class="n">e</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 标准的二分迭代法求根</span>
<span class="kt">double</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">double</span> <span class="n">e</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">left</span><span class="p">,</span> <span class="kt">double</span> <span class="n">right</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">mid</span><span class="p">,</span> <span class="n">mvalue</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">ACC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
		<span class="n">mvalue</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_zero</span><span class="p">(</span><span class="n">mvalue</span><span class="p">))</span> <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mvalue</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">inc</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">mvalue</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">inc</span><span class="p">))</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在，你看懂这个漏洞是怎么回事了吗？你能不能给出另一种修补的方法呢？有一种一句语句都不需要增加，只是对现有某一句语句进行小小的修改的方法，你能想出来吗？</p>
<p>Anyway，就算不弥补这个小漏洞，洛谷的四个测试点里也没有安排类似 <span class="math notranslate nohighlight">\(x^3-199x^2+9900x=0\)</span> 这样的恶心数据。但是洛谷的测试数据简单并不代表我们不需要追求完美，没有漏洞应该是每一个编程人的终极追求。</p>
<p>最后看看AC截图，我们利用了线性时间的快速多项式求值算法之后，这个程序的运行速度是非常快的。</p>
<img alt="../../_images/247_p1024_ac.png" src="../../_images/247_p1024_ac.png" />
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="248_p2678.html" title="3.4.8. 二分法例题：跳石头（洛谷P2678）"
             >下一页</a> |</li>
        <li class="right" >
          <a href="246_cubic_root.html" title="3.4.6. 二分迭代法求方程根"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../240_rec_bin.html" ><span class="section-number">3.4. </span>递归与二分</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>