
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.4.9. 二分法例题：切绳子（洛谷P1577） &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.4.10. 中位数问题" href="24A_median.html" />
    <link rel="prev" title="3.4.8. 二分法例题：跳石头（洛谷P2678）" href="248_p2678.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="24A_median.html" title="3.4.10. 中位数问题"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="248_p2678.html" title="3.4.8. 二分法例题：跳石头（洛谷P2678）"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../240_rec_bin.html" accesskey="U"><span class="section-number">3.4. </span>递归与二分</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>上一个主题</h4>
  <p class="topless"><a href="248_p2678.html"
                        title="上一章"><span class="section-number">3.4.8. </span>二分法例题：跳石头（洛谷P2678）</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="24A_median.html"
                        title="下一章"><span class="section-number">3.4.10. </span>中位数问题</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec04/249_p1577.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="p1577">
<span id="index-0"></span><h1><span class="section-number">3.4.9. </span>二分法例题：切绳子（洛谷P1577）<a class="headerlink" href="#p1577" title="永久链接至标题">¶</a></h1>
<p><strong>题目描述</strong></p>
<p>有 <span class="math notranslate nohighlight">\(N\)</span> 条绳子，它们的长度分别为 <span class="math notranslate nohighlight">\(L_i\)</span>。如果从它们中切割出 <span class="math notranslate nohighlight">\(K\)</span> 条长度相同的绳子，这 <span class="math notranslate nohighlight">\(K\)</span> 条绳子每条最长能有多长？答案保留到小数点后2位(直接舍掉2位后的小数)。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数 <span class="math notranslate nohighlight">\(N\)</span> 和 <span class="math notranslate nohighlight">\(K\)</span>，接下来 <span class="math notranslate nohighlight">\(N\)</span> 行，描述了每条绳子的长度 <span class="math notranslate nohighlight">\(L_i\)</span>。</p>
<p><strong>输出格式</strong></p>
<p>切割后每条绳子的最大长度。</p>
<p><strong>输入输出样例</strong></p>
<p>输入：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>4 11
8.02
7.43
4.57
5.39
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2.00
</pre></div>
</div>
<p><strong>说明/提示</strong></p>
<p>对于 <span class="math notranslate nohighlight">\(100\%\)</span> 的数据：<span class="math notranslate nohighlight">\(0\lt L_i \le 100000.00, 0\lt n\le10000, 0\lt k\le10000\)</span></p>
<p><strong>题目解析</strong></p>
<p>这又是一个经典的二分法问题，虽然和前一节的跳石头问题表面上看起来很不同，但是通过分析我们可以发现它们俩的本质惊人的相似。</p>
<p>这个题目有一个设定很反常，它用小数来表示绳子的长度。如果真的长度可以是任意的小数，那就很麻烦了，因为实数是稠密的无法穷举的，而计算机浮点数又是不精确的。幸亏题目描述里讲了，答案保留小数点后2位，更关键的是括号里的说明：直接舍掉2位后的小数！这就意味着，如果把绳子长度乘以100再强制类型转换为整数，是不会造成误差的。因为输入的绳子长度最多就是2位小数。另外，按照C++的整数运算规则，不能整除时直接舍弃小数部分，这不正是题目里说的直接舍弃2位后的小数吗？所以本题看上去是一个基于小数运算的问题，实质上还是一个基于整数的算法。</p>
<p>根据题目给出的数据范围，长度最多为100,000.00，乘100之后是10<sup>7</sup>。所以我们完全可以用一个 <code class="docutils literal notranslate"><span class="pre">int</span></code> 型数组来存放这些数据。在读数时，先将数据读入到一个 <code class="docutils literal notranslate"><span class="pre">double</span></code> 型临时变量 <code class="docutils literal notranslate"><span class="pre">temp</span></code> 中，然后赋值 <code class="docutils literal notranslate"><span class="pre">(int)(temp</span> <span class="pre">*</span> <span class="pre">100)</span></code> 给对应的数组元素就可以了。整个算法就使用整数进行处理，得到的结果也是整数，输出时只要除回100.0以变回浮点数，输出格式保留2位小数就可以了。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>要知道算法题真的很少很少会需要处理小数的，就算有，我们也都会想尽一切方法来转换成等价的整数处理。所以在遇到数据涉及小数的题目时，首先要想一下能不能改成用整数，当然前提是不会带来误差而且不会让算法复杂度大幅度增加。</p>
</div>
<p>搞定了没人喜欢的小数之后，问题就更容易分析了，接下来的分析我们就都使用转换过的整数了。</p>
<p>首先，本题的解是一个长度值，是一个整数，很显然它的取值范围为 <span class="math notranslate nohighlight">\(1\)</span> 到 <span class="math notranslate nohighlight">\(M=\max_i\{L_i\}\)</span>，即所有绳子长度中的最大值。整数是天然有良序的，所以我们可以进一步分析是不是可以使用二分法来求解。</p>
<p>如果给出任意一个候选解 <span class="math notranslate nohighlight">\(m\in[1,M]\)</span>，能不能找到一种方法来判断它和真正的解之间的顺序关系呢？我们可以尝试去切割长度为 <span class="math notranslate nohighlight">\(m\)</span> 的绳子，看看能切得多少段，这个段数就是候选解的判断依据。模拟切割的过程非常简单，用每一根绳子的长度去除 <span class="math notranslate nohighlight">\(m\)</span>，把得到的商累加起来就是了。如果能切割得到比 <span class="math notranslate nohighlight">\(K\)</span> 段更多的绳子，说明这个候选解 <span class="math notranslate nohighlight">\(m\)</span> 小了，我们下一步可以尝试切割更长的长度。如果得到的绳子段数比 <span class="math notranslate nohighlight">\(K\)</span> 小，则说明候选解大了，下一步应该尝试切割更短一点的长度。但是要小心，和跳石头问题类似，刚好等于 <span class="math notranslate nohighlight">\(K\)</span> 并不代表 <span class="math notranslate nohighlight">\(m\)</span> 就是真正的解。因为与 <span class="math notranslate nohighlight">\(m\)</span> 前后相邻的其他候选解也可能会切出相同的绳子段数来。</p>
<p>就拿题目的样例数据来说，乘以100转整型后四条绳子的长度分别为802、743、457和539。假如候选解 <span class="math notranslate nohighlight">\(m=350\)</span>，从四条绳子里分别可以切出2段、2段、1段和1段长度为350的绳子，总共可得6段。但是候选解如果是 <span class="math notranslate nohighlight">\(m=300\)</span>，结果也是可以切割出6段来。当然了，300和350之间的每一个候选解都可以切割出6段与之等长的绳子来。</p>
<p>因此和跳石头问题一样，本题候选解的判断依据（即可切割得到的绳子段数）也是有重复的，但可以确保所有判断依据相等的候选解都是连续地排在一起的，也就是说，候选解排好序之后，它们的判断依据值也是相应有序的。那么本题即然是要求可切得 <span class="math notranslate nohighlight">\(K\)</span> 条长度相同的绳子时的“最大”长度，显然如果候选解满足判断依据等于 <span class="math notranslate nohighlight">\(K\)</span> 时，我们应该进一步尝试比它更大的候选解，以便找到可能的最大长度。所以本题又是一个边界查找问题，同样是要找右边界的前一个位置，和跳石头问题一模一样。</p>
<p>然而本题和跳石头问题存在一个重要的不同点，其实在前面的分析过程中已经暴露了这个不同点。通过把候选解和它们的判断依据视作一个虚拟的数组我们可以清楚地看到这个差异。当然了，虚拟数组的下标 <span class="math notranslate nohighlight">\(m\)</span> 代表候选解，下标0的元素就当它不存在好了。数组元素 <span class="math notranslate nohighlight">\(q[m]\)</span> 就是 <span class="math notranslate nohighlight">\(m\)</span> 对应的判断依据，即切割长度为 <span class="math notranslate nohighlight">\(m\)</span> 的绳子能切得的段数。当我们去填写数组的第一个元素 <span class="math notranslate nohighlight">\(q[1]\)</span> 和最后一个元素 <span class="math notranslate nohighlight">\(q[M]\)</span> 时，我们就会发现，如果以所有绳子长度中的最大值 <span class="math notranslate nohighlight">\(M\)</span> 为长度去切割，那么长度为 <span class="math notranslate nohighlight">\(M\)</span> 的绳子原本有几条，能切割得到的绳子就有几条，最少可能只有一条；如果以长度 <span class="math notranslate nohighlight">\(1\)</span> 去切割，那么能切割得到的绳子数量等于所有绳子长度之总和 <span class="math notranslate nohighlight">\(L=L_1+L_2+\cdots+L_N\)</span>。数组大概会是下面这个样子：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  m:    0   1   2   3   4   5   6   7   8   9   ...   M
      +---+---+---+---+---+---+---+---+---+---+-----+---+
q[m]: |   | L | 9 | 9 | 9 | 8 | 8 | 8 | 8 | 7 | ... | 1 |
      +---+---+---+---+---+---+---+---+---+---+-----+---+
</pre></div>
</div>
<p>这个数组里元素值是按照逆序排列的！</p>
<p>再来回顾整理前面所述的尝试和判断规则，如果我们用二分法查找右边界，左右端点和中间点仍然沿用 <code class="docutils literal notranslate"><span class="pre">left、right、mid</span></code> 这三个变量名，查找规则如下：</p>
<ol class="arabic simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">q[mid]</span> <span class="pre">&gt;=</span> <span class="pre">K</span></code>，那么下一步应该查找后半段：<code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">=</span> <span class="pre">mid</span> <span class="pre">+</span> <span class="pre">1</span></code>。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">q[mid]</span> <span class="pre">&lt;</span> <span class="pre">K</span></code>，那么下一步应该查找前半段：<code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">=</span> <span class="pre">mid</span> <span class="pre">-</span> <span class="pre">1</span></code>。</p></li>
</ol>
<p>是不是和“通常”的右边界查找规则恰好反了？反了就对了，说明我们的分析过程和结论都是正确的，会和通常的规则恰好相反就是因为这次判断依据是逆序的。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>本题这样的判据逆序，如果只是在脑子里想，对于初学者来说还是挺烧脑的。试着去画一画判断依据的数组，填一下最小候选解和最大候选解的对应元素值，这往往会是一个帮助整理思路的好方法。</p>
</div>
<p>不管怎样，算法仍然是二分查找右边界，并返回右边界前一位置（<code class="docutils literal notranslate"><span class="pre">right</span></code>）。例如 <span class="math notranslate nohighlight">\(K=9\)</span>，那么解就是最后一个元素9的位置下标：4。所以返回的还是 <code class="docutils literal notranslate"><span class="pre">right</span></code>。</p>
<p>到此为止，应该已经可以写出正确的程序了吧？请在看下面的代码之前先自己动手试一试，然后对比下面的代码。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">len</span><span class="p">[</span><span class="mi">10010</span><span class="p">];</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
	<span class="kt">double</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
		<span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">temp</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>	<span class="c1">// 乘100变成整数</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 最长的绳子长度作为查找的终点</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>	<span class="c1">// 尝试切出的绳子长度为mid</span>
		<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// 计算能切出的绳子数量</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">num</span> <span class="o">+=</span> <span class="n">len</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">mid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>	<span class="c1">// 切成长度mid，切出来的数量少了，说明mid大了</span>
			<span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// 下一次尝试切得更短</span>
		<span class="k">else</span>		<span class="c1">// 切出的绳子数量大于等于k，还能尝试更长的长度</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">// 下一次尝试更长的长度</span>
	<span class="p">}</span>
	<span class="c1">// right指向的是要查找的解，left指向的是它的后一个位置，即右边界</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">right</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>AC截图：</p>
<img alt="../../_images/249_p1577.png" src="../../_images/249_p1577.png" />
<p>可以看出，速度非常快，二分法的特点就是速度快。这个程序使用的算法，主架构是一个二分边界查找，是 <span class="math notranslate nohighlight">\(O(\log M)\)</span> 的量级。在每一轮查找里，我们要对所有 <span class="math notranslate nohighlight">\(N\)</span> 条绳子进行切割，即一次整数除法，然后还要累加起来，这个是 <span class="math notranslate nohighlight">\(O(N)\)</span> 时间的。所以整个算法的工作量为 <span class="math notranslate nohighlight">\(O(N\log M)\)</span> 量级。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>很多人会误以为这是一个类似 <span class="math notranslate nohighlight">\(O(n\log n)\)</span> 时间的算法，比二阶算法快，比线性算法略慢。其实不然，它实际上是一个 <span class="math notranslate nohighlight">\(O(Nm)\)</span> 时间算法，严格说属于二阶时间复杂度。为什么？因为二分查找的右端点 <span class="math notranslate nohighlight">\(M\)</span> 不是一个“数据的数量”，而是一个“数据的值”，它的性质和“绳子的条数” <span class="math notranslate nohighlight">\(N\)</span> 是不同的。</p>
<p>数据规模是用于衡量算法时间复杂度的参数，按照真正的定义，这个参数应该是指数据在计算机中储存的长度，以二进制位（bit）为计量单位。</p>
<p>如果一个参数是“数据的数量”，比如这里的绳子条数 <span class="math notranslate nohighlight">\(N\)</span>，每一条绳子拥有一个长度数据，对应一个 <code class="docutils literal notranslate"><span class="pre">int</span></code> 变量，即32个bits，那么 <span class="math notranslate nohighlight">\(N\)</span> 代表的数据规模就是 <span class="math notranslate nohighlight">\(32N\)</span> 个bits。当它用做数据规模的参数来计算时间复杂度时，常数系数32可以忽略，所以 <span class="math notranslate nohighlight">\(O(32N)\)</span> 就是 <span class="math notranslate nohighlight">\(O(N)\)</span>。</p>
<p>如果一个参数是“数据的值”，比如这里的绳子最大长度 <span class="math notranslate nohighlight">\(M\)</span>，它是一个整数，假设其二进制数共有 <span class="math notranslate nohighlight">\(m\)</span> 位，则有 <span class="math notranslate nohighlight">\(2^m\le M\le 2^{m+1}-1\)</span>，所以 <span class="math notranslate nohighlight">\(O(M)\)</span> 实际上代表的是 <span class="math notranslate nohighlight">\(O(2^m)\)</span>，是指数型的！</p>
<p>因此，我们这个程序的算法时间复杂度 <span class="math notranslate nohighlight">\(O(N\log M)\)</span>，实际上是 <span class="math notranslate nohighlight">\(O(N\log 2^m)=O(Nm)\)</span>，是一个二阶算法。但是题目规定了绳子的最大长度乘100转整型后不会超过 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的取值范围，也就是说 <span class="math notranslate nohighlight">\(m\le31\)</span>，所以这个 <span class="math notranslate nohighlight">\(m\)</span> 很小，虽然是个二阶时间算法但实际上非常接近线性时间的。</p>
</div>
<p>最后留一个问题。在本题中，题目描述已经明确了绳子长度、绳子条数和要求切割得到的绳子段数都大于0，所以我们的二分查找左端点是从1开始的。还记得上一节的跳石头问题吗？那个题目就比较恶心，它保留了数据为0的可能性，使得算法的左端点要从0开始。</p>
<p>那么假如本题也改成有可能出现绳子为0条，或者所有绳子的长度都为0的情况呢？要怎么处理？这里把左端点也改成从0开始可以吗？请仔细地思考一下这个问题，并完成洛谷P2440“木材加工”。</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="24A_median.html" title="3.4.10. 中位数问题"
             >下一页</a> |</li>
        <li class="right" >
          <a href="248_p2678.html" title="3.4.8. 二分法例题：跳石头（洛谷P2678）"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../240_rec_bin.html" ><span class="section-number">3.4. </span>递归与二分</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>