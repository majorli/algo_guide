
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.4.10. 中位数问题 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.5. 基础排序算法" href="../250_sort_algos.html" />
    <link rel="prev" title="3.4.9. 二分法例题：切绳子（洛谷P1577）" href="249_p1577.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../250_sort_algos.html" title="3.5. 基础排序算法"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="249_p1577.html" title="3.4.9. 二分法例题：切绳子（洛谷P1577）"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../240_rec_bin.html" accesskey="U"><span class="section-number">3.4. </span>递归与二分</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.4.10. 中位数问题</a><ul>
<li><a class="reference internal" href="#a1-merge-ref">3.4.10.1. 归并法求两个有序数组的中位数</a></li>
<li><a class="reference internal" href="#id3">3.4.10.2. 二分法求两个有序数组的中位数</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="249_p1577.html"
                        title="上一章"><span class="section-number">3.4.9. </span>二分法例题：切绳子（洛谷P1577）</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="../250_sort_algos.html"
                        title="下一章"><span class="section-number">3.5. </span>基础排序算法</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec04/24A_median.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="index-0">
<span id="id1"></span><h1><span class="section-number">3.4.10. </span>中位数问题<a class="headerlink" href="#index-0" title="永久链接至标题">¶</a></h1>
<p><strong>中位数</strong>（median），又称<strong>中值</strong>，是一个重要的统计指标。它是将一组数据按顺序排列后居于中间位置的数，可将数据划分为个数相等的两部分，其中一个部分中所有数都大于等于中位数，另一个部分中所有数都小于等于中位数。对于有限的数集，如果其中有奇数个数，那么把所有数排序后正中间的那一个数的值就是中位数；如果有偶数个数，排序后最中间两个数的平均值是中位数。</p>
<div class="admonition- admonition">
<p class="admonition-title">示例</p>
<p>数列 [7,1,3,20,5] 的中位数是5。数列中比5小的数和比5大的数个数相等，都是2个。如果把这5个数排序后得到 [1,3,5,7,20]，可以发现5位于正中间的位置。</p>
<p>数列 [1,3,10,2] 的中位数是2和3的平均数2.5。数列中比2.5小的数和比2.5大的数都是2个。如果把数列排序为 [1,2,3,10]，就可以直观地看出2和3是最中间的两个数，所以中位数取它们的平均数。</p>
</div>
<p>简而言之，一个数列的中位数就是将其排序后，位于最中间位置的数值。对于这个数列而言，其中比中位数小的数和比中位数大的数应当是数量相等的。所以说中位数可以将数列中的数据划分为个数相等的两个部分，一个部分中所有数都大于等于中位数，另一个部分中所有数都小于等于中位数。</p>
<p>关于中位数，有一点概念必须澄清：<em>它是一个单独的数，而不是数列中的一个元素！</em></p>
<p>如果给出一组数值，求它的中位数是很简单的，只需要对数组进行排序，然后根据元素个数的奇偶性来进行计算即可。</p>
<p>C++提供了一个非常方便实用的快速排序函数 <code class="docutils literal notranslate"><span class="pre">std::sort()</span></code>，可以用来对数组中指定的一段元素进行排序。调用 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 函数，只需要提供数组中要排序的那一段元素的头尾指针即可。要使用这个函数，需引入 <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> 库并使用命名空间 <code class="docutils literal notranslate"><span class="pre">std</span></code>，下面是用法示例：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 读入100个元素</span>

<span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>      <span class="c1">// 对 a[0] 到 a[9] 之间的10个元素进行排序，注意含头不含尾的范围表示原则</span>
<span class="n">sort</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">40</span><span class="p">);</span> <span class="c1">// 对 a[20] 到 a[39] 之间的20个元素进行排序</span>
<span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">100</span><span class="p">);</span>     <span class="c1">// 对 a[0] 到 a[99]，即整个数组进行排序</span>
</pre></div>
</div>
<p>所以，假如有一个题目，要读入 <span class="math notranslate nohighlight">\(n\le1000\)</span> 个整数并求其中位数，那么程序将非常简单：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1001</span><span class="p">];</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>  <span class="c1">// 读数</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>  <span class="c1">// 排序</span>
        <span class="c1">// 根据 n 的奇偶性来计算中位数并输出，保留2位小数</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">?</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
<p>这个程序看懂了吗？看懂了我们就继续讨论一个更加复杂的问题。</p>
<p>现在有两个有序数组 <span class="math notranslate nohighlight">\(A\)</span> 和 <span class="math notranslate nohighlight">\(B\)</span>，各有 <span class="math notranslate nohighlight">\(m\)</span> 和 <span class="math notranslate nohighlight">\(n\)</span> 个元素，两个数组都已经完成升序排序，即元素从小到大排列。现在要求快速求出这两个数组中所有元素的中位数，时间复杂度不高于 <span class="math notranslate nohighlight">\(O\bigl(\log(m+n)\bigr)\)</span>。其中 <span class="math notranslate nohighlight">\(0\le m,n \le 10^6\)</span>，保证两个数组不会同时为空。</p>
<div class="section" id="a1-merge-ref">
<span id="id2"></span><h2><span class="section-number">3.4.10.1. </span>归并法求两个有序数组的中位数<a class="headerlink" href="#a1-merge-ref" title="永久链接至标题">¶</a></h2>
<p>如果两个数组都是乱序的，为了求出它们所有元素的中位数，我们可以把两个数组的元素都合到一个大数组里，然后对大数组进行排序来求出中位数。但排序算法最快的时间复杂度为 <span class="math notranslate nohighlight">\(O\bigl((n+m)\log(n+m)\bigr)\)</span>，远大于问题所要求的上限 <span class="math notranslate nohighlight">\(O\bigl(\log(n+m)\bigr)\)</span>。这个方法的主要问题出在没有利用两个原始数组都已经有序这个条件。</p>
<p>那么即然两个数组都已经排好序了，我们可以用一种叫做<strong>归并</strong>的操作把两个数组中的元素保持有序地合到另一个大数组里去，时间复杂度为线性的 <span class="math notranslate nohighlight">\(O(n+m)\)</span>。归并操作非常重要，在大量的算法问题中会用到，基本排序算法中最重要的<strong>归并排序</strong>也是基于归并来完成的，一定要熟练掌握。</p>
<p>归并的思路来源于整队。比如有两列队伍，都是按照身高从矮到高排列好的，现在要把两列队伍合并为一列，并且保持身高从矮到高排列。这个整队过程非常简单，从两列队伍各自排在队头的人开始，每次挑出两个队头中比较矮的那个人出列，排进新的队伍的尾部，如果队头两个人身高一样就任选其中一人即可。不断循环这一过程，直到某个队伍的人全部挑完，把另一个队伍中剩余的人按原顺序排到新队伍的后面就完成了。下面举个简单的例子来说明这个过程：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>初始状态：

队伍一: [1, 3]

队伍二: [2, 6, 7]

新队伍: []

第1步：队伍一的队头1较小，挑出来放到新队伍尾部

队伍一: 1, [3]

队伍二: [2, 6, 7]

新队伍: [1]

第2步：队伍二的队头2较小，挑出来放到新队伍尾部

队伍一: 1, [3]

队伍二: 2, [6, 7]

新队伍: [1, 2]

第3步：队伍一的队头3较小，挑出来放到新队伍尾部

队伍一: 1, 3, []

队伍二: 2, [6, 7]

新队伍: [1, 2, 3]

第4步：队伍一已空，把队伍二剩下的部分按原顺序放到新队伍尾部

队伍一: 1, 3, []

队伍二: 2, 6, 7, []

新队伍: [1, 2, 3, 6, 7]
</pre></div>
</div>
<p>按照这个方法，我们把两个数组读进来之后，可以归并到一个新的数组里去，然后在新数组里计算中位数即可。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000010</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1000010</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2000010</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">half</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="c1">// 计算出元素总数 m+n 的一半，由于C++整数除法向下取整，以及数组从0开始计数的特点</span>
	<span class="c1">// 当 m+n 为奇数时，half 恰好值向中间元素的位置，例如 (2+3)/2=2，c[2]恰好是第3个元素</span>
	<span class="c1">// 当 m+n 为偶数时，half-1 和 half 恰为最中间的两个位置，例如 (2+2)/2=2，c[1]和c[2]位于正中位置</span>
	<span class="n">half</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="c1">// 读入两个原数组 a 和 b</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="c1">// pa, pb: a 和 b 两个数组中还没有被归并部分的首位置；p: c 数组的尾部位置</span>
	<span class="kt">int</span> <span class="n">pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// 每次从 a 和 b 未归并部分的头部挑较小的那个数放到 c 的尾部，直到 a 或 b 中某一个数组被归并完</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">pb</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="p">]</span> <span class="o">?</span> <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="o">++</span><span class="p">];</span>
	<span class="c1">// 把剩余部分照搬到 c 的尾部完成归并</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="o">++</span><span class="p">];</span>	<span class="c1">// 如果 a 已经归并完了，这个循环不会进入</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pb</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="o">++</span><span class="p">];</span>	<span class="c1">// 同上，故两个循环只有一个会真正运行</span>
	<span class="c1">// 输出中位数</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">?</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">half</span><span class="p">]</span> <span class="o">:</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">half</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">half</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个算法思路很简单，程序很简洁，运行速度其实也挺快的，通常情况下这种方法就很好，推荐使用。但是归并算法有一个很大的问题是大量占用内存，因为它要把所有原数据都复制一份，所以空间复杂度高达 <span class="math notranslate nohighlight">\(O(m+n)\)</span>。</p>
<p>归并的时间复杂度很显然是 <span class="math notranslate nohighlight">\(O(m+n)\)</span>，所以这个基于归并的算法还远达不到不超过 <span class="math notranslate nohighlight">\(O\bigl(\log(m+n)\bigr)\)</span> 的时间复杂度要求。</p>
<p>我们需要一个更加快的算法，因为问题要求的时间复杂度为对数型，看到对数型的时间要求一定会想到二分法。这个世界上绝大多数达到对数时间的算法都是二分法。下面我们就要重点讲一讲怎么用二分法求两个有序数组的中位数。</p>
</div>
<div class="section" id="id3">
<h2><span class="section-number">3.4.10.2. </span>二分法求两个有序数组的中位数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>根据中位数的定义，假设把 <span class="math notranslate nohighlight">\(A,B\)</span> 两个数组有序归并成数组 <span class="math notranslate nohighlight">\(C\)</span>，取 <span class="math notranslate nohighlight">\(half=\left\lfloor\frac{m + n}{2}\right\rfloor\)</span>，将 <span class="math notranslate nohighlight">\(C\)</span> 分为前后两半 <span class="math notranslate nohighlight">\(C_l\)</span> 和 <span class="math notranslate nohighlight">\(C_r\)</span>。前半部分 <span class="math notranslate nohighlight">\(C_l\)</span> 有 <span class="math notranslate nohighlight">\(half\)</span> 个数，后半部分 <span class="math notranslate nohighlight">\(C_r\)</span> 有 <span class="math notranslate nohighlight">\(m+n-half\)</span> 个数。那么实际上我们已经找到中位数了：</p>
<blockquote>
<div><p>如果 <span class="math notranslate nohighlight">\(m+n\)</span> 为奇数，中位数等于后半部分最小值 <span class="math notranslate nohighlight">\(C_r[0]\)</span>；</p>
<p>如果 <span class="math notranslate nohighlight">\(m+n\)</span> 为偶数，则中位数为前半部分最大值和后半部分最小值的平均值 <span class="math notranslate nohighlight">\(\frac{1}{2}\bigl(C_l[half-1]+C_r[0]\bigr)\)</span>。</p>
</div></blockquote>
<p>但是现在我们不能真的去归并出数组 <span class="math notranslate nohighlight">\(C\)</span> 来，怎么办？我们当然还是要设法把所有的数划分成两半，并且在没有归并、没有排序的情况下判断是不是前一半中的最大值恰好小于等于后一半中的最小值，即 <span class="math notranslate nohighlight">\(\max\{C_l\}\le \min\{C_r\}\)</span>。请注意，现在 <span class="math notranslate nohighlight">\(C_l\)</span> 中的最大值不是 <span class="math notranslate nohighlight">\(C_l[half-1]\)</span> 了，<span class="math notranslate nohighlight">\(C_r\)</span> 中的最小值也不是 <span class="math notranslate nohighlight">\(C_r[0]\)</span> 了。如果找到了满足这个条件的一种划分，那么实际上中位数也就找到了：</p>
<blockquote>
<div><p>如果 <span class="math notranslate nohighlight">\(m+n\)</span> 为奇数，中位数等于后半部分最小值 <span class="math notranslate nohighlight">\(\min\{C_r\}\)</span>；</p>
<p>如果 <span class="math notranslate nohighlight">\(m+n\)</span> 为偶数，则中位数为前半部分最大值和后半部分最小值的平均值 <span class="math notranslate nohighlight">\(\frac{1}{2}\bigl(\max\{C_l\}+\min\{C_r\}\bigr)\)</span>。</p>
</div></blockquote>
<p>要找到这样一种划分，首先要有办法遍历所有可能的划分方法。</p>
<p>不失一般性，假设 <span class="math notranslate nohighlight">\(m \le n\)</span>，即数组 <span class="math notranslate nohighlight">\(A\)</span> 的元素个数不多于数组 <span class="math notranslate nohighlight">\(B\)</span> 的元素个数。如果读入的数据情况相反，我们可以在编程的时候用一个小技巧把两个数组互换过来，这个技巧到后面再讲，现在先在这个假设下进行分析。</p>
<p>如前所述，<span class="math notranslate nohighlight">\(C_l\)</span> 中一定有一些数来自 <span class="math notranslate nohighlight">\(A\)</span>，另一些来自 <span class="math notranslate nohighlight">\(B\)</span>，<span class="math notranslate nohighlight">\(C_r\)</span> 也是如此。<span class="math notranslate nohighlight">\(A\)</span> 和 <span class="math notranslate nohighlight">\(B\)</span> 都为 <span class="math notranslate nohighlight">\(C\)</span> 的前后两半贡献了一些数。不难想象，<span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C_l\)</span> 的数一定都不大于它贡献给 <span class="math notranslate nohighlight">\(C_r\)</span> 的数，即 <span class="math notranslate nohighlight">\(A\)</span> 对 <span class="math notranslate nohighlight">\(C\)</span> 前后两半的贡献其实也是它自己的一个前后划分。数组 <span class="math notranslate nohighlight">\(B\)</span> 当然也一样。所以，是 <span class="math notranslate nohighlight">\(A\)</span> 和 <span class="math notranslate nohighlight">\(B\)</span> 各自的一个前后划分，组合成了 <span class="math notranslate nohighlight">\(C\)</span> 的前后两半。</p>
<p>于是我们可以先任意划分数组 <span class="math notranslate nohighlight">\(A\)</span>，将 <span class="math notranslate nohighlight">\(A[0:k]\)</span> 贡献给 <span class="math notranslate nohighlight">\(C_l\)</span>，<span class="math notranslate nohighlight">\(A[k:m]\)</span> 贡献给 <span class="math notranslate nohighlight">\(C_r\)</span>，其中 <span class="math notranslate nohighlight">\(0\le k\le m\)</span>。当 <span class="math notranslate nohighlight">\(k=0\)</span> 时，<span class="math notranslate nohighlight">\(A\)</span> 中所有元素都贡献给了 <span class="math notranslate nohighlight">\(C_r\)</span>；当 <span class="math notranslate nohighlight">\(k=m\)</span> 时则全部贡献给了 <span class="math notranslate nohighlight">\(C_l\)</span>。</p>
<p><span class="math notranslate nohighlight">\(A\)</span> 划分完毕后，实际上 <span class="math notranslate nohighlight">\(B\)</span> 的划分也就依此而确定了。这是因为 <span class="math notranslate nohighlight">\(C_l\)</span> 规定了是要有 <span class="math notranslate nohighlight">\(half\)</span> 个元素，所以既然 <span class="math notranslate nohighlight">\(A\)</span> 已经提供了 <span class="math notranslate nohighlight">\(k\)</span> 个，那么 <span class="math notranslate nohighlight">\(B\)</span> 就一定是提供 <span class="math notranslate nohighlight">\(half-k\)</span> 个。所以 <span class="math notranslate nohighlight">\(B[0:half-k]\)</span> 贡献给 <span class="math notranslate nohighlight">\(C_l\)</span>，剩余的 <span class="math notranslate nohighlight">\(B[half-k:n]\)</span> 全部贡献给 <span class="math notranslate nohighlight">\(C_r\)</span>。因为我们已经限定了 <span class="math notranslate nohighlight">\(m \le n\)</span>，所以确保了 <span class="math notranslate nohighlight">\(B\)</span> 的划分一定不会出界，即一定能确保 <span class="math notranslate nohighlight">\(0\le half-k\le n\)</span>。这是一个简单的不等式推导，请自行验证。</p>
<p>数组 <span class="math notranslate nohighlight">\(A\)</span> 一共有 <span class="math notranslate nohighlight">\(m+1\)</span> 种划分，其中必有一种是满足中位数划分的条件的，即 <span class="math notranslate nohighlight">\(\max\{C_l\}\le \min\{C_r\}\)</span>，我们的任务于是就变成了找出这种划分。如果蛮力枚举，也已经把时间复杂度降到了 <span class="math notranslate nohighlight">\(O\bigl(\min\{m,n\}\bigr)\)</span>。如果对于任意一种划分 <span class="math notranslate nohighlight">\(k\)</span>，我们有办法确定它是大了还是小了，即数组 <span class="math notranslate nohighlight">\(A\)</span> 给 <span class="math notranslate nohighlight">\(C_l\)</span> 贡献其前 <span class="math notranslate nohighlight">\(k\)</span> 个元素是给多了还是给少了，那么我们就可以愉快地用二分法来查找正确的划分数 <span class="math notranslate nohighlight">\(k\)</span> 了，时间复杂度 <span class="math notranslate nohighlight">\(O\bigl(\log\min\{m,n\}\bigr)\)</span>，问题完美解决。</p>
<p>要判断一个划分 <span class="math notranslate nohighlight">\(k\)</span> 是大了还是小了还是正好，一共有三种情况：</p>
<ol class="arabic">
<li><p><span class="math notranslate nohighlight">\(1\le k \le m-1\)</span>，这时候 <span class="math notranslate nohighlight">\(A[0:k]\)</span> 贡献给了 <span class="math notranslate nohighlight">\(C_l\)</span>，<span class="math notranslate nohighlight">\(A[k:m]\)</span> 在 <span class="math notranslate nohighlight">\(C_r\)</span> 中。相应的，数组 <span class="math notranslate nohighlight">\(B\)</span> 的划分点为 <span class="math notranslate nohighlight">\(j=half-k\)</span>，满足 <span class="math notranslate nohighlight">\(1\le j\le n-1\)</span>，所以 <span class="math notranslate nohighlight">\(B[0:j]\)</span> 贡献给了 <span class="math notranslate nohighlight">\(C_l\)</span>，<span class="math notranslate nohighlight">\(C_r\)</span> 中则是 <span class="math notranslate nohighlight">\(B[j:n]\)</span>。两个数组对前后两半都有贡献，如下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                C的前半部分     |     C的后半部分

来自数组A：  A[0], ..., A[k-1]  |  A[k], ..., A[m-1]

来自数组B：  B[0], ..., B[j-1]  |  B[j], ..., B[n-1]
</pre></div>
</div>
<p>我们要比较前半部分的最大值和后半部分的最小值，前半部分的最大值是 <span class="math notranslate nohighlight">\(A[k-1]\)</span> 和 <span class="math notranslate nohighlight">\(B[j-1]\)</span> 二者中的大者，后半部分的最小值是 <span class="math notranslate nohighlight">\(A[k]\)</span> 和 <span class="math notranslate nohighlight">\(B[j]\)</span> 二者的小者。四者要相互比较大小，但是由于两个原数组本身是有序的，所以 <span class="math notranslate nohighlight">\(A[k-1]\le A[k]\)</span> 和 <span class="math notranslate nohighlight">\(B[j-1]\le B[j]\)</span> 天生成立，它们不需要比较，我们只需要交叉对比即可：</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(A[k-1]\gt B[j]\)</span> 时，说明数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C_l\)</span> 的数太多了，有过大的数混进前半部分去了，所以这时候我们应该减小 <span class="math notranslate nohighlight">\(k\)</span> 的值；</p></li>
<li><p>当 <span class="math notranslate nohighlight">\(B[j-1]\gt A[k]\)</span> 时，说明数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C_l\)</span> 的数太少了，有过小的数混进后半部分去了，所以这时候我们应该增大 <span class="math notranslate nohighlight">\(k\)</span> 的值；</p></li>
<li><p>其余情况，说明 <span class="math notranslate nohighlight">\(A[k-1]\le B[j]\)</span> 且 <span class="math notranslate nohighlight">\(B[j-1]\le A[k]\)</span>，这就是说 <span class="math notranslate nohighlight">\(A[k-1]\)</span> 和 <span class="math notranslate nohighlight">\(B[j-1]\)</span> 二者中的大者小于等于 <span class="math notranslate nohighlight">\(A[k]\)</span> 和 <span class="math notranslate nohighlight">\(B[j]\)</span> 二者的小者，即 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的数都不大于后半部分的数，Bingo！我们找到了中位数。</p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\(k=0\)</span> 时，数组 <span class="math notranslate nohighlight">\(A\)</span> 中所有数都分在了 <span class="math notranslate nohighlight">\(C_r\)</span>，<span class="math notranslate nohighlight">\(C_l\)</span> 全部由 <span class="math notranslate nohighlight">\(B[0:j]\)</span> 构成。此时 <span class="math notranslate nohighlight">\(j=half\)</span>，当 <span class="math notranslate nohighlight">\(m=n\)</span> 时 <span class="math notranslate nohighlight">\(j=n\)</span>，会出现整个数组 <span class="math notranslate nohighlight">\(B\)</span> 都在 <span class="math notranslate nohighlight">\(C_l\)</span> 前半部分的情况，但是这没有关系，如下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                C的前半部分     |     C的后半部分

来自数组A：                     |  A[0], ..., A[m-1]

来自数组B：  B[0], ..., B[j-1]  |  B[j], ..., B[n-1]  (当 m == n 时，j == n，后半部分无 B 的元素)
</pre></div>
</div>
<p>现在，数组 <span class="math notranslate nohighlight">\(A\)</span> 对 <span class="math notranslate nohighlight">\(C_l\)</span> 没有贡献任何数，所以前半部分的最大值就是 <span class="math notranslate nohighlight">\(B[j-1]\)</span>，而且 <span class="math notranslate nohighlight">\(A\)</span> 的划分数 <span class="math notranslate nohighlight">\(k\)</span> 也已经不能再减小了。因此只能有两种情况，要么 <span class="math notranslate nohighlight">\(k\)</span> 小了，要么这个划分正好。而 <span class="math notranslate nohighlight">\(B\)</span> 有没有对 <span class="math notranslate nohighlight">\(C\)</span> 的后半部分贡献元素是无关紧要的，因为要减小 <span class="math notranslate nohighlight">\(k\)</span> 的情况不存在，而且反正也没有数需要和它比大小：</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(B[j-1]\gt A[k]\)</span> 时，说明数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C_l\)</span> 的数太少了，有过小的数混进后半部分去了，所以这时候我们应该增大 <span class="math notranslate nohighlight">\(k\)</span> 的值；</p></li>
<li><p>其余情况，说明这就是中位数的正确划分。</p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\(k=m\)</span> 时，数组 <span class="math notranslate nohighlight">\(A\)</span> 中所有数都被分在了 <span class="math notranslate nohighlight">\(C_l\)</span>，<span class="math notranslate nohighlight">\(C_r\)</span> 全部由 <span class="math notranslate nohighlight">\(B[j:n]\)</span> 构成。此时 <span class="math notranslate nohighlight">\(j=half-m\)</span>，当 <span class="math notranslate nohighlight">\(m=n\)</span> 时 <span class="math notranslate nohighlight">\(j=0\)</span>，会出现整个数组 <span class="math notranslate nohighlight">\(B\)</span> 都在 <span class="math notranslate nohighlight">\(C_r\)</span> 的情况，但是和情况2类似，这也没有关系，如下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                C的前半部分     |     C的后半部分

来自数组A：  A[0], ..., A[m-1]  |

来自数组B：  B[0], ..., B[j-1]  |  B[j], ..., B[n-1]  (当 m == n 时，j == 0，前半部分无 B 的元素)
</pre></div>
</div>
<p>现在，数组 <span class="math notranslate nohighlight">\(A\)</span> 对 <span class="math notranslate nohighlight">\(C_r\)</span> 没有贡献任何数，所以后半部分的最小值就是 <span class="math notranslate nohighlight">\(B[j]\)</span>，而且 <span class="math notranslate nohighlight">\(A\)</span> 的划分数 <span class="math notranslate nohighlight">\(k\)</span> 也已经不能再增大了。因此只能有两种情况，要么 <span class="math notranslate nohighlight">\(k\)</span> 大了，要么这个划分正好。而 <span class="math notranslate nohighlight">\(B\)</span> 有没有对 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分贡献元素是无关紧要的，因为要增大 <span class="math notranslate nohighlight">\(k\)</span> 的情况不存在，而且反正也没有数需要和它比大小：</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(A[k-1]\gt B[j]\)</span> 时，说明数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C_l\)</span> 的数太多了，有过大的数混进前半部分去了，所以这时候我们应该减小 <span class="math notranslate nohighlight">\(k\)</span> 的值；</p></li>
<li><p>其余情况，说明这就是中位数的正确划分。</p></li>
</ol>
</li>
</ol>
<p>上面一共分析了三种情况，每种情况里又有2到3种小情况，显得比较复杂。但是我们发现所有七种小情况其实一共只有减小 <span class="math notranslate nohighlight">\(k\)</span>、增大 <span class="math notranslate nohighlight">\(k\)</span>、解是 <span class="math notranslate nohighlight">\(k\)</span> 这么三类，所以我们可以综合以上三种情况，整合成比较清晰的符合二分查找特征的三个分支：</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(1\le k\le m\)</span> 时，即当 <span class="math notranslate nohighlight">\(k\gt0\)</span> 时，如果 <span class="math notranslate nohighlight">\(A[k-1]\gt B[j]\)</span>，那么减小 <span class="math notranslate nohighlight">\(k\)</span>；</p></li>
<li><p>当 <span class="math notranslate nohighlight">\(0\le k\le m-1\)</span> 时，即当 <span class="math notranslate nohighlight">\(k\lt m\)</span> 时，如果 <span class="math notranslate nohighlight">\(B[j-1]\gt A[k]\)</span>，那么增大 <span class="math notranslate nohighlight">\(k\)</span>；</p></li>
<li><p>其余情况，查找成功。</p></li>
</ol>
<p>上面就是整个二分查找数组 <span class="math notranslate nohighlight">\(A\)</span> 的合适划分数 <span class="math notranslate nohighlight">\(k\)</span> 的过程。</p>
<p>这个二分算法，比我们前面学过的几个都要复杂，而且有以下几个不同之处：</p>
<ol class="arabic simple">
<li><p>问题必有解，所以二分查找的循环甚至可以用死循环，然后在判断找对答案的时候 <code class="docutils literal notranslate"><span class="pre">break</span></code> 循环。</p></li>
<li><p>找对答案的情况比没找对的情况要复杂，所以我们在编程的时候应该先对没找对答案的情况进行判断，最后剩余的就是找对了答案的情况。</p></li>
<li><p>由于必有解，所以在查找的边界处可能会有特殊情况需要照顾，在分析时要引起注意。</p></li>
</ol>
<p>最后介绍一下怎样确保两个原数组一定是 <span class="math notranslate nohighlight">\(m\le n\)</span>。当然不是读完之后判断二者大小然后交换数组元素，那太笨了。我们可以定义一个二维数组用来保存两个原数组：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1000010</span><span class="p">];</span>
</pre></div>
</div>
<p>然后照常读入两个原数组的长度 <code class="docutils literal notranslate"><span class="pre">m</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n</span></code>，将数组 <span class="math notranslate nohighlight">\(A\)</span> 读入到 <code class="docutils literal notranslate"><span class="pre">d[0]</span></code> 中，将数组 <span class="math notranslate nohighlight">\(B\)</span> 读入到 <code class="docutils literal notranslate"><span class="pre">d[1]</span></code> 中。再定义两个整型变量：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>接下来就是见证奇迹的时刻。我们比较两个原数组的长度，如果 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> 就什么都不做，如果 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code> 就交换 <code class="docutils literal notranslate"><span class="pre">m</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n</span></code> 的值，并且让 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">0</span></code>。于是 <code class="docutils literal notranslate"><span class="pre">d[a]</span></code> 就是比较短的那个数组，长度为 <code class="docutils literal notranslate"><span class="pre">m</span></code>；<code class="docutils literal notranslate"><span class="pre">d[b]</span></code> 就是比较短的那个数组，长度为 <code class="docutils literal notranslate"><span class="pre">n</span></code>。搞定！这叫做“名实分离”，我说你是 <span class="math notranslate nohighlight">\(A\)</span> 你就是 <span class="math notranslate nohighlight">\(A\)</span>，说你是 <span class="math notranslate nohighlight">\(B\)</span> 你就是 <span class="math notranslate nohighlight">\(B\)</span>，不管你原本是谁。这个技巧在很多场景下有用，很实用。</p>
<p>下面是完整的程序：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">half</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">half</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="c1">// 确保数组 d[a] 是比较短的那个数组，其长度为m，因此确保 m &lt;= n</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
	
	<span class="c1">// 二分查找数组 d[a] 分在前半部分的数字个数 k，查找范围为从 0 到 m，</span>
	<span class="c1">// 当 d[a] 中有 k 个数分在前半部分的时候，那么 d[b] 中必须有 j = half-k</span>
	<span class="c1">// 个数分在前半部分，这样前半部分一共 half 个数，后半部分 m+n-half 个。</span>
	<span class="c1">// 当 m+n 为偶数时，前后个数相等；奇数时，前半部分少一个。</span>
	<span class="c1">// </span>
	<span class="c1">// 设前半部分最大值为 max_h，后半部分最小值为 min_r，那么当 m+n 为偶</span>
	<span class="c1">// 数时，中位数为 (max_h+min_r)/2.0；为奇数时，中位数为 min_r。</span>
	<span class="c1">//</span>
	<span class="c1">// 因为 m &lt;= n，所以 m &lt;= half &lt;= n，当：</span>
	<span class="c1">//   k = 0 时：d[a] 的所有 m 个数都在后半部分</span>
	<span class="c1">//   k = m 时：d[a] 的所有 m 个数都在前半部分</span>
	<span class="c1">//   1 &lt;= k &lt;= m-1 时：d[a] 和 d[b] 各有一部分数在前后两个部分</span>
	<span class="c1">//</span>
	<span class="c1">// 又，各重要变量的取值范围如下：</span>
	<span class="c1">// 0 &lt;= k &lt;= m, m &lt;= half &lt;= n =&gt; 0 &lt;= m-k &lt;= j = half-k &lt;= n-k &lt;= n</span>
	<span class="c1">//</span>
	<span class="c1">// 此问题必有且仅有一个解，解的条件是：max_h &lt;= min_r</span>
	<span class="c1">//</span>
	<span class="c1">// 查找时应判断 d[a] 提供给前半部分的数字个数 k 是多了还是少了：</span>
	<span class="c1">//     如果 d[a] 贡献给前半部分的最后一个数字 d[a][k-1] 比 d[b] 留在</span>
	<span class="c1">//         后半部分的第一个数字 d[b][j] 大，那么说明 k 多了</span>
	<span class="c1">//     如果 d[b] 贡献给前半部分的最后一个数字 d[b][j-1] 比 d[a]</span>
	<span class="c1">//         留在后半部分的第一个数字 d[a][k] 大，那么说明 k 少了</span>
	<span class="c1">// 所以，进行下面的分析：</span>
	<span class="c1">//     当 1 &lt;= k &lt;= m-1 时：</span>
	<span class="c1">//        IF d[a][k-1] &gt; d[b][j] THEN right = k - 1</span>
	<span class="c1">//        IF d[b][j-1] &gt; d[a][k] THEN left = k + 1</span>
	<span class="c1">//     当 k == 0 时：</span>
	<span class="c1">//        这时已经不可能再减少 k 了，也不存在 d[a][k-1]，只需要判断</span>
	<span class="c1">//        IF d[b][j-1] &gt; d[a][k] THEN left = k + 1</span>
	<span class="c1">//     当 k == m 时：</span>
	<span class="c1">//        这是已经不可能再增加 k 了，也不存在 d[a][k]，只需要判断</span>
	<span class="c1">//        IF d[a][k-1] &gt; d[b][j] THEN right = k - 1</span>
	<span class="c1">//     其他情况都说明查找成功。</span>
	<span class="c1">// 以上三种情况可以合并为两种：</span>
	<span class="c1">//     IF k &lt; m &amp;&amp; d[b][j-1] &gt; d[a][k] THEN left = k + 1</span>
	<span class="c1">//     IF k &gt; 0 &amp;&amp; d[a][k-1] &gt; d[b][j] THEN right = k - 1</span>
	<span class="c1">// 剩余情况说明查找成功，计算 max_h 和 min_r 并得出中位数即可</span>
	<span class="c1">//</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="c1">// d[a], d[b] 各自在前半部分的最大值和后半部分的最小值</span>
	<span class="kt">int</span> <span class="n">max_h</span><span class="p">,</span> <span class="n">min_r</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">half</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// k 小了</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
			<span class="n">right</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// k 大了</span>
		<span class="k">else</span> <span class="p">{</span>			<span class="c1">// Bingo! 找到中位数的正确划分</span>
			<span class="c1">// 计算左半部分的最大值 max_h</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">max_h</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">max_h</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
			<span class="k">else</span>
				<span class="n">max_h</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
			<span class="c1">// 计算右半部分的最小值 min_r</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>
				<span class="n">min_r</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
				<span class="n">min_r</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
			<span class="k">else</span>
				<span class="n">min_r</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">?</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">:</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
			<span class="c1">// 退出循环</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">?</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="nl">min_r</span> <span class="p">:</span> <span class="p">(</span><span class="n">max_h</span> <span class="o">+</span> <span class="n">min_r</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后留一个思考问题：为什么不需要在开始查找之前对“有一个数组为空”的情况进行特判？</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../250_sort_algos.html" title="3.5. 基础排序算法"
             >下一页</a> |</li>
        <li class="right" >
          <a href="249_p1577.html" title="3.4.9. 二分法例题：切绳子（洛谷P1577）"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../240_rec_bin.html" ><span class="section-number">3.4. </span>递归与二分</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>