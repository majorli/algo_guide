
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>3.4.10. 中位数问题 &#8212; C++算法编程指南 0.1 文档</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.5. 基础排序算法" href="../250_sort_algos.html" />
    <link rel="prev" title="3.4.9. 二分法例题：切绳子（洛谷P1577）" href="249_p1577.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../250_sort_algos.html" title="3.5. 基础排序算法"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="249_p1577.html" title="3.4.9. 二分法例题：切绳子（洛谷P1577）"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../240_rec_bin.html" accesskey="U"><span class="section-number">3.4. </span>递归与二分</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.4.10. 中位数问题</a><ul>
<li><a class="reference internal" href="#id2">3.4.10.1. 归并法求两个有序数组的中位数</a></li>
<li><a class="reference internal" href="#id3">3.4.10.2. 二分法求两个有序数组的中位数</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="249_p1577.html"
                        title="上一章"><span class="section-number">3.4.9. </span>二分法例题：切绳子（洛谷P1577）</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="../250_sort_algos.html"
                        title="下一章"><span class="section-number">3.5. </span>基础排序算法</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/ch02/sec04/24A_median.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="index-0">
<span id="id1"></span><h1><span class="section-number">3.4.10. </span>中位数问题<a class="headerlink" href="#index-0" title="永久链接至标题">¶</a></h1>
<p><strong>中位数</strong>（median），又称<strong>中值</strong>，是一个重要的统计指标。它是按顺序排列的一组数据中居于中间位置的数，可将数据划分为个数相等的两部分，其中一部分中所有数都大于等于中位数，另一部分中所有数都小于等于中位数。对于有限的数集，如果其中有奇数个数，那么可以通过把所有数排序后找出正中间的那一个作为中位数；如果有偶数个数，通常取最中间的两个数值的平均数作为中位数。</p>
<div class="admonition- admonition">
<p class="admonition-title">示例</p>
<p>数列 [7,1,3,20,5] 的中位数是5。数列中比5小的数和比5大的数个数相等，都是2个。如果把这5个数排序后得到 [1,3,5,7,20]，可以发现5位于正中间的位置。</p>
<p>数列 [1,3,10,2] 的中位数是2和3的平均数2.5。数列中比2.5小的数和比2.5大的数都是2个。如果把数列排序为 [1,2,3,10]，就可以直观地看出2和3是最中间的两个数，所以中位数取它们的平均数。</p>
</div>
<p>简而言之，一个数列的中位数就是将其排序后，位于最中间位置的数值。对于这个数列而言，其中比中位数小的数和比中位数大的数应当是数量相等的。所以也说“中位数可以将数列中的数据划分为个数相等的两个部分，其中一部分中所有数都大于等于中位数，另一部分中所有数都小于等于中位数”。</p>
<p>关于中位数，有一点概念必须澄清：它是一个单独的数，而不是数列中的一个元素！</p>
<p>如果给出一组数值，求它的中位数是很简单的，只需要对数组进行排序，然后根据元素个数的奇偶性来进行计算即可。</p>
<p>C++的模板算法库algorithm中提供了一个非常方便实用的快速排序函数 <code class="docutils literal notranslate"><span class="pre">std::sort()</span></code>，可以用来对数组中指定的一段元素进行排序。调用 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 函数，只需要提供数组中要排序的那一段元素的头尾指针即可。要使用这个函数，需引入algorithm库并使用命名空间std，下面是用法示例：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 读入100个元素</span>

<span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// 对 a[0] 到 a[9] 之间的10个元素进行排序，注意含头不含尾的范围表示原则</span>
<span class="n">sort</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">40</span><span class="p">);</span> <span class="c1">// 对 a[20] 到 a[39] 之间的20个元素进行排序</span>
<span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// 对 a[0] 到 a[99]，即整个数组进行排序</span>
</pre></div>
</div>
<p>所以，假如有一个题目，要读入 <span class="math notranslate nohighlight">\(n\le1000\)</span> 个整数并求其中位数，那么程序将非常简单：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1001</span><span class="p">];</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>  <span class="c1">// 读数</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>  <span class="c1">// 排序</span>
        <span class="c1">// 根据 n 的奇偶性来计算中位数并输出，保留2位小数</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">?</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
<p>这个程序看懂了吗？看懂了我们就继续讨论一个更加复杂的问题。</p>
<p>现在有两个有序数组 <span class="math notranslate nohighlight">\(A\)</span> 和 <span class="math notranslate nohighlight">\(B\)</span>，各有 <span class="math notranslate nohighlight">\(m\)</span> 和 <span class="math notranslate nohighlight">\(n\)</span> 个元素，两个数组都已经完成升序排序，即元素从小到大排列。现在要求快速求出这两个数组中所有元素的中位数，时间复杂度不高于 <span class="math notranslate nohighlight">\(O(\log(m+n))\)</span>。其中 <span class="math notranslate nohighlight">\(0\le m,n \le 1000000\)</span>，但保证两个数组不会同时为空。</p>
<div class="section" id="id2">
<h2><span class="section-number">3.4.10.1. </span>归并法求两个有序数组的中位数<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>如果两个数组都是乱序的，为了求出它们所有元素的中位数，我们可以把两个数组的元素都合到一个大数组里，然后对大数组进行排序来求出中位数。但使用排序算法最快的时间复杂度为 <span class="math notranslate nohighlight">\(O((n+m)\log(n+m))\)</span>，远大于问题所要求的上限 <span class="math notranslate nohighlight">\(O(\log(n+m))\)</span>。这个方法的主要问题出在没有利用两个原始数组都已经有序这个条件。</p>
<p>那么即然两个数组都已经排好序了，我们可以用一种叫做<strong>归并</strong>的操作把两个数组中的元素保持有序地合到另一个大数组里去，时间复杂度为线性的 <span class="math notranslate nohighlight">\(O(n+m)\)</span>。归并操作非常重要，在大量的算法问题中会用到归并操作，基本排序算法中最重要的<strong>归并排序</strong>也是基于归并操作来完成的，大家一定要熟练掌握。</p>
<p>其实归并操作非常简单，它的思路来源于整队。比如有两列队伍，都是按照身高从矮到高排列好的，现在要把两列队伍合并为一列，并且保持身高从矮到高排列。这个整队过程非常简单，从两列队伍各自排在队头的人开始，每次挑出两个队头中比较矮的那个人出列，排进新的队伍的尾部，如果队头两个人身高一样就任选其中一人即可。不断循环这一过程，直到某个队伍的人全部挑完，把另一个队伍中剩余的人按原顺序排到新队伍的后面就完成了。下面举个简单的例子来说明这个过程：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>初始状态：

队伍一: [1, 3]

队伍二: [2, 6, 7]

新队伍: []

第1步：队伍一的队头1较小，挑出来放到新队伍尾部

队伍一: 1, [3]

队伍二: [2, 6, 7]

新队伍: [1]

第2步：队伍二的队头2较小，挑出来放到新队伍尾部

队伍一: 1, [3]

队伍二: 2, [6, 7]

新队伍: [1, 2]

第3步：队伍一的队头3较小，挑出来放到新队伍尾部

队伍一: 1, 3, []

队伍二: 2, [6, 7]

新队伍: [1, 2, 3]

第4步：队伍一已空，把队伍二剩下的部分按原顺序放到新队伍尾部

队伍一: 1, 3, []

队伍二: 2, 6, 7, []

新队伍: [1, 2, 3, 6, 7]
</pre></div>
</div>
<p>按照这个方法，我们把两个数组读进来之后，可以归并到一个新的数组里去，然后在新数组里计算中位数即可。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000010</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1000010</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2000010</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">half</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="c1">// 计算出元素总数 m+n 的一半，由于C++整数除法向下取整，以及数组从0开始计数的特点</span>
	<span class="c1">// 当 m+n 为奇数时，half 恰好值向中间元素的位置，例如 (2+3)/2=2，c[2]恰好是第3个元素</span>
	<span class="c1">// 当 m+n 为偶数时，half-1 和 half 恰为最中间的两个位置，例如 (2+2)/2=2，c[1]和c[2]位于正中位置</span>
	<span class="n">half</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="c1">// 读入两个原数组 a 和 b</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="c1">// pa, pb: a 和 b 两个数组中还没有被归并部分的首位置；p: c 数组的尾部位置</span>
	<span class="kt">int</span> <span class="n">pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// 每次从 a 和 b 未归并部分的头部挑较小的那个数放到 c 的尾部，直到 a 或 b 中某一个数组被归并完</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">pb</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="p">]</span> <span class="o">?</span> <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="o">++</span><span class="p">];</span>
	<span class="c1">// 把剩余部分照搬到 c 的尾部完成归并</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">pa</span><span class="o">++</span><span class="p">];</span>	<span class="c1">// 如果 a 已经归并完了，这个循环不会进入</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pb</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">pb</span><span class="o">++</span><span class="p">];</span>	<span class="c1">// 同上，故两个循环只有一个会真正运行</span>
	<span class="c1">// 输出中位数</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">?</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">half</span><span class="p">]</span> <span class="o">:</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">half</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">half</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个算法思路很简单，程序很简洁，运行速度其实也挺快的，通常情况下这种方法就很好，推荐使用。但是归并算法有一个很大的问题是大量占用内存，因为它要把所有原数据都复制一份，所以空间复杂度高达 <span class="math notranslate nohighlight">\(O(m+n)\)</span>。</p>
<p>归并过程实际上逐个把所有原数据都复制了一遍，算法的时间复杂度很显然是 <span class="math notranslate nohighlight">\(O(m+n)\)</span>。所以这个基于归并的算法还远达不到问题的时间复杂度要求，不超过 <span class="math notranslate nohighlight">\(O(\log(m+n))\)</span>。</p>
<p>我们需要一个更加快的算法，因为问题要求的时间复杂度为对数型，看到对数型的时间要求一定会想到二分法。这个世界上绝大多数达到对数时间的算法都是二分法。下面我们就要重点讲一讲怎么用二分法求两个有序数组的中位数。</p>
</div>
<div class="section" id="id3">
<h2><span class="section-number">3.4.10.2. </span>二分法求两个有序数组的中位数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>根据中位数的定义，把 <span class="math notranslate nohighlight">\(A,B\)</span> 两个数组有序归并成数组 <span class="math notranslate nohighlight">\(C\)</span>，取 <span class="math notranslate nohighlight">\(half = \lfloor(m + n) / 2\rfloor\)</span>，将 <span class="math notranslate nohighlight">\(C\)</span> 分为前后两半。前半部分有 <span class="math notranslate nohighlight">\(half\)</span> 个数，后半部分有 <span class="math notranslate nohighlight">\(m + n - half\)</span> 个数。这样，前半部分中的最大值一定小于等于后半部分中的最小值。那么我们就已经找到中位数了，如果 <span class="math notranslate nohighlight">\(m+n\)</span> 为奇数，那么中位数就等于后半部分的最小值；如果 <span class="math notranslate nohighlight">\(m+n\)</span> 为偶数，那么中位数就是前半部分最大值和后半部分最小值的平均值。</p>
<p>有了上面的知识，我们就可以进一步这样考虑：怎样把所有数分成这样的前后两个部分，一共有多少种分发？从而可以引出新的二分算法来求中位数。</p>
<p>不失一般性，先让我们假设 <span class="math notranslate nohighlight">\(m\le n\)</span>，即数组 <span class="math notranslate nohighlight">\(A\)</span> 的元素个数不大于数组 <span class="math notranslate nohighlight">\(B\)</span> 的元素个数。如果读入的数据情况相反，我们可以在编程的时候用一个小技巧把两个数组互换过来，这个技巧到后面再讲，现在先在这个假设下进行分析。</p>
<p>前面所述的将归并后的数组 <span class="math notranslate nohighlight">\(C\)</span> 分为前后两部分，实际上在它分成的前一部分，一定有一些数是来自于数组 <span class="math notranslate nohighlight">\(A\)</span> 的，另一些数是来自数组 <span class="math notranslate nohighlight">\(B\)</span> 的，在分成的后半部分也一样。也就是说，数组 <span class="math notranslate nohighlight">\(A\)</span> 和 <span class="math notranslate nohighlight">\(B\)</span> 都为最终的前半部分 <span class="math notranslate nohighlight">\(C\)</span> 和后半部分 <span class="math notranslate nohighlight">\(C\)</span> 贡献了一些数。而且不难想象，数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给前半部分的数一定都不大于它贡献给后半部分的数，即 <span class="math notranslate nohighlight">\(A\)</span> 对前后两个部分的贡献其实也是它自己的一个前后划分。这对于数组 <span class="math notranslate nohighlight">\(B\)</span> 也是同样的情况。所以，是数组 <span class="math notranslate nohighlight">\(A\)</span> 和 <span class="math notranslate nohighlight">\(B\)</span> 各自的一个前后分割，组合成了 <span class="math notranslate nohighlight">\(C\)</span> 的前后两个部分。</p>
<p>于是我们可以考虑先任意分割数组 <span class="math notranslate nohighlight">\(A\)</span>，即把它任意分割成前后两个部分，设前一部分一共 <span class="math notranslate nohighlight">\(k\)</span> 个元素，那么后一部分就是 <span class="math notranslate nohighlight">\(m-k\)</span> 个元素，而且分割点 <span class="math notranslate nohighlight">\(k\)</span> 的取值范围为 <span class="math notranslate nohighlight">\(0\le k \le m\)</span>。即数组 <span class="math notranslate nohighlight">\(A\)</span> 给 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分贡献其前 <span class="math notranslate nohighlight">\(k\)</span> 个数，给 <span class="math notranslate nohighlight">\(C\)</span> 的后半部分贡献后 <span class="math notranslate nohighlight">\(m-k\)</span> 个数。当 <span class="math notranslate nohighlight">\(k=0\)</span> 时，表示数组 <span class="math notranslate nohighlight">\(A\)</span> 中所有元素最终都贡献给了 <span class="math notranslate nohighlight">\(C\)</span> 的后半部分；当 <span class="math notranslate nohighlight">\(k=m\)</span> 时，则全部贡献给了 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分。</p>
<p>数组 <span class="math notranslate nohighlight">\(A\)</span> 划分完毕后，实际上数组 <span class="math notranslate nohighlight">\(B\)</span> 的划分也就依此而确定了。这是因为 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分规定了是要有 <span class="math notranslate nohighlight">\(half\)</span> 个元素，所以既然 <span class="math notranslate nohighlight">\(A\)</span> 已经提供了 <span class="math notranslate nohighlight">\(k\)</span> 个，那么 <span class="math notranslate nohighlight">\(B\)</span> 就一定是要提供 <span class="math notranslate nohighlight">\(half-k\)</span> 个。所以我们接下来要给数组 <span class="math notranslate nohighlight">\(B\)</span> 做的划分已经确定下来了：数组 <span class="math notranslate nohighlight">\(B\)</span> 的前 <span class="math notranslate nohighlight">\(half-k\)</span> 个元素贡献给 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分，剩余的 <span class="math notranslate nohighlight">\(n-(half-k)\)</span> 个元素贡献给 <span class="math notranslate nohighlight">\(C\)</span> 的后半部分。因为我们已经限定了 <span class="math notranslate nohighlight">\(m\le n\)</span>，所以有 <span class="math notranslate nohighlight">\(m\le half \le n\)</span>，又因为有 <span class="math notranslate nohighlight">\(0\le k\le m\)</span>，所以我们可以确保 <span class="math notranslate nohighlight">\(B\)</span> 的划分一定不会“出界”，即 <span class="math notranslate nohighlight">\(0\le half-k\le n\)</span> 得到了保证。这就是我们前面要限制 <span class="math notranslate nohighlight">\(A\)</span> 数组比较短的原因。</p>
<div class="admonition- admonition">
<p class="admonition-title">补充</p>
<p>实际上，如果我们不限定 <span class="math notranslate nohighlight">\(m\le n\)</span> 也是可以分析的，当 <span class="math notranslate nohighlight">\(m \gt n\)</span> 时，数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给前半部分的元素数量 <span class="math notranslate nohighlight">\(k\)</span> 会有一个不同的取值区间，以确保对数组 <span class="math notranslate nohighlight">\(B\)</span> 的划分不会出界。这个分析会相对比较麻烦一些，会烧脑，而且我们知道，烧脑容易带来错误，所以我们干脆限定 <span class="math notranslate nohighlight">\(m\le n\)</span> 更好。</p>
</div>
<p>现在，问题的规模就限制在了对数组 <span class="math notranslate nohighlight">\(A\)</span> 的总共 <span class="math notranslate nohighlight">\(m+1\)</span> 中划分之内，分别为 <span class="math notranslate nohighlight">\(k = 0,1,2,\dots,m\)</span>，其中必有一种是满足数组 <span class="math notranslate nohighlight">\(C\)</span> 的中位数划分的，即前半部分的最大值小于等于后半部分的最小值。我们的任务变成了单纯地找出这种划分，如果蛮力枚举，也已经把时间复杂度降到了 <span class="math notranslate nohighlight">\(O(\min\{m,n\})\)</span>。如果我们对于任意一种划分 <span class="math notranslate nohighlight">\(k\)</span>，有办法确定它是大了还是小了，即数组 <span class="math notranslate nohighlight">\(A\)</span> 给 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分贡献其前 <span class="math notranslate nohighlight">\(k\)</span> 个元素是给多了还是给少了，那么我们就可以愉快地使用二分法来查找正确的划分数 <span class="math notranslate nohighlight">\(k\)</span> 了，左端点为 <span class="math notranslate nohighlight">\(0\)</span>，右端点为 <span class="math notranslate nohighlight">\(m\)</span>，时间复杂度降到 <span class="math notranslate nohighlight">\(O(\log\min\{m,n\})\)</span>，问题就能完美解决了。</p>
<p>其实要做到判断一个划分 <span class="math notranslate nohighlight">\(k\)</span> 是大了还是小了还是正好，是很简单的，只要对 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的最大值和后半部分的最小值进行对比分析即可。那么我们来分析一下，一共有三种情况：</p>
<ol class="arabic">
<li><p><span class="math notranslate nohighlight">\(1\le k \le m-1\)</span>，这时候 <span class="math notranslate nohighlight">\(A[0]\)</span> 到 <span class="math notranslate nohighlight">\(A[k-1]\)</span> 贡献给了 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分，<span class="math notranslate nohighlight">\(A[k]\)</span> 到 <span class="math notranslate nohighlight">\(A[m-1]\)</span> 在后半部分。相应的，数组 <span class="math notranslate nohighlight">\(B\)</span> 的划分点为 <span class="math notranslate nohighlight">\(j=half-k\)</span>，满足 <span class="math notranslate nohighlight">\(1\le j\le n-1\)</span>，所以 <span class="math notranslate nohighlight">\(B[0]\)</span> 到 <span class="math notranslate nohighlight">\(B[j-1]\)</span> 贡献给了 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分，后半部分则是 <span class="math notranslate nohighlight">\(B[j]\)</span> 到 <span class="math notranslate nohighlight">\(B[n-1]\)</span>。两个原数组对 <span class="math notranslate nohighlight">\(C\)</span> 的前后两半都有贡献，如下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                C的前半部分     |     C的后半部分

来自数组A：  A[0], ..., A[k-1]  |  A[k], ..., A[m-1]

来自数组B：  B[0], ..., B[j-1]  |  B[j], ..., B[n-1]
</pre></div>
</div>
<p>我们要比较前半部分的最大值和后半部分的最小值，前半部分的最大值是 <span class="math notranslate nohighlight">\(A[k-1]\)</span> 和 <span class="math notranslate nohighlight">\(B[j-1]\)</span> 二者中的大者，后半部分的最小值是 <span class="math notranslate nohighlight">\(A[k]\)</span> 和 <span class="math notranslate nohighlight">\(B[j]\)</span> 二者的小者。四者要相互比较大小，但是由于两个原数组本身是有序的，所以 <span class="math notranslate nohighlight">\(A[k-1]\le A[k]\)</span> 和 <span class="math notranslate nohighlight">\(B[j-1]\le B[j]\)</span> 天生成立，它们不需要比较，我们只需要交叉对比即可：</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(A[k-1]\gt B[j]\)</span> 时，说明数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的数太多了，有过大的数混进前半部分去了，所以这时候我们应该减小 <span class="math notranslate nohighlight">\(k\)</span> 的值；</p></li>
<li><p>当 <span class="math notranslate nohighlight">\(B[j-1]\gt A[k]\)</span> 时，说明数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的数太少了，有过小的数混进后半部分去了，所以这时候我们应该增大 <span class="math notranslate nohighlight">\(k\)</span> 的值；</p></li>
<li><p>其余情况，说明 <span class="math notranslate nohighlight">\(A[k-1]\le B[j]\)</span> 且 <span class="math notranslate nohighlight">\(B[j-1]\le A[k]\)</span>，这就是说 <span class="math notranslate nohighlight">\(A[k-1]\)</span> 和 <span class="math notranslate nohighlight">\(B[j-1]\)</span> 二者中的大者小于等于 <span class="math notranslate nohighlight">\(A[k]\)</span> 和 <span class="math notranslate nohighlight">\(B[j]\)</span> 二者的小者，即 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的数都不大于后半部分的数，Bingo！我们找到了中位数。</p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\(k=0\)</span> 时，这时候数组 <span class="math notranslate nohighlight">\(A\)</span> 中所有数都分在了 <span class="math notranslate nohighlight">\(C\)</span> 的后半部分，<span class="math notranslate nohighlight">\(C\)</span> 的前半部分全部由 <span class="math notranslate nohighlight">\(B\)</span> 的前 <span class="math notranslate nohighlight">\(j\)</span> 个数构成。此时 <span class="math notranslate nohighlight">\(j=half\)</span>，当 <span class="math notranslate nohighlight">\(m=n\)</span> 时 <span class="math notranslate nohighlight">\(j=m=n\)</span>，会出现整个数组 <span class="math notranslate nohighlight">\(B\)</span> 都在 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的情况，但是这没有关系，如下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                C的前半部分     |     C的后半部分

来自数组A：                     |  A[0], ..., A[m-1]

来自数组B：  B[0], ..., B[j-1]  |  B[j], ..., B[n-1]  (当 m == n 时，j == n，后半部分无 B 的元素)
</pre></div>
</div>
<p>现在，数组 <span class="math notranslate nohighlight">\(A\)</span> 对 <span class="math notranslate nohighlight">\(C\)</span> 前半部分没有贡献任何数，所以前半部分的最大值就是 <span class="math notranslate nohighlight">\(B[j-1]\)</span>，而且 <span class="math notranslate nohighlight">\(A\)</span> 的划分数 <span class="math notranslate nohighlight">\(k\)</span> 也已经不能再减小了。因此只能有两种情况，要么 <span class="math notranslate nohighlight">\(k\)</span> 小了，要么这个划分正好。而 <span class="math notranslate nohighlight">\(B\)</span> 有没有对 <span class="math notranslate nohighlight">\(C\)</span> 的后半部分贡献元素是无关紧要的，因为要减小 <span class="math notranslate nohighlight">\(k\)</span> 的情况不存在，而且反正也没有数需要和它比大小：</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(B[j-1]\gt A[k]\)</span> 时，说明数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的数太少了，有过小的数混进后半部分去了，所以这时候我们应该增大 <span class="math notranslate nohighlight">\(k\)</span> 的值；</p></li>
<li><p>其余情况，说明这就是中位数的正确划分。</p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\(k=m\)</span> 时，这时候数组 <span class="math notranslate nohighlight">\(A\)</span> 中所有数都被分在了 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分，<span class="math notranslate nohighlight">\(C\)</span> 的后半部分全部由 <span class="math notranslate nohighlight">\(B\)</span> 的后 <span class="math notranslate nohighlight">\(n+m-half\)</span> 个数构成。此时 <span class="math notranslate nohighlight">\(j=half-m\)</span>，当 <span class="math notranslate nohighlight">\(m=n\)</span> 时 <span class="math notranslate nohighlight">\(j=0\)</span>，会出现整个数组 <span class="math notranslate nohighlight">\(B\)</span> 都在 <span class="math notranslate nohighlight">\(C\)</span> 后半部分的情况，但是和情况2类似，这也没有关系，如下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                C的前半部分     |     C的后半部分

来自数组A：  A[0], ..., A[m-1]  |

来自数组B：  B[0], ..., B[j-1]  |  B[j], ..., B[n-1]  (当 m == n 时，j == 0，前半部分无 B 的元素)
</pre></div>
</div>
<p>现在，数组 <span class="math notranslate nohighlight">\(A\)</span> 对 <span class="math notranslate nohighlight">\(C\)</span> 后半部分没有贡献任何数，所以后半部分的最小值就是 <span class="math notranslate nohighlight">\(B[j]\)</span>，而且 <span class="math notranslate nohighlight">\(A\)</span> 的划分数 <span class="math notranslate nohighlight">\(k\)</span> 也已经不能再增大了。因此只能有两种情况，要么 <span class="math notranslate nohighlight">\(k\)</span> 大了，要么这个划分正好。而 <span class="math notranslate nohighlight">\(B\)</span> 有没有对 <span class="math notranslate nohighlight">\(C\)</span> 的前半部分贡献元素是无关紧要的，因为要增大 <span class="math notranslate nohighlight">\(k\)</span> 的情况不存在，而且反正也没有数需要和它比大小：</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(A[k-1]\gt B[j]\)</span> 时，说明数组 <span class="math notranslate nohighlight">\(A\)</span> 贡献给 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的数太多了，有过大的数混进前半部分去了，所以这时候我们应该减小 <span class="math notranslate nohighlight">\(k\)</span> 的值；</p></li>
<li><p>其余情况，说明这就是中位数的正确划分。</p></li>
</ol>
</li>
</ol>
<p>上面一共分析了三种情况，每种情况里又有2到3种小情况，显得比较复杂。但是我们发现所有七种小情况其实一共只有减小 <span class="math notranslate nohighlight">\(k\)</span>、增大 <span class="math notranslate nohighlight">\(k\)</span>、解是 <span class="math notranslate nohighlight">\(k\)</span> 这么三类，所以我们可以综合以上三种情况，整合成比较清晰的符合二分查找特征的三个分支：</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(1\le k\le m\)</span> 时，即当 <span class="math notranslate nohighlight">\(k\gt0\)</span> 时，如果 <span class="math notranslate nohighlight">\(A[k-1]\gt B[j]\)</span>，那么减小 <span class="math notranslate nohighlight">\(k\)</span>；</p></li>
<li><p>当 <span class="math notranslate nohighlight">\(0\le k\le m-1\)</span> 时，即当 <span class="math notranslate nohighlight">\(k\lt m\)</span> 时，如果 <span class="math notranslate nohighlight">\(B[j-1]\gt A[k]\)</span>，那么增大 <span class="math notranslate nohighlight">\(k\)</span>；</p></li>
<li><p>其余情况，查找成功。</p></li>
</ol>
<p>上面就是整个二分查找数组 <span class="math notranslate nohighlight">\(A\)</span> 的合适划分数 <span class="math notranslate nohighlight">\(k\)</span> 的过程，当查找到正确的划分后，我们只要把 <span class="math notranslate nohighlight">\(C\)</span> 前半部分的最大值 <span class="math notranslate nohighlight">\(\max_h\)</span> 和后半部分的最小值 <span class="math notranslate nohighlight">\(\min_r\)</span> 计算出来，结束查找就可以了。在结束查找之后，根据 <span class="math notranslate nohighlight">\(m+n\)</span> 的奇偶性得出中位数。如果 <span class="math notranslate nohighlight">\(m+n\)</span> 为奇数，那么中位数等于 <span class="math notranslate nohighlight">\(\min_r\)</span>；为偶则中位数等于 <span class="math notranslate nohighlight">\(\max_h\)</span> 和 <span class="math notranslate nohighlight">\(\min_r\)</span> 的平均值。</p>
<p>这个二分算法，比我们前面学过的几个都要复杂，而且有以下几个不同之处：</p>
<ol class="arabic simple">
<li><p>问题必有解，所以二分查找的循环甚至可以用死循环，然后在判断找对答案的时候 <code class="docutils literal notranslate"><span class="pre">break</span></code> 循环。</p></li>
<li><p>找对答案的情况比没找对的情况要复杂，所以我们在编程的时候应该先对没找对答案的情况进行判断，最后剩余的就是找对了答案的情况。</p></li>
<li><p>由于必有解，所以在查找的边界处可能会有特殊情况需要照顾，在分析时要引起注意。</p></li>
</ol>
<p>最后在动手编程之前，讲解一下怎样确保两个原数组一定是 <span class="math notranslate nohighlight">\(m\le n\)</span>。当然不是读完之后判断二者大小然后交换数组元素，那太笨了。我们可以定义一个二维数组用来保存两个原数组：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1000010</span><span class="p">];</span>
</pre></div>
</div>
<p>然后照常读入两个原数组的长度 <code class="docutils literal notranslate"><span class="pre">m</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n</span></code>，将数组 <span class="math notranslate nohighlight">\(A\)</span> 读入到 <code class="docutils literal notranslate"><span class="pre">d[0]</span></code> 中，将数组 <span class="math notranslate nohighlight">\(B\)</span> 读入到 <code class="docutils literal notranslate"><span class="pre">d[1]</span></code> 中。再定义两个整型变量：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>接下来就是见证奇迹的时刻。我们比较两个原数组的长度，如果 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> 就什么都不做，如果 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code> 就交换 <code class="docutils literal notranslate"><span class="pre">m</span></code> 和 <code class="docutils literal notranslate"><span class="pre">n</span></code> 的值，并且让 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">0</span></code>。于是 <code class="docutils literal notranslate"><span class="pre">d[a]</span></code> 就是比较短的那个数组，长度为 <code class="docutils literal notranslate"><span class="pre">m</span></code>；<code class="docutils literal notranslate"><span class="pre">d[b]</span></code> 就是比较短的那个数组，长度为 <code class="docutils literal notranslate"><span class="pre">n</span></code>。搞定！这叫做“名实分离”，我说你是 <span class="math notranslate nohighlight">\(A\)</span> 你就是 <span class="math notranslate nohighlight">\(A\)</span>，说你是 <span class="math notranslate nohighlight">\(B\)</span> 你就是 <span class="math notranslate nohighlight">\(B\)</span>，不管你原本是谁。这个技巧在很多场景下有用，很实用。</p>
<p>下面是完整的程序：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">half</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">half</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="c1">// 确保数组 d[a] 是比较短的那个数组，其长度为m，因此确保 m &lt;= n</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
	
	<span class="c1">// 二分查找数组 d[a] 分在前半部分的数字个数 k，查找范围为从 0 到 m，</span>
	<span class="c1">// 当 d[a] 中有 k 个数分在前半部分的时候，那么 d[b] 中必须有 j = half-k</span>
	<span class="c1">// 个数分在前半部分，这样前半部分一共 half 个数，后半部分 m+n-half 个。</span>
	<span class="c1">// 当 m+n 为偶数时，前后个数相等；奇数时，前半部分少一个。</span>
	<span class="c1">// </span>
	<span class="c1">// 设前半部分最大值为 max_h，后半部分最小值为 min_r，那么当 m+n 为偶</span>
	<span class="c1">// 数时，中位数为 (max_h+min_r)/2.0；为奇数时，中位数为 min_r。</span>
	<span class="c1">//</span>
	<span class="c1">// 因为 m &lt;= n，所以 m &lt;= half &lt;= n，当：</span>
	<span class="c1">//   k = 0 时：d[a] 的所有 m 个数都在后半部分</span>
	<span class="c1">//   k = m 时：d[a] 的所有 m 个数都在前半部分</span>
	<span class="c1">//   1 &lt;= k &lt;= m-1 时：d[a] 和 d[b] 各有一部分数在前后两个部分</span>
	<span class="c1">//</span>
	<span class="c1">// 又，各重要变量的取值范围如下：</span>
	<span class="c1">// 0 &lt;= k &lt;= m, m &lt;= half &lt;= n =&gt; 0 &lt;= m-k &lt;= j = half-k &lt;= n-k &lt;= n</span>
	<span class="c1">//</span>
	<span class="c1">// 此问题必有且仅有一个解，解的条件是：max_h &lt;= min_r</span>
	<span class="c1">//</span>
	<span class="c1">// 查找时应判断 d[a] 提供给前半部分的数字个数 k 是多了还是少了：</span>
	<span class="c1">//     如果 d[a] 贡献给前半部分的最后一个数字 d[a][k-1] 比 d[b] 留在</span>
	<span class="c1">//         后半部分的第一个数字 d[b][j] 大，那么说明 k 多了</span>
	<span class="c1">//     如果 d[b] 贡献给前半部分的最后一个数字 d[b][j-1] 比 d[a]</span>
	<span class="c1">//         留在后半部分的第一个数字 d[a][k] 大，那么说明 k 少了</span>
	<span class="c1">// 所以，进行下面的分析：</span>
	<span class="c1">//     当 1 &lt;= k &lt;= m-1 时：</span>
	<span class="c1">//        IF d[a][k-1] &gt; d[b][j] THEN right = k - 1</span>
	<span class="c1">//        IF d[b][j-1] &gt; d[a][k] THEN left = k + 1</span>
	<span class="c1">//     当 k == 0 时：</span>
	<span class="c1">//        这时已经不可能再减少 k 了，也不存在 d[a][k-1]，只需要判断</span>
	<span class="c1">//        IF d[b][j-1] &gt; d[a][k] THEN left = k + 1</span>
	<span class="c1">//     当 k == m 时：</span>
	<span class="c1">//        这是已经不可能再增加 k 了，也不存在 d[a][k]，只需要判断</span>
	<span class="c1">//        IF d[a][k-1] &gt; d[b][j] THEN right = k - 1</span>
	<span class="c1">//     其他情况都说明查找成功。</span>
	<span class="c1">// 以上三种情况可以合并为两种：</span>
	<span class="c1">//     IF k &lt; m &amp;&amp; d[b][j-1] &gt; d[a][k] THEN left = k + 1</span>
	<span class="c1">//     IF k &gt; 0 &amp;&amp; d[a][k-1] &gt; d[b][j] THEN right = k - 1</span>
	<span class="c1">// 剩余情况说明查找成功，计算 max_h 和 min_r 并得出中位数即可</span>
	<span class="c1">//</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="c1">// d[a], d[b] 各自在前半部分的最大值和后半部分的最小值</span>
	<span class="kt">int</span> <span class="n">max_h</span><span class="p">,</span> <span class="n">min_r</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">half</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// k 小了</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
			<span class="n">right</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// k 大了</span>
		<span class="k">else</span> <span class="p">{</span>			<span class="c1">// Bingo! 找到中位数的正确划分</span>
			<span class="c1">// 计算左半部分的最大值 max_h</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">max_h</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">max_h</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
			<span class="k">else</span>
				<span class="n">max_h</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
			<span class="c1">// 计算右半部分的最小值 min_r</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>
				<span class="n">min_r</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
				<span class="n">min_r</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
			<span class="k">else</span>
				<span class="n">min_r</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">?</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">:</span> <span class="n">d</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
			<span class="c1">// 退出循环</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">?</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="nl">min_r</span> <span class="p">:</span> <span class="p">(</span><span class="n">max_h</span> <span class="o">+</span> <span class="n">min_r</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后留一个思考问题：为什么不需要在开始查找之前对“有一个数组为空”的情况进行特判？</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../250_sort_algos.html" title="3.5. 基础排序算法"
             >下一页</a> |</li>
        <li class="right" >
          <a href="249_p1577.html" title="3.4.9. 二分法例题：切绳子（洛谷P1577）"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">C++算法编程指南 0.1 文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../200_basic_algos.html" ><span class="section-number">3. </span>简单的基础算法</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../240_rec_bin.html" ><span class="section-number">3.4. </span>递归与二分</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2019, Libin.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0 创建。
    </div>
  </body>
</html>