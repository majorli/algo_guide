.. _ref_511:

欧拉线性筛和互质对
++++++++++++++++++


欧拉线性筛
^^^^^^^^^^

在基础算法部分我们已经学习过怎么利用埃氏筛法来打出一张指定范围内的质数表。我们也提到过，埃氏筛法虽然已经快到足以满足绝大多数的题目要求，但是如果数据范围极其残暴而且程序其他部分还有非常耗时的复杂算法时，有可能还是会不够快。这种时候需要用一种称为 *欧拉线性筛* 或简称为 *欧拉筛*、*线性筛* 的 :math:`O(n)` 算法来打质数表。

这种算法为什么能比埃氏筛更加高效以至于能达到线性时间效率呢？秘密就在于欧拉巧妙地颠倒了内外两层循环，因此就可以设法保证每一个合数只会被它的最小质因数晒掉。为了直观理解，我们用筛选20以内质数的过程来具体看一看。现在我们需要从2到20这一组整数中先后筛掉4,6,8,9,10,12,14,15,16,18,20这11个合数，留下2,3,5,7,11,13,17,19这8个质数。

先来回顾埃氏筛子的做法。埃氏筛子利用两层循环来完成筛选。外层循环是从小到大的已知质数，从2开始，直到某个数的平方超过20；内存循环则是从2开始逐一递增的正整数，就是每次筛选时的倍数。所以用埃氏筛子进行筛选，依次会晒掉以下这些数：

=========== ====== ===============================
外循环轮次  质数   被筛除的合数
=========== ====== ===============================
1           2      4, 6, 8, 10, 12, 14, 16, 18, 20
2           3      *6*, 9, *12*, 15, *18*
3           5      5的平方大于20，筛选结束
=========== ====== ===============================

可以看到，在第二轮用质数3进行筛选的时候，我们实际上重复筛了三个数：6、12和18。原因在于它们都有比3更小的质因数2，而外循环是按照质数从小到大的顺序进行的。这就是埃筛达不到线性时间效率的原因。

下面我们来看欧拉线性筛是怎么操作的。我们如果能按下面这个顺序来进行筛选，就不会出现重复：

==== ========== ====
倍数 已知质数   合数
==== ========== ====
2    [2]        4
3    [2,3]      6, 9
4    [2,3]      8, 但不筛掉3的4倍12
5    [2,3,5]    10, 15
6    [2,3,5]    12, 但不筛掉3的6倍18
7    [2,3,5,7]  14
8    [2,3,5,7]  16
9    [2,3,5,7]  18
10   [2,3,5,7]  20
11+  ...        超过20，不再有筛选，仅收集已知质数
==== ========== ====

要实现这个顺序有两个关键点：一是以倍数从小到大为外层循环，以已知质数从小到大为内层循环，如何确定每一轮外循环时的已知质数列表；二是确保每一个合数都被它的最小的那个质因数筛掉，例如18，它在第9轮外循环以2的9倍这个身份被筛，而不是在第6轮以3的6倍的身份被筛掉。

每一次进入外循环，假设倍数为i，那么我们可以一定确定以及肯定的已经经过筛选的已知质数，就是存在于从2到i的范围之内的所有质数，可以证明这个范围里的所有合数都是已经被筛掉了的。因为最大到i本身，如果它是一个合数，那么它一定可以表示为 :math:`i=k\cdot q`，其中q是它的最小质因数，k是倍数，而且一定 :math:`k<i,q<i`，所以这个合数i一定已经在第k次外循环的时候作为q的k倍数被筛掉了。其他比i更小的合数就更不用说了。例如上面的表格里，在4倍数的外循环时，4这个整数已经在2倍数的外循环中作为质数2的2倍数被筛掉；在6倍数的外循环时，6已经在3倍数的外循环里作为质数2的3倍数筛掉了。但是比i更大的合数就不能保证了，例如在7倍数的外循环时，仅比7大1的整数8还没有被筛掉呢。综上所述，我们就可以顺利地解决第一个关键点了。在每一轮以i为倍数的外循环时，我们只要判断整数i本身是不是已经被筛掉，如果还没有被筛就足以说明i本身就是下一个已知质数，将它加入到已知质数表里就可以了，而最初的最初那个质数2就是天然的第一个已知质数。

外循环从2倍开始，逐次提升。设我们要筛选的范围为2到n，那么因为最小质数为2，所以会发生筛掉合数的外循环最多到n/2（整数除法，向下取整）倍。如果n是偶数例如20，那么外循环到11倍数时最小的候选合数是22，超过20了；如果n是奇数例如21，那么同样的22已经超过了21。因此外循环在 :math:`2\to \lfloor n/2 \rfloor` 倍时会发生筛掉合数，此后每一轮外循环其实已经不会再发生筛选了，它们的作用只是收集已经筛出来的质数。

第二个关键点如何实现就比较微妙了。从上面这个具体的例子来看，就是要怎样在4倍数的循环时，确保3的4倍数12不需要筛，而是把它留给后面的6倍数循环去筛。同样的，在6倍数循环时怎样确保18不会被筛，而是把它留给后面的9倍数循环去。我们来看一下4倍数循环的情况。在4倍数循环时，已知质数列表为[2,3]。按照从小到大的顺序来进行筛选，筛掉2的4倍数8后我们发现倍数4本身能够被质数2整除，所以对于质数3，它的4倍数12一定可以这样分解：:math:`12=4\cdot3=(2\cdot2)\cdot3=(3\cdot2)\cdot2=6\cdot2`，也就是说它一定能分解成2的6倍数。如果还有比3更大的质数，那么同理也一定可以分解成2的若干倍数。所以2之后的任何质数的4倍数都不需要筛掉了，以后一定会在某次后续的外循环时作为2的若干倍被再次找到并筛掉。这个规律可以推广为一般情况，在i倍数外循环时，如果筛掉某个质数p的i倍数后我们发现i本身就是p的倍数（i可以被p整除），设 :math:`i=kp`，那么对于任何比p更大的质数q，它的i倍数一定可以表示为 :math:`iq=(kp)q=(kq)p`，即可以表示为p的某个更大的倍数。所以为了确保每一个合数都被它的最小质因数筛掉，当遇到这种情况时，i倍数的外循环就可以结束了，直接进入到下一轮i+1倍数的外循环去。

好了，上面说了一大堆分析说明，可能还是有点抽象，现在上代码。欧拉线性筛的算法设计比较精巧，也比较难读懂，所以建议学习时一定要自己试着运行一下看看，最好能先在纸面上用一个比较小的n来推演一遍，然后运行一下程序试试，所以请务必在代码里合适的地方加上观察筛选过程的语句进行试验。

.. tip::

   和埃氏筛子的程序一样，如果为了避免手动初始化筛子里每个元素为true，我们可以把筛子元素的bool值反过来用，即用true表示不是质数而false表示是质数。当然这么做会让编程者的思维比较别扭，考虑到欧拉线性筛算法本身就比较别扭，这里我就用了正常的表示法，在每次筛选开始前用 ``memset()`` 函数初始化整个筛子，毕竟这样做比循环赋值的速度是要快许多的。


.. literalinclude:: ../../codes/511_euler_seive.cpp
   :language: c++
   :emphasize-lines: 15,16,19,20

.. note::

   1. 第15、16行的作用就是实现关键点一：收集到i倍数外循环时的已知质数。请注意观察它是怎样确保按从小到大的顺序正确收集到[2,max]范围内的所有质数的。
   2. 第19、20行就是那一行实现了关键点二的神奇代码，请注意理解，这才是使得这种筛子能成为线性筛的关键。

我们可以看到，欧拉线性筛由于需要留存一个已知质数列表 ``primes[MAXN]``，所以比埃氏筛子要多用数倍的内存（int占用4个字节，而bool只用一个字节），而且大多数情况下它和埃氏筛子相比速度的差异并不明显。其实用欧拉线性筛来打质数表是一件杀鸡用牛刀的事情，它的主要作用是用来计算所谓积性函数，最典型的是下面一节要介绍的欧拉 :math:`\varphi` 函数。


欧拉函数
^^^^^^^^

（待续）