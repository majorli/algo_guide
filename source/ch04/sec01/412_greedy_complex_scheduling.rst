贪心法(II) 复杂任务调度
+++++++++++++++++++++++++++++++

作为介绍贪心法的第一个最简单的例子，我们讲过了单机任务调度问题。这里我们将进一步看两个更加复杂一点的任务调度问题，:strong:`区间调度问题`\ 和\ :strong:`双机调度问题`。我们可以看到，区间调度也适用贪心法求解，但是双机调度（乃至多机调度）则无法用贪心法求得最优解。


区间调度问题
^^^^^^^^^^^^

:strong:`区间调度问题`，有时候也会以\ :strong:`活动安排问题`、:strong:`教室安排问题`\ 等形式出现，其实它们都是同一个问题。

区间调度问题也是在一台机器上调度 :math:`n` 个任务，机器同样不能同时运行多个任务。和通常的单机调度不同，区间调度问题的输入数据是一系列的时间区间 :math:`[s_i,f_i),(i=1,2,\dots,n)`，:math:`s_i` 表示每个任务的开始时间，:math:`f_i` 表示结束时间，故而这个问题被称为区间调度问题。时间区间左闭右开意味着机器可以在运行完前一个任务之后立即启动下一个任务，中间无需停顿。这些区间相互之间是会有所重叠的。

显然，只要有两个任务的时间区间有重叠，这两个任务就只能选择调度其中一个，放弃另一个。所以区间调度的调度结果是选择出来的一部分任务，它们之间没有任何时间上的重叠。调度的目标是尽可能多的完成任务，最优解是一个包含任务数量最多的调度序列。

例如我们有11个任务以供调度，任务的开始时间、结束时间已知。为了能更直观地观察这些任务之间的关系，我们还可以画成甘特图，如下：

.. image:: ../../images/412_scheduling.png

仔细想一想，如果我们想要让更多的任务得到运行，那么我们就必须要让每一个任务运行完成后剩余的时间足够多。这就意味着每次调度的时候，我们都需要尽量先调度那些结束时间早的任务。这就是区间调度问题的贪心策略，具体实现的过程只有两步：

1. 对所有待调度的任务按各自的结束时间进行排序。
2. 循环调度任务：第一个应该被调度的任务一定是排完序后的第一个任务，以后每一次调度，假设上一次被调度的任务序号为 :math:`i`，那么下一个就是它后面的第一个开始时间晚于或等于 :math:`f_i` 的任务，如此循环下去直到找不到下一个可调度任务为止，调度就完毕了。

按照这个策略，请手动排一排上面示例中的11项任务并完成调度，看看结果是不是图中标红的4项，也就是调度 :math:`\{2,6,9,11\}`，再尝试一下还能不能找出更完成更多任务数的调度来？

.. hint::

   如果结束时间可以用整数表示，如示例中那样，那么可以使用两个数组 ``s[n]`` 和 ``f[n]`` 分别存放开始时间和结束时间，然后对它们进行整体的外排序来完成这样的区间调度算法编程。但是这样做其实并不简单，也不见得很经济。如果结束时间的取值范围很大，那么外排序可能会消耗大量的空间，比如开计数桶数组。使用外排序还会导致程序中出现大量形如 ``f[ord[i]]`` 这样的数组下标套数组元素的表达式，很容易导致编程时的笔误和混乱。外排序没有库函数可以调用，需要自己编写排序函数，容易引入更多的错误点。更重要的是，万一结束时间不是用整数来表示的，外排序就很难实现。

   所以我们还是建议采用和上一节“部分背包问题”中所用的方法。把任务编号、开始时间、结束时间三项结合起来构造一个结构体，对这个结构体编写一个基于结束时间的比较大小函数，然后直接调用库函数 ``sort()`` 来完成内排序。

   要知道，algorithm库的 ``sort()`` 函数运行效率是极高的，高于标准快速排序。实际编程时强烈推荐调用它来完成排序，而不是自己手写。


双机调度问题
^^^^^^^^^^^^




（待续）
