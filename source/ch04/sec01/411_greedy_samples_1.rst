贪心法（I）：背包问题
++++++++++++++++++++++++++++++++++

背包问题是一类非常经典的算法问题，它是要把 :math:`n` 种不同物品有选择地放进一个背包中，物品有各自的重量 :math:`\{w_1,w_2,\dots,w_n\}` 和价值 :math:`\{v_1,v_2,\dots,v_n\}`，背包有最大承重限制 :math:`W`，我们要选择一个最优的物品组合放入背包中，使得背包中物品的总价值 :math:`V` 最大。通常这些重量和价值都采用正整数来表示。

常见的背包问题有\ :strong:`部分背包问题`、:strong:`0-1背包问题`、:strong:`完全背包问题`\ 和\ :strong:`多重背包问题`。其中前两种是最常见的，后两种是0-1背包问题的变种。这里面只有部分背包问题是贪心法可解的。其他三种都不适用贪心法，尽管它们都有一种可行的伪多项式时间算法，但实际上它们甚至都是NP难题。下面我们分别对部分背包问题的贪心算法和0-1背包问题的贪心法不可解性质进行介绍。至于0-1背包问题及其他两种变种的伪多项式时间算法，是一种必学、常考的经典动态规划算法，我们将在讲述动态规划的章节中进行介绍。


部分背包问题
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在部分背包问题中，所有的物品都是可以拆分的，最小可以拆到重量为1。部分背包问题的另一种常见形式是不同浓度的溶液混合，使混合后的溶液浓度最大化。

部分背包问题是可以用贪心法求解的，但是要正确选择贪心策略。对于背包问题，选择物品的策略有三种：一是依据重量选择，重量越小的越优先；二是依据价值选择，价值越大的越优先；三是依据单位重量的价值选择，单位重量的价值越大的越优先。

按照生活经验，直观地就会选择第三种贪心策略，按单位价值进行从大到小的选择（似乎用混合溶液的提法更容易直观理解）。那么如何用精准的数学语言来证明它呢？这个证明要利用到部分背包问题的一个特殊性质，背包总是能够被塞满，因此最终放入背包的物品的重量总和恒等于 :math:`W`。为了证明这个贪心策略是能够得出正确的最优解的，我们首先要看一下怎么应用它。

首先计算出每一种物品的单位价值 :math:`\rho_i=v_i/w_i`，然后对它们进行排序，得到一个有序的序列 :math:`\rho_{i_1}\le\rho_{i_2}\le\dots\le\rho_{i_n}`。这里的 :math:`\{i_1,i_2,\dots,i_n\}` 是物品编号 :math:`\{1,2,\dots,n\}` 的一个排列。

例如我们的背包总承重限制为 :math:`W=6`，共有四种物品，它们的编号、重量、价值和计算得到的单位价值（保留1位小数）如下表：

+-------------------+-----------------+-----------------+------------------------+
|物品编号 :math:`i` |重量 :math:`w_i` |价值 :math:`v_i` |单位价值 :math:`\rho_i` |
+===================+=================+=================+========================+
|         1         |        3        |        7        |           2.3          |
+-------------------+-----------------+-----------------+------------------------+
|         2         |        2        |        2        |           1.0          |
+-------------------+-----------------+-----------------+------------------------+
|         3         |        4        |        8        |           2.0          |
+-------------------+-----------------+-----------------+------------------------+
|         4         |        5        |        9        |           1.8          |
+-------------------+-----------------+-----------------+------------------------+

于是我们可以得到一个依单位价值从小到大的物品排列 :math:`\{2,4,3,1\}`。

下一步就是应用单位价值大者优先的贪心策略来选取放入背包的物品。从具有最大单位价值 :math:`\rho_{i_n}` 的物品 :math:`i_n` 开始，逐个从后向前选取物品，如果背包剩余的可装重量不足以全部装下当前选择的物品了，那么就从该物品中拆分出恰好等于背包剩余承重的部分来塞满整个背包。如此进行贪心选择，最终得到的解 :math:`\{i_n,i_{n-1},\dots,i_k\},(1 \le k \le n)` 就是最优解。此解中的物品重量总和一定为 :math:`W`，其中物品 :math:`i_n,i_{n-1},\dots,i_{k+1}` 全部装入背包，最后一项物品 :math:`i_k` 装入背包的重量为 :math:`w^\prime_{i_k}\le w_{i_k}`，所以可以计算出这个解得到的背包中物品总价值为 :math:`V=v_{i_n}+v_{i_{n-1}}+\cdots+v_{i_{k+1}}+w^\prime_{i_k}\times\rho_{i_k}`。

例如在我们上面这个例子中，按照这个策略来取物品，得到的解依次包含物品 :math:`\{1,3\}`，其中物品 :math:`3` 所取的重量为 :math:`3`，所以解的总价值为 :math:`7+3\times2=13`。

这个贪心解一定是最优解吗？答案是肯定的。我们可以这样想，根据这个策略得到的解，包里所装的物品有 :math:`\{i_n,i_{n-1},\dots,i_k\}`，未装入包里的物品有 :math:`\{i_k,i_{k-1},\dots,i_1\}`。因为物品编号的排列 :math:`\{i_1,i_2,\dots,i_n\}` 满足单位价值有序：:math:`\rho_{i_1}\le\rho_{i_2}\le\dots\le\rho_{i_n}`，所以任何一种未装入背包的物品的单位价值都不会高于任何一种已装入背包的物品的单位价值，即对于任意的 :math:`1\le p\le k` 和 :math:`k\le q\le n`，:math:`\rho_{i_p}\le\rho_{i_q}` 恒成立。而部分背包问题的特性使得我们总要保持解中所有物品的总重量之和恒为背包总承重量 :math:`W` 不变，使得如果要对解进行变动，必然是要用未放入背包的物品去等重量地替换已经放入背包里的物品。假使我们使用任意重量 :math:`w` 的任意未放入背包的物品 :math:`i_p`，用它来替换等重的已放入背包物品 :math:`i_q`，那么从解中换出去的价值为 :math:`w\cdot\rho_{i_q}`，换进来的价值为 :math:`w\cdot\rho_{i_p}`，因为 :math:`\rho_{i_p}\le\rho_{i_q}`，所以这样的交换必然是得不偿失，不可能使解的总价值得到提升，只可能下降。

到此就证明了我们得到的贪心解，是已经不可能通过任何交换来使其价值更大了，它就是最优解。有兴趣的可以用我们上面的示例数据来试一试，看看能不能找出总价值比 :math:`13` 更大的解来。

部分背包问题的贪心算法就讲解完了，但是你能编出这样一个程序来吗？事实上要编出这个程序来还是有一定难度的，难度在于计算和排序的技巧，希望大家能够尝试一下。

.. hint::

   要编写这个程序，第一个要注意的是单位价值不一定是整数，但是考虑到浮点数的精度问题，在排序时最好不要用浮点数进行比较，那么就需要将小数比大小改成分数比大小，怎么办？第二个难点是对单位价值进行排序的时候不能使用普通的内排序方法直接将单位价值数组进行排序，而是要对它们的编号进行排序，即要用外排序。而我们学过的外排序方法比如桶排、计数排都是针对整数的排序，并不适合分数或小数，怎么办？一种方法是可以用数据结构来帮助我们。

   用一个数据结构来组织数据，而不是简单的用几个数组，可以使用内排序而且使得排完之后每个元素还都记得自己的编号。例如我们可以定义这样一个自定义结构来表示物品（Stuff）：

   .. code-block:: c++

      struct Stuff {
              int id;         // 编号
              int w;          // 重量
              int v;          // 价值
      };

   这样，我们可以自行设计一种用来比较两个分数大小的比较函数，用它来对物品数组直接进行内排序。排完之后，数组里的每一个元素虽然位置改变了，但它们还在自己的数据结构里储存着自己的物品编号。这样就避免了可能很复杂的分数外排序，甚至可以直接使用algorithm库的 ``sort()`` 函数来完成排序，所要做的只是提供一个可以比较 ``Stuff`` 型变量大小（实际上就是 ``v/w`` 的分数大小）的比较函数而已。


0-1背包问题初探
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

0-1背包问题是最为经典的背包问题。所谓“0-1”的意思就是指物品不能拆分，要么不放入背包（即放入0个），要么放入背包（即放入1个），非0即1。其他规则和目标与部分背包问题全无二致。0-1背包问题还有一些更加复杂的变种，比较常见的有完全背包问题和多重背包问题。完全背包问题的变化是每种物品都有无限多个，可以选择0个或任意数量个放入背包，但是物品不能拆分。多重背包问题是每一种物品都有各自的总数量 :math:`q_i\ge 1`，可以选择0个或者最多 :math:`q_i` 个放入背包。事实上只要能解开0-1背包问题，这两种变种的解法也就相应产生了。0-1背包问题是出了部分背包问题以外所有其他背包问题变种的源头。

现在有一个坏消息和一个好消息。坏消息是：:strong:`0-1背包问题是NP难题`；好消息是：:strong:`它有一个很好用的` :math:`O(nW)` :strong:`时间的动态规划解法`，其中 :math:`W` 是背包总承重，:math:`n` 是物品种数。听上去有点矛盾，其实这个动态规划解法并不是多项式时间的，总承重 :math:`W` 作为一个乘数的存在使得它事实上还是一个指数时间算法，只不过这个指数增长很慢，在绝大多数数据范围内它运行得还是很有效的。

我们在这里不打算详细介绍0-1背包问题的动态规划解法，这个算法留到后面动态规划的部分再讲。现在我们只是来初窥一下这个目前为止第一次遇到的NP难题，看看为什么贪心法对它不起作用。



