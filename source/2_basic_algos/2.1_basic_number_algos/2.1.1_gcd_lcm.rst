最大公因数与最小公倍数
++++++++++++++++++++++

最大公因数
^^^^^^^^^^

数学中一般用 :math:`\gcd(a,b)` 表示两个整数 :math:`a` 和 :math:`b` 的最大公因数。显然，此运算满足交换律。

.. math::

    \gcd(a,b)=\gcd(b,a)

求取两个正整数的最大公因数一般采用辗转相除法，也称为欧几里得法，是古希腊数学家欧几里得发现的一种用来快速计算两个整数的最大公因数的算法。这个算法非常快速，而且同时非常适合人和计算机。辗转相除法法求最大公因数的原理来源于最大公因数的两个性质：

1. 任何整数和0的最大公因数，它和它自己的最大公因数都就是这个整数自己。

.. math::

    \gcd(a,0)=\gcd(a,a)=a

2. 两个不相等的整数的最大公因数等于大数除以小数得到的余数和小整数的最大公因数。

.. math::

    a\gt b\implies \gcd(a,b)=\gcd(a\mod b,b)

辗转相除法就是利用上面的两条性质，不断地用大数去除小数，把大的那个数变成它除小的那个数的余数，直到其中有一个数变为0，此时另一个数就是要求的最大公因数。举例说明如下。

.. admonition:: 示例

    .. math::
    
        \begin{align}
        &\gcd(16, 12) = \gcd(4, 12) = \gcd(4, 0) = 4\\
        &\gcd(14, 3) = \gcd(2, 3) = \gcd(2, 1) = \gcd(0, 1) = 1\\
        &\gcd(48, 36) = \gcd(12, 36) = \gcd(12, 0) = 12\\
        &\gcd(105, 21) = \gcd(0, 21) = 21\\
        &\gcd(7, 7) = \gcd(0, 7) = 7\\
        \end{align}


**算法实现**

用一个结束条件是某一次辗转相除的时候取得的余数为0的循环即可实现辗转相除法。

.. code-block:: c++

    int gcd(int a, int b)
    {
        while (a && b)
            if (a > b)
                a %= b;
            else
                b %= a;
        
        return a + b;
    }

.. note::

    1. 循环条件 ``(a && b)`` 相当于 ``(a != 0 && b != 0)``，也就是当 ``a`` 或者 ``b`` 中的任何一个是 ``0`` 的时候，循环就结束了。
    2. 因为循环结束之后，``a`` 和 ``b`` 中肯定至少有一个是 ``0``，所以最大公因数就是另一个数，为了简化程序，我们利用任何数加上零等于它自己的性质，直接把结果赋值为 ``a+b`` 即可，无需再去判断其中哪一个是 ``0`` 了。

利用c++ 的三元运算，可以把上面这个函数的代码进一步简化。

.. code-block:: c++

    int gcd(int a, int b)
    {
        while (a && b && (a > b ? a %= b : b %= a));
        return a + b;
    }

利用多个整数最大公因数的数学性质 :math:`\gcd(a, b, c)=\gcd(\gcd(a,b),c)` 可以方便地循环调用上面的 ``gcd()`` 函数求出任意个正整数的最大公因数。

.. attention::

    以上算法仅对0和正整数有效，尽管对于绝大部分算法程序已经足够，但也可能出现需要处理负数的情况，请自行设法修改以适应负数。

最小公倍数
^^^^^^^^^^
