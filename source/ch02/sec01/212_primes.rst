和质数相关的基础算法
++++++++++++++++++++

我们所说的质数，一般不考虑负数的情况，我们考虑的范围是所有大于或等于2的正整数。

质数判断
^^^^^^^^

如何判断一个整数是不是质数？对于单个整数n，我们就用最简单的小学数学课上教的方法，从2开始到n-1为止逐个寻找它的因数，如果这中间找到了至少一个因数，那么n就是一个合数，否则它就是质数。当然了，数学老师教过我们，其实不需要一直找到n-1，只要找到那个其平方值大于等于n的数为止就可以了。

所以判断一个整数是不是质数的程序，核心就是一个 :math:`2\to t:t^2\le n` 的循环。

.. code-block:: c++

   bool is_prime(int n)
   {
       if (n < 2)
           return false;
       for (int t = 2; t * t <= n; t++)
           if (n % t == 0)
               return false;
       return true;
   }

这个方法运行起来速度并不像想象中那么慢，有兴趣可以试一试，其实速度还是很快的。如果程序中只是需要对某些整数进行判断，这个小函数就完全够用了。但是如果程序要求在一个很大范围内找出其中的所有质数，比如1,000,000,000以内的所有质数，那么逐个用这个函数来判断就不那么高效了。这种情况下我们常用一种叫做 **埃拉托斯特尼筛法（简称埃氏筛法、埃筛、素数筛）** 的算法来快速打出一张质数表。


埃氏筛法
^^^^^^^^

埃氏筛法是由希腊数学家埃拉托斯特尼（Eratosthenes）所提出的一种简单检定质数的算法。要得到大于2的自然数n以内的全部质数，必须把不大于 :math:`\sqrt{n}` 的所有质数的倍数剔除，剩下的就是质数。下面这个动图演示了埃氏筛子筛选出120以内质数的过程。

.. image:: ../../images/212_Sieve_of_Eratosthenes_animation.gif

这个算法实现起来也很简单，需要提供一个足够大的 ``bool`` 型数组作为质数表。先把0号和1号元素初始化为 ``false``，2号到n号的所有元素初始化为 ``true``。然后从2开始进行筛选，将表中所有的2的倍数号的元素赋值为 ``false``，表中剩下的最小的数字就是3，它不能被更小的数整除，所以3是质数。再将表中所有的3的倍数号元素赋值为 ``false``……依此类推，如果表中剩余的最小的数是m，那么m就是质数，接下来就将表中所有m的倍数号元素赋值为 ``false``。像这样反复操作，直到那个其平方大于等于n的数为止，因为再往上，所有的合数肯定已经都被筛选掉了。（希望大家能去想一想为什么？）


.. tip::

    一般来说一个程序里只要打一张质数表就够了，我们可以把这张表定义为一个全局的数组。但是相对于通常的做法，我更喜欢在这张表里用 ``true`` 表示合数，用 ``false`` 表示质数，因为全局变量会自动初始化为全0，也就是全 ``false``，这样的话，我们的埃筛打表函数里就不需要手动把数组所有元素初始化为 ``true`` 了，要知道这个步骤需要一个大循环来完成，如果表很大还是挺费时间的。

.. tip::

   另一个可以提高效率的小窍门：每次用质数 :math:`p` 来进行筛选时，不需要从 :math:`2p` 开始，直接从 :math:`p^2` 开始筛就可以了，因为从 :math:`2p` 到 :math:`(p-1)p` 这些个倍数其实都已经被前面的质数筛过了。


下面是一个用了我的小窍门的“反”埃筛打表程序。

.. literalinclude:: ../../codes/212_erato_seive.cpp
   :language: c++
   :emphasize-lines: 20,23

.. admonition:: 思考

   如果要打一个从某个整数 :math:`m\gt2`，而不是从2开始的质数表，当然你可以坚持从2开始，但是为了节省一点空间和时间，你可以怎样改进这个算法？


埃氏筛子的时间复杂度是 :math:`O(n\log\log n)`，这已经非常非常接近 :math:`O(n)` 了，绝大多数情况下都不会出现问题。但是对于那些极大的数据规模，例如 :math:`n\ge10^9`，再加上如果程序的其他部分也是相当耗时的复杂算法，那么普通的埃筛还是有可能跪TLE的。这时候一种叫做欧拉线性筛的 :math:`O(n)` 筛法就闪亮登场了。

欧拉线性筛是一种 :math:`O(n)` 的质数筛选算法，是最为高效率的质数筛。它虽是对埃氏筛法的一种优化改进，但这个算法本身的目的并非是单纯地为了筛选质数，它主要用于高效计算所谓的 *积性函数*，即满足性质 :math:`f(a\cdot b)=f(a)\cdot f(b)` 的函数，例如同样以欧拉命名的欧拉函数 :math:`\varphi(n)` 就是一个积性函数，它用于求解与正整数n互质的正整数（包括1）的个数，并且它满足 :math:`\varphi(n\cdot m)=\varphi(m)\cdot\varphi(n)`。

对于线性筛，目前我们不要求掌握，以后在高级数论算法的时候再讨论。目前我们要知道的是：

1. 欧拉线性筛是一种最高效的质数筛法，它的平均速度比埃氏筛子快3到4倍，但是它要比埃氏筛法多用近3倍的内存。
2. 欧拉线性筛在数据量较小的时候，由于大量使用取模运算，速度甚至会比埃氏筛子慢。
3. 因此欧拉线性筛一般不用于打质数表，通常情况下需要打质数表的算法就不多，绝大多数时候用埃氏筛子已经足够了。
4. 欧拉线性筛的主要用途是快速计算积性函数。

对欧拉线性筛有兴趣的可以参考这篇博文：`线性筛 <https://www.cnblogs.com/zhuohan123/p/3233011.html>`_。想了解欧拉函数的可以参考这篇博文：`十分钟学会计算欧拉函数 <https://blog.csdn.net/ydd97/article/details/47805419>`_。


中国余数定理
^^^^^^^^^^^^

中国余数定理，又叫孙子定理，是用于求解一元线性同余方程组的一种算法。
