和质数相关的基础算法
++++++++++++++++++++

我们所说的质数，一般不考虑负数的情况，我们考虑的范围是所有大于或等于2的正整数。

质数判断
^^^^^^^^

如何判断一个整数是不是质数？对于单个整数n，我们就用最简单的小学数学课上教的方法，从2开始到n-1为止逐个寻找它的因数，如果这中间找到了至少一个因数，那么n就是一个合数，否则它就是质数。当然了，数学老师教过我们，其实不需要一直找到n-1，只要找到那个其平方值大于等于n的数为止就可以了。

所以判断一个整数是不是质数的程序，核心就是一个 :math:`2\to t:t^2\le n` 的循环。

.. code-block:: c++

   bool is_prime(int n)
   {
       if (n < 2)
           return false;
       for (int t = 2; t * t <= n; t++)
           if (n % t == 0)
               return false;
       return true;
   }

这个方法运行起来速度并不像想象中那么慢，有兴趣可以试一试，其实速度还是很快的。如果程序中只是需要对某些整数进行判断，这个小函数就完全够用了。但是如果程序要求在一个很大范围内找出其中的所有质数，比如1,000,000,000以内的所有质数，那么逐个用这个函数来判断就不那么高效了。这种情况下我们常用一种叫做 **埃拉托斯特尼筛法（简称埃氏筛法、埃筛、素数筛）** 的算法来快速打出一张质数表。


埃氏筛法
^^^^^^^^

埃氏筛法是由希腊数学家埃拉托斯特尼（Eratosthenes）所提出的一种简单检定质数的算法。要得到大于2的自然数n以内的全部质数，必须把不大于 :math:`\sqrt{n}` 的所有质数的倍数剔除，剩下的就是质数。下面这个动图演示了埃氏筛子筛选出120以内质数的过程。

.. image:: ../../images/212_Sieve_of_Eratosthenes_animation.gif

这个算法实现起来也很简单，需要提供一个足够大的 ``bool`` 型数组作为质数表。先把0号和1号元素初始化为 ``false``，2号到n号的所有元素初始化为 ``true``。然后从2开始进行筛选，将表中所有的2的倍数号的元素赋值为 ``false``，表中剩下的最小的数字就是3，它不能被更小的数整除，所以3是质数。再将表中所有的3的倍数号元素赋值为 ``false``……依此类推，如果表中剩余的最小的数是m，那么m就是质数，接下来就将表中所有m的倍数号元素赋值为 ``false``。像这样反复操作，直到那个其平方大于等于n的数为止，因为再往上，所有的合数肯定已经都被筛选掉了。（希望大家能去想一想为什么？）


.. tip::

    一般来说一个程序里只要打一张质数表就够了，我们可以把这张表定义为一个全局的数组。但是相对于通常的做法，我更喜欢在这张表里用 ``true`` 表示合数，用 ``false`` 表示质数，因为全局变量会自动初始化为全0，也就是全 ``false``，这样的话，我们的埃筛打表函数里就不需要手动把数组所有元素初始化为 ``true`` 了，要知道这个步骤需要一个大循环来完成，如果表很大还是挺费时间的。

.. tip::

   另一个可以提高效率的小窍门：每次用质数 :math:`p` 来进行筛选时，不需要从 :math:`2p` 开始，直接从 :math:`p^2` 开始筛就可以了，因为从 :math:`2p` 到 :math:`(p-1)p` 这些个倍数其实都已经被前面的质数筛过了。


下面是一个用了我的小窍门的“反”埃筛打表程序。

.. literalinclude:: ../../codes/212_erato_seive.cpp
   :language: c++
   :emphasize-lines: 20,23

.. admonition:: 思考

   如果要打一个从某个整数 :math:`m\gt2`，而不是从2开始的质数表，当然你可以坚持从2开始，但是为了节省一点空间和时间，你可以怎样改进这个算法？


埃氏筛子的时间复杂度是 :math:`O(n\log\log n)`，这已经非常非常接近 :math:`O(n)` 了，绝大多数情况下都不会出现问题。但是对于那些极大的数据规模，例如 :math:`n\ge10^9`，再加上如果程序的其他部分也是相当耗时的复杂算法，那么普通的埃筛还是有可能跪TLE的。这时候一种叫做欧拉线性筛的 :math:`O(n)` 筛法就闪亮登场了。

欧拉线性筛是一种 :math:`O(n)` 的质数筛选算法，是最为高效率的质数筛。它虽是对埃氏筛法的一种优化改进，但这个算法本身的目的并非是单纯地为了筛选质数，它主要用于高效计算所谓的 *积性函数*，即满足性质 :math:`f(a\cdot b)=f(a)\cdot f(b)` 的函数，例如同样以欧拉命名的欧拉函数 :math:`\varphi(n)` 就是一个积性函数，它用于求解与正整数n互质的正整数（包括1）的个数，并且它是一个不完全的积性函数，当两个正整数m和n互质时，它满足 :math:`\varphi(n\cdot m)=\varphi(m)\cdot\varphi(n)`。

对于线性筛，目前我们不要求掌握，以后在高级数论算法的时候再讨论。目前我们要知道的是：

1. 欧拉线性筛是一种最高效的质数筛法，它的平均速度比埃氏筛子快3到4倍，但是它要比埃氏筛法多用至少一倍的内存。
2. 欧拉线性筛在数据量较小的时候，由于大量使用取模运算，速度甚至会比埃氏筛子慢。
3. 因此欧拉线性筛一般不用于打质数表，通常情况下需要打质数表的算法就不多，绝大多数时候用埃氏筛子已经足够了。
4. 欧拉线性筛的主要用途是快速计算积性函数。

如果有兴趣，可以跳转到线性筛和欧拉函数的相关章节：:ref:`ref_511`。


中国余数定理
^^^^^^^^^^^^

中国余数定理，又叫孙子定理，是用于求解一元线性同余方程组的一种算法。用数学语言来讲，中国余数定理给出了一元线性同余方程组有解的判定方法，并且在有解的情况下获得解的一种构造法。

.. hint::

   在数学语言里，整数 :math:`a` 除以除以整数 :math:`m` 的余数等于 :math:`r` 记作 :math:`a\equiv r(\mod m)`。把整数运算的数值范围限制在 :math:`[0,m-1]` 范围之内，一旦某数超过这个范围就取其除以 :math:`m` 的余数的运算称为 *模m的运算*。

所谓一元线性同余方程组是指整数域内的这样一个方程组：

.. math::

   \begin{cases}
   x\equiv a_1(\mod m_1)\\
   x\equiv a_2(\mod m_2)\\
   \vdots\\
   x\equiv a_n(\mod m_n)
   \end{cases}

中国余数定理说，如果方程组中的模 :math:`m_1,m_2,\dots,m_n\in\Bbb{Z}` 两两互质，那么对于任意的 :math:`a_1,a_2,\dots,a_n\in\Bbb{Z}`，上面这个方程组有解。而且可以用下面的方法来构造出解。

设 :math:`M=\prod_{i=1}^n{m_i}=m_1\times m_2\times\cdots\times m_n`，并设 :math:`M_i=M/m_i,(i=1,2,\dots,n)`，即 :math:`M_i` 是除了 :math:`m_i` 以外其他所有n-1个模的乘积。再设 :math:`t_i` 是 :math:`M_i` 的模 :math:`m_i` 运算下的倒数，即 :math:`t_i\cdot M_i\equiv 1(\mod m_i)`。那么上面这个方程组的通解就是：

.. math::

   x=kM+\sum_{i=1}^n{a_it_iM_i}=kM+a_1t_1M_1+a_2t_2M_2+\cdots+a_nt_nM_n,(k\in\Bbb{Z})

如果把解限制在模 :math:`M` 运算的意义下，那么就只有一个确定的解，:math:`x=\left(\sum_{i=1}^n{a_it_iM_i}\right)\mod M`。

这么说肯定太抽象了，下面来看一个简单的具体例子大家就明白这一大堆数学符号是在做什么了。这是最经典的一类题，最常见的一组数据，小学奥数的时候就做过这组数据的题。


.. admonition:: 例题

   某学校每个班的学生人数为40到60人不等，有一个班的学生分组做实验，如果每组三人就多两人，每组五人就多三人，每组七人就多四人，问这个班有多少学生?


此题用的是最经典的三模组 :math:`m_1=3`，:math:`m_2=5`，:math:`m_3=7`，显然它们两两互质。它们对应的余数分别是 :math:`a_1=2`，:math:`a_2=3`，:math:`a_3=4`。按照中国余数定理，通解一定存在。但是要在规定的40到60之间找到这样一个特殊解可并不一定，这一点一定要清楚！

先计算出构造通解所需的常数：:math:`M=3\cdot5\cdot7=105`，:math:`M_1=5\cdot7=35`，:math:`M_2=3\cdot7=21`，:math:`M_3=3\cdot5=15`。

然后我们要找出这样一些倍数 :math:`t_1M_1`，:math:`t_2M_2`，:math:`t_3M_3` 使得它们分别除以自己对应的模后余数为1。经过简单的计算我们发现 :math:`2\cdot M_1=70`，:math:`1\cdot M_2=21`，:math:`1\cdot M_3=15` 满足上面的要求，把它们分别除以对应的模3、5、7得到的余数都是1。

接下来我们就可以按照定理公式来得到通解了：:math:`x=105k+2\cdot70+3\cdot21+4\cdot15=263+105k,(k\in\Bbb{Z})`。

最后，根据题意找出在40和60之间的那个特殊解，容易看出来，当 :math:`k=-2` 的时候，:math:`x=263-2\times105=53` 满足题目要求，再增加一个105或减少一个105都会超出题目要求的人数范围。所以本题的答案是53人。


可见用中国余数定理来求解此类问题的构造解法本身就是一个典型的算法。虽然对于三五七这样一组简单的模来说，似乎解题过程反而复杂了，但是由于它定义了一套完好的计算过程，每一步都可以用固定的方法进行计算，最后在有限步之内得出正确答案，并且它还有一个容易用计算机程序实现的适用性判据。所以这个定理特别适合用计算机程序来实现。具体怎么实现视具体题目而定，应该不难，请大家遇到题目自行解决，重点是理解定理的使用方法。但是有下面几点需要特别关注。

* 少数题目可能给出的数据不一定满足所有模都两两互质，因此有必要在程序开始时进行互质判断。如果模组不满足两两互质那么可能要用到更加复杂的同余方程组求解方法，有兴趣的可以自行寻找“同余方程组”相关的资料进行学习。但是这样的题目不多，而且大多数情况下遇到这样的模组，完全可以用循环测试公倍数的方法来解决。
* 如果模的数量非常大，或者模本身数值很大，那么参数 :math:`M` 和 :math:`M_i` 可能会很大，注意数据超限问题。
* 如果 :math:`M_i` 很大，那么在从1倍开始逐个寻找满足条件的倍数 :math:`t_iM_i` 时可以利用余数运算的规则，先计算出 :math:`M_i` 除以 :math:`m_i` 的余数 :math:`r_i`，然后去寻找满足 :math:`t_ir_i\equiv1(\mod m_i)` 的倍数 :math:`t_i`，想一想这是为什么？
* 最后最重要的一点，题目要求找的特殊解取值范围内，可能有1个解，也可能无解，也可能有多个解！千万注意！！此类题目最容易WA的点就在这里。
