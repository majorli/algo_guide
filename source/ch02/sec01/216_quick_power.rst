.. index:: 快速幂（整数）, 洛谷P1226

快速幂算法（整数快速幂）
+++++++++++++++++++++++++++++++++++++

整数快速幂算法（简称快速幂）是一个经典的数值运算算法，也是普及组的常考算法。它的功能就是快速计算整数的幂运算\ :math:`a^n`，:math:`a`\ 称为底数，:math:`n`\ 称为指数。根据数学定义，整数的幂运算就是将底数连乘指数次，另外有一个特例：任何数的0次幂都等于1。

.. math::

   a^n=\begin{cases}\underbrace{a\times\cdots\times a}_\text{n times}&, n\neq0\\1&, n=0\end{cases}

所以按照数学定义我们可以很简单地用一个循环来计算出整数的幂。

.. code-block:: c++

   int power(int a, int n)
   {
           if (n == 0) return 1;
   
           int ans = 1;
           for (int p = 0; p < n; p++)
                   ans *= a;
   
           return ans;
   }

除了数据类型 ``int`` 有点偏小以外，上面这段代码的正确性无懈可击，因为我们知道指数是一种增长速度快得可怕的运算，``int`` 类型整数的绝对值最大也不过\ :math:`2^{31}-1`\ ，大约21亿多，用来计算整数幂很可能一不留神就爆掉了。但是就算改成 ``long long`` 类型情况也好不到哪里去，如果换成 ``double`` 类型那么数据的精度又成了大问题。所以上面这个算法的一个小问题就是它很可能需要有\ :strong:`高精度整数运算`\ 算法的加持。

但是这不是最重要的，最重要的是上面这种朴素的算法在效率上非常堪忧。它需要着着实实地进行n次乘法计算，所以它的时间复杂度是\ :math:`O(n)`。鉴于计算机进行乘法运算本身就很费时，所以这样的运行效率并不能令人满意。假设用上了高精度乘法，那么这个朴素的算法就很费力了。这是它最大的问题所在，我们需要一种更优秀的算法，这就是经典的整数快速幂算法，效率高达\ :math:`O(\log n)`。


**快速幂算法的数学原理**

一切的一切来自于幂运算的一条基本性质：:math:`a^{b+c}=a^b\times a^c`。这条性质很好理解，:math:`a^{b+c}`\ 就是把底数\ :math:`a`\ 连乘\ :math:`(b+c)`\ 次，所以就是\ :math:`a`\ 连乘\ :math:`b`\ 次再乘以它连乘\ :math:`c`\ 次。

所以如果我们能把比较大的指数\ :math:`n`\ 拆成少量的几个小一点的整数之和，那么我们就可以设法把一个规模比较大的问题拆分成几个规模比较小的问题，再看看能不能用一些特殊的关联关系把这些小问题组合起来以便更快速地解决大问题。这种思路就是所谓\ :strong:`分治法`，是一种非常常用也非常有效的算法设计方法。

那么具体要怎么拆分指数才能达到目的呢？拆分的方法必须满足一个条件：能够让拆出来的各个小整数幂之间有简单的递推关系，也就是从一个可以推出另一个而且方法很简单，这样才能达到提高运算效率的关系，否则是没有用的。这时候就需要用到二进制来帮忙了，我们把指数从十进制转换为二进制，可以发现指数可以拆分成一系列2的幂只和。举个例子，十进制的13，转换成二进制就是(1101)\ :subscript:`2`。根据二进制数占位计数法的规则，它从高到低4个位的基数分别是2\ :superscript:`3`、2\ :superscript:`2`、2\ :superscript:`1`、2\ :superscript:`0`，这就意味着13可以拆分成1个2\ :superscript:`3`、1个2\ :superscript:`2`、0个2\ :superscript:`1`、1个2\ :superscript:`0`\ 之和：13=8+4+1。

如此，以13为指数的幂可以改写成：:math:`a^{13}=a^8 \times a^4 \times a^1`，为了看得更清楚，我们把指数写成二进制，并且用1来补上被丢弃的那一位：

.. math::

   a^{13}=a^{(1101)_2}=a^8\times a^4\times 1\times a^1=a^{1\times(1000)_2}\times a^{1\times(100)_2}\times a^{0\times(10)_2}\times a^{1\times(1)_2}

现在可以看出一点端倪来了，我们可以这样操作：先用一个变量来保存底数的1次方，也就是底数本身，我们称之为基数（base），然后定义一个变量来保存运算结果，由于是连乘运算所以肯定先初始化为1。接下来我们进行循环，每一轮循环时看指数的二进制数最低位是0还是1，0表示这一位的基数不需要乘到结果里去，结果不变，1表示这一位上的基数需要乘到结果里去，我们就在结果变量上乘上基数。做完一位之后，我们把指数的二进制形式右移一位（相当于除2），这样原先的次低位就移到了最低位上，同时我们把基数自乘一次成为对应原先指数次低位的基数，继续循环。直到指数右移为0，算法就结束了。

看不懂很正常，看一个具体的例子就懂了。让我们演示一下怎样用上述算法来计算\ :math:`3^{13}`。我们的基数变量叫做 ``base``，结果变量叫做 ``ans``，底数 ``a=3``，指数 ``n=13``。

.. csv-table::
   :header: "轮次", "n(2进制)", "base", "ans", "说明"
   :widths: 10, 10, 10, 10, 60

   "初始", "1101", "3", "1", "开始循环前，``ans`` 初始化为1, ``base`` 为底数3，对应3的1次方"
   "1","110","9","3","进入第1轮循环时指数最低位为1，表示结果要乘上基数3，然后指数右移一位变成110，基数自乘一次变成9，对应3的2次方"
   "2","11","81","3","进入第2轮循环时指数的最低位为0，表示结果不需要乘上对应的基数，然后指数右移一位变成11，基数自乘一次变成81，对应3的4次方"
   "3","1","6561","243","进入第3轮循环时指数的最低位为1，表示结果要乘上对应的基数81，然后指数右移一位变成1，基数自乘一次变成6561，对应3的8次方"
   "4","0","","1594323","进入第4轮循环时指数的最低位为1，表示结果要乘上对应的基数6561，然后指数右移一位变成0，下一次循环将不再继续，基数是否自乘已经不重要了"

至此，通过4轮循环，每一轮循环里最多2次乘法，完成了3的13次方的计算，结果正确。现在回过头去再看看上一段的算法描述，如果能看懂了，那么来看一下代码。




（待续）