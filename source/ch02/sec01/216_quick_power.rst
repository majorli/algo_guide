.. index:: 快速幂（整数）, 洛谷P1226

快速幂算法（整数快速幂）
+++++++++++++++++++++++++++++++++++++

整数快速幂算法（简称快速幂）是一个经典的数值运算算法，也是普及组的常考算法。它的功能就是快速计算整数的幂运算\ :math:`a^n`，:math:`a`\ 称为底数，:math:`n`\ 称为指数，指数大于等于零。根据数学定义，整数的幂运算就是将底数连乘指数次，另外有一个特例：任何数的0次幂都等于1。

.. math::

   a^n=\begin{cases}\underbrace{a\times\cdots\times a}_\text{n times}&, n\neq0\\1&, n=0\end{cases}

所以按照数学定义我们可以很简单地用一个循环来计算出整数的幂。

.. code-block:: c++

   int power(int a, int n)
   {
           if (n == 0) return 1;
   
           int ans = 1;
           for (int p = 0; p < n; p++)
                   ans *= a;
   
           return ans;
   }

除了数据类型 ``int`` 有点偏小以外，上面这段代码的正确性无懈可击，因为我们知道指数是一种增长速度快得可怕的运算，``int`` 类型整数的绝对值最大也不过\ :math:`2^{31}-1`\ ，大约21亿多，用来计算整数幂很可能一不留神就爆掉了。但是就算改成 ``long long`` 类型情况也好不到哪里去，如果换成 ``double`` 类型那么数据的精度又成了大问题。所以上面这个算法的一个小问题就是它很可能需要有\ :strong:`高精度整数运算`\ 算法的加持。

但是这不是最重要的，最重要的是上面这种朴素的算法在效率上非常堪忧。它需要着着实实地进行n次乘法计算，所以它的时间复杂度是\ :math:`O(n)`。鉴于计算机进行乘法运算本身就很费时，所以这样的运行效率并不能令人满意。假设用上了高精度乘法，那么这个朴素的算法就很费力了。这是它最大的问题所在，我们需要一种更优秀的算法，这就是经典的整数快速幂算法，效率高达\ :math:`O(\log n)`。


**快速幂算法的数学原理**

一切的一切来自于幂运算的一条基本性质：:math:`a^{b+c}=a^b\times a^c`。这条性质很好理解，:math:`a^{b+c}`\ 就是把底数\ :math:`a`\ 连乘\ :math:`(b+c)`\ 次，所以就是\ :math:`a`\ 连乘\ :math:`b`\ 次再乘以它连乘\ :math:`c`\ 次。

所以如果我们能把比较大的指数\ :math:`n`\ 拆成少量的几个小一点的整数之和，那么我们就可以设法把一个规模比较大的问题拆分成几个规模比较小的问题，再看看能不能用一些特殊的关联关系把这些小问题组合起来以便更快速地解决大问题。这种思路就是所谓\ :strong:`分治法`，是一种非常常用也非常有效的算法设计方法。

那么具体要怎么拆分指数才能达到目的呢？拆分的方法必须满足一个条件：能够让拆出来的各个小整数幂之间有简单的递推关系，也就是从一个可以推出另一个而且方法很简单，这样才能达到提高运算效率的关系，否则是没有用的。这时候就需要用到二进制来帮忙了，我们把指数从十进制转换为二进制，可以发现指数可以拆分成一系列2的幂只和。举个例子，十进制的13，转换成二进制就是(1101)\ :subscript:`2`。根据二进制数占位计数法的规则，它从高到低4个位的基数分别是2\ :superscript:`3`、2\ :superscript:`2`、2\ :superscript:`1`、2\ :superscript:`0`，这就意味着13可以拆分成1个2\ :superscript:`3`、1个2\ :superscript:`2`、0个2\ :superscript:`1`、1个2\ :superscript:`0`\ 之和：13=8+4+1。

如此，以13为指数的幂可以改写成：:math:`a^{13}=a^{1\times8} \times a^{1\times4} \times a^{0\times2} \times a^{1\times1}`，为了看得更清楚，我们把指数写成二进制：

.. math::

   a^{13}=a^{(1101)_2}=a^{1\times8} \times a^{1\times4} \times a^{0\times2} \times a^{1\times1}=a^{1\times(1000)_2}\times a^{1\times(100)_2}\times a^{0\times(10)_2}\times a^{1\times(1)_2}

现在可以看出一点端倪来了，只要把指数写成它的二进制形式，那么它的每一位都会对应一个基数，第m位的基数等于\ :math:`a^{2^{m-1}}`\ （最低位是第1位）。指数的二进制形式一共有几位，就有几个这样的基数。例如如果指数的二进制形式一共有4位，那么从最低位（第1位）到最高位（第4位）对应的基数分别为：:math:`a^1,a^2,a^4,a^8`。这些基数是不是要成为整个幂运算的因数，取决于二进制指数对应的位上是0还是1。

于是我们可以这样操作：从二进制指数的最低位开始到最高位逐位循环，第一轮的时候让基数等于底数本身，即最低位对应的\ :math:`a^1`\ 。每轮循环检查二进制指数的当前位上是不是1，如果是1就乘上基数。最后无论该位是0还是1，都把基数进行平方，让它成为下一轮循环的基数。这就是快速幂的基本思路，最差的情况下循环\ :math:`\log n`\ 轮，每轮循环进行两次整数乘法，时间函数\ :math:`T(n)=2\log n`，时间复杂度\ :math:`O(\log n)`。

在具体实现这个循环的时候，通常的做法是利用位运算来控制循环和取位：在每一次循环之后，把指数右移一位，这样下一轮循环要检查的位就移动到了最低位上，每一次循环只要固定地检查最低位就可以了。这样做同时带来一个便利，那就是循环结束条件可以设置为指数为0，当不断右移最终使得指数变成0的时候，说明最高位也已经检查掉了，循环可以结束了。

还有一个值得一提的地方，这样一个循环足以让所有零次幂得到正确的结果1，为什么？请大家自己思考。

先来看一个具体的例子，用上述算法来计算\ :math:`3^{13}`。我们的基数变量叫做 ``base``，结果变量叫做 ``ans``，底数 ``a=3``，指数 ``n=13``。

.. csv-table::
   :header: "轮次", "n(2进制)", "base", "ans", "说明"
   :widths: 10, 10, 10, 10, 60

   "初始", "1101", "3", "1", "开始循环前，ans初始化为1, base为底数3=3\ :superscript:`1`"
   "1", "1101", "3", "1", "进入第1轮循环时指数最低位为1，表示结果要乘上基数3，然后指数右移一位变成110，基数平方一次变成9=3\ :superscript:`2`"
   "2", "110", "9", "3", "进入第2轮循环时指数的最低位为0，表示结果不需要乘上基数，然后指数右移一位变成11，基数平方一次变成81=3\ :superscript:`4`"
   "3", "11", "81", "3", "进入第3轮循环时指数的最低位为1，表示结果要乘上基数81，然后指数右移一位变成1，基数平方一次变成6561=3\ :superscript:`8`"
   "4", "1", "6561", "243", "进入第4轮循环时指数的最低位为1，表示结果要乘上对应的基数6561，然后指数右移一位变成0，下一次循环将不再继续，基数是否平方已经不重要了"
   "结束", "0", "---", "1594323", "现在指数移成了0，循环结束，ans变量里就是最终的结果3\ :superscript:`13`\ =1594323"

至此，通过4轮循环，一共7次乘法，完成了3的13次方的计算，结果正确。现在回过头去再看看上一段的算法描述，如果能看懂，那么来看一下代码，请先回顾好C++按位运算的语法知识。

.. literalinclude:: ../../codes/216_quick_power.cpp
   :language: c++
   :emphasize-lines: 5-11

.. hint::

   这个算法非常优雅而且高效，上面是它最常见的一种C++语言实现，实际上它还可以有很多其他实现形式。例如对于不熟悉二进制位操作的人可能会习惯于用 ``n \= 2`` 来代替右移，用 ``if (n % 2)`` 来代替 ``if (n & 1)`` 检查最低位。循环也可以用 ``for`` 或者 ``do ... while`` 来实现。但是算法是不变的，要习惯于理解和记忆算法而不是具体的代码，因为代码是表象，它总是可以千变万化，而算法是精髓，它永远不变。作为对语言本身的练习，请大家至少用一种别的方式来实现一遍这个算法。

main函数中测试了几组幂运算，运行后得到的结果如下：

.. code-block:: none

   0^0 = 1
   3^0 = 1
   3^13 = 1594323
   -3^13 = -1594323
   -3^14 = 4782969
   2^62 = 4611686018427387904
   2^63 = -9223372036854775808

可以看到，2\ :superscript:`63`\ 的计算结果错误，这是因为它超过了 ``long long`` 数据类型的最大表示范围。普通的整数快速幂算法最大的问题就是很容易爆数据类型，因为指数运算的增长速度实在太过恐怖。所以在实际应用中，往往使用一种叫做\ :strong:`模m的整数幂`\ 的运算，也就是说要求的结果并不是\ :math:`a^n`\ ，而是它除以模m之后的余数\ :math:`a^n(\mod m)`\ ，其中\ :math:`m\ge2`\ 。这种运算就将结果限制在了0到m-1的范围之内。下面我们就来看看怎样实现这种“模m的整数幂”的快速幂算法。


模m的快速幂算法
^^^^^^^^^^^^^^^^

模m的整数幂在计算机安全、密码学等领域被广泛使用，是一种必须掌握的基本算法。



（待续）