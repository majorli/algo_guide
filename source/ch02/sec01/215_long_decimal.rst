超高精度有理小数
++++++++++++++++++++++

C++的浮点数精度有限，最低的 ``float`` 型单精度浮点数只有最多6位有效数字的精度，最常用的双精度浮点数 ``double`` 为15到16位，哪怕是高精度浮点数 ``long double`` 也只有19位精度。

.. caution::

   必须知道，描述C++浮点数精度时常说的多少多少位，是指有效数字的位数，从整数部分的最高位开始算，而不是小数点后面多少位！比如单精度浮点数 ``float f = 12345.67``，由于 ``float`` 类型最多只保证6位有效数字的精度，所以这个数的百分位上的7就已经不能保证准确了。


.. hint::

   C++浮点数和其他编程语言的浮点数都是采用的IEEE标准的单精度、双精度、高精度浮点数格式，并不是只有C++的浮点数才精度有限，所有语言都是一样的。事实上这样的精度用于科学计算一般来说是没有什么问题的，但是如果是用在金融领域等对小数精度要求特别高的场景里就往往不够用了。


有时候我们往往需要更加精确的小数表示，比如需要精确到小数点后面50位，这就需要我们自己编程来计算出所需的小数点后50位精确数值了。我们知道实数分为有理数和无理数两类，但由于受到存储空间的限制，在计算机里不可能真正表示无限小数。尽管可以保留非常非常多的位，但无论是无理数还是循环小数最终也只能限定在固定的位数之内。所以我们仅考虑有理小数的情况，而有理数一定可以表示成两个整数相除。所以我们的算法核心就是用整数除法和取余两个运算来模拟整数除法的笔算过程，具体来说就是竖式除法。

整数竖式除法是一种完善的循环算法，它的过程就是用除数去除被除数，得到一个商和一个余数，然后把余数乘以10作为新的被除数来重复上述过程，直至除尽（余数为0）或者达到所需的小数位数。通常如果达到所需的小数位数时还未除尽，那么需要再多算一位并从这一位上开始做四舍五入。四舍五入可能会向前传播，例如小数0.99999在最后一位上开始四舍五入后，会一路向前传播使得最终得到的结果成为1。

**不做四舍五入的情形**

（待续）