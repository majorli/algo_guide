超高精度有理小数
++++++++++++++++++++++

C++的浮点数精度有限，最低的 ``float`` 型单精度浮点数只有最多6位有效数字的精度，最常用的双精度浮点数 ``double`` 为15到16位，哪怕是高精度浮点数 ``long double`` 也只有19位精度。

.. caution::

   必须知道，描述C++浮点数精度时常说的多少多少位，是指有效数字的位数，从整数部分的最高位开始算，而不是小数点后面多少位！比如单精度浮点数 ``float f = 12345.67``，由于 ``float`` 类型最多只保证6位有效数字的精度，所以这个数的百分位上的7就已经不能保证准确了。


.. hint::

   C++浮点数和其他编程语言的浮点数都是采用的IEEE标准的单精度、双精度、高精度浮点数格式，并不是只有C++的浮点数才精度有限，所有语言都是一样的。事实上这样的精度用于科学计算一般来说是没有什么问题的，但是如果是用在金融领域等对小数精度要求特别高的场景里就往往不够用了。


有时候我们往往需要更加精确的小数表示，比如需要精确到小数点后面50位，这就需要我们自己编程来计算出所需的小数点后50位精确数值了。我们知道实数分为有理数和无理数两类，但由于受到存储空间的限制，在计算机里不可能真正表示无限小数。尽管可以保留非常非常多的位，但无论是无理数还是循环小数最终也只能限定在固定的位数之内。所以我们仅考虑有理小数的情况，而有理数一定可以表示成两个整数相除。所以我们的算法核心就是用整数除法和取余两个运算来模拟整数除法的笔算过程，具体来说就是竖式除法。

整数竖式除法是一种完善的循环算法，它的过程就是用除数去除被除数，得到一个商和一个余数，然后把余数乘以10作为新的被除数来重复上述过程，直至除尽（余数为0）或者达到所需的小数位数。通常如果达到所需的小数位数时还未除尽，那么需要再多算一位并从这一位上开始做四舍五入。四舍五入可能会向前传播，例如小数0.99999在最后一位上开始四舍五入后，会一路向前传播使得最终得到的结果成为1。


.. admonition:: 问题

   输入三个整数：\ :math:`-10^8\le a \le10^8,-10^8\le b \le10^8,0\le c \le 100,(b\neq0)`\ ，输出有理数\ :math:`a/b`\ 的小数形式，最多保留\ :math:`c`\ 位小数。例如：

   * 输入8, 5, 3，输出1.6
   * 输入8, -5, 0，输出-2
   * 输入-1, 7, 4，输出-0.1429
   * 输入-9, -3, 100，输出3


**结果如何表示？**

对于此问题所要求的结果，其整数部分可以用一次整型除法运算直接得到。小数部分需要模仿竖式除法逐次计算小数点后面的位，直到除尽或者达到所需要的位数。由于\ :math:`c\le100`，所以我们可以用一个长度为101的整型数组来保存结果。其中第0个元素用来保存结果的整数部分，从第1个开始的各个元素就用来存放小数点后对应位上的数字。

实际的结果可能在\ :math:`c`\ 位以内就除尽了，所以我们还需要一个整型变量来记录结果的实际小数位数。它可以从0开始，随着小数位的逐步计算而逐步累加。

又因为除数和被除数有正有负，所以结果也可能有正有负，所以我们还需要一个逻辑型变量来标示结果的正负。我们在输入结束后应该马上判断结果的正负，保存在这个变量里，然后把除数和被除数统一改为正数（或零）。这样我们在后面的计算中就不需要考虑正负的问题了，而计算得到的结果需要配合符号变量才是完整的。

.. admonition:: 思考

   这里为什么不把结果的正负表示在整数部分里，而要单独把符号作为一个逻辑变量另外保存呢？请想一想这个问题。

最后我们还需要一个整型的临时变量，用来在每一步计算的时候放置得到的余数，并且每次都乘以10以便用作下一位计算时的被除数。

现在就可以整理出为了表示算法的结果所需要的所有变量（包括一个中间变量）了。

.. code-block:: c++

   int digits[101], d = 0, r;   // d：实际的小数位数；r：临时变量，余数*10
   bool neg = (a < 0 && b > 0) || (a > 0 && b < 0);     // 结果是否为负


**算法的计算过程**

算法本质上是一个模拟算法，就是模拟整数的竖式除法。下面以能除尽和不能除尽两种情况为例，用图表来观察一下算法要做的计算过程。

.. image:: ../../images/215_decimal.png


但实际上四舍五入发生的时候，有可能不止影响到最后一个小数位，它可能会向前传播。

例如，:math:`198\div199\approx 0.99497...`，如果我们要求最多保留4位小数，那么在小数点后第4位上四舍五入后会继续向前进位，最终结果剩下3位小数，为0.995。

再如\ :math:`2018\div2019\approx 0.99950...`，如果我们要保留最多3位小数，那么四舍五入引发的向前进位会一直传播到整数部分，最终结果为1。

这是我们算法里在四舍五入时要考虑到的情况。舍入首先肯定是发生在当前最后一位，也就是第d位上的。舍入后要判断其是否大于9，如果是则说明要向前进位，这就需要把当前最后位改为0，然后把前面一位变成新的最后位，然后新的最后位加1，再判断是否需要继续向前进位......如此不断重复这一过程直至某次舍入之后不需要向前进位或一直推进到了整数部分。这和小学算术所学的四舍五入过程完全一致。


**代码及其改进**

经过上面的分析，应该不难写出实际的C++代码了。编写输出语句时要注意两处容易引起错误的地方。一是结果的正负不要忘记；二是如果结果是整数则不需要输出小数点。代码里没有加注释，请大家务必自己把这它读懂。


.. literalinclude:: ../../codes/215_long_decimal.cpp
   :language: c++


这个算法还有可以改进的地方吗？当然有。试想如果问题没有限定 :math:`c\le100` 呢？用静态的数组就很难确定应该开多大的长度了。


（待续）
