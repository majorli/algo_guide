
.. index:: 回文质数, USACO1.5, 洛谷P1217

回文质数（USACO1.5；洛谷P1217）
+++++++++++++++++++++++++++++++++++


**题目描述**

因为151既是一个回文数又是一个质数，所以称151是一个回文质数。

写一个程序来找出范围在 :math:`[a,b],(5\le a\lt b\le 100,000,000)` 之间的所有回文质数。

**输入格式**

第1行：二个整数，a和b。

**输出格式**

按从小到大的顺序输出一个回文质数的列表，一行一个。

**输入输出样例**

输入：

.. code-block:: none

   5 500

输出：

.. code-block:: none

   5
   7
   11
   101
   131
   151
   181
   191
   313
   353
   373
   383


朴素的算法
^^^^^^^^^^^^^^^^^^

遇到问题，一般总是先从最朴素的思路出发考虑如何解决。这个题最朴素的思路就是从最小值 :math:`a` 到最大值 :math:`b` 挨个儿把所有整数循环一遍，然后对每一个数判断它是否既是质数又是回文数。非常简单直接粗暴，这种思路一般叫做\ :strong:`枚举法`\ 或\ :strong:`暴力搜索`。

由于偶数不可能是质数，个位数为5的奇数除5以外也不可能是质数，所以我们只需要暴力搜索所有奇数，并且抛弃除了5以外那些个位数为5的数，这样可以节省一大半时间。同时因为偶数已经全部抛弃，所以在判断一个数是不是质数时，可以从3开始找它的因数，而不是从2开始，这样又可以稍微节省一丢丢的时间。下面我们把代码写出来，试着运行一下看看效果如何。

.. literalinclude:: ../../codes/214_p1217_NV.cpp
   :language: c++
   :emphasize-lines: 23

.. note::

   这个蛮力算法的程序其实没有什么可多解释的，非常简单直接。

   唯一值得一看的地方是函数 ``is_prime()`` 用了一点小技巧来使得代码更紧凑简洁。通常中规中矩的质数判断会在循环体中检查是否发现因数，一旦发现了一个因数就中断循环并返回false，否则直到循环结束后返回true。而这里我们换了一种写法，先预设一个逻辑型变量 ``prime`` 作为是否质数的标志，初始化它为true。然后在寻找因数时，我们利用C++语言把0视为false、非0视为true的特点，用余数去直接赋值它。如果余数为0，说明找到了一个因数，这会使 ``prime`` 被赋值为false；如果余数不为0则恰好相反。然后我们把这个赋值表达式直接用在循环条件里，使得一旦这个标志成为false，循环就会中止。如果一直找不到因数，那么它就会始终保持为true。于是循环体里面就不需要做任何事情了，该做的事情在判断循环条件时就一并做完了，空循环足矣。最终我们只要返回这个 ``prime`` 的值就可以了。

   如果你看到这里还不明白这个小技巧的运行原理，我建议找几个小一点的奇数在纸面上自己模拟运行一下看看，把这个小技巧搞懂。如果你对这种小技巧不感兴趣，你也完全可以忽视它，就用中规中矩的方式写程序。这并没有什么实质性的区别。


如果测量一下这个程序的运行时间，我们发现当数据范围在5到1,000,000（一百万）的时候，它大概要运行250ms的样子，在可以接受的“秒答”范围内。当数据范围扩大到5到3,000,000（三百万）时，它大概率就要运行1秒以上才能结束了。当数据范围扩大到5到10,000,000（一千万）时，它大概要运行6400ms左右，远远超出了算法竞赛所要求的一秒以内的要求。而当数据范围扩大到题目所给出的最大可能范围5到100,000,000（一亿）时它竟然运行了近170秒！

暴力搜索有三大特点：思路简单、程序不易错、运行常超时。而常超时这个大缺点彻底掩盖了简单和不易错两个优点，使得在算法编程中往往不能采用这种方法。这也促使我们要不断设法改进思路，设计出更加精妙的高性能算法。但是那样的算法也一定更加复杂和难懂。


从质数中找回文数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



朴素算法的改进版
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



从回文数中找质数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^




