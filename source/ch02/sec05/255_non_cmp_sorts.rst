非比较型排序算法
++++++++++++++++++++++++++++++

本节介绍三种经典的\ :strong:`非比较型排序`\ 算法：\ :strong:`计数排序`、\ :strong:`桶排序`\ 和\ :strong:`基数排序`。

所谓非比较型排序算法就是指不使用元素之间的比较运算来实现的排序算法。非比较型排序算法一般使用范围有限，对数据类型、取值范围、数据量、数据分布规律等都有一些特殊要求，符合这些特定要求的情况才能适用。但是这些算法在满足各自特定条件的时候往往会速度非常快，实际的效果超过快速排序等最快的比较型排序算法。

非比较型排序的设计思想往往是紧扣特定条件，充分利用特殊数据的特殊性质的精巧构思。相比于实际应用，学习它们的算法设计思想更为重要。在算法竞赛的编程环节中一般很少遇到非要使用这些算法的题目，但是在笔试环节却经常会考到此类排序算法或者它们的变种。所以本节将重点针对它们的设计思路进行介绍，实际编程留作练习。

计数排序
^^^^^^^^^^^^^^^^

:strong:`计数排序`\ 是基于“出现次数”统计的一种排序算法。如果待排序序列中的数据是一个有限集合的元素，理论上就可以使用计数排序算法。

最天然的有限集合是有取值范围的整数，例如0到100之间的整数。但是0到100之间的实数就不是有限集合。再如中国所有城市的名称是一个字符串型的有限集合，但中国人所有可能的姓名就是不是一个有限集合。计数排序最常见的应用场景是对1000以内的自然数序列进行排序，排序速度接近于线性。

以对 :math:`K` 以内的自然数序列进行排序为例，待排序序列为 :math:`A`，长度为 :math:`n`，任一元素都满足 :math:`0\le A[i]\lt K`。这时我们可以申请一个长度为 :math:`K` 的整型数组 :math:`C`，用于给序列中的元素进行计数。对于 :math:`0\le j\lt K`，:math:`C[j]` 表示值为 :math:`j` 的元素出现的个数。所以初始化的时候我们让 :math:`C` 的所有值都等于0，然后从头到尾遍历每一个待排序序列中的元素，每遍历一个元素 :math:`A[i]` 就把它对应的计数值 :math:`C[A[i]]` 增1。:math:`A` 中所有元素遍历结束计数也就完成了。接下来我们再从头到尾遍历 :math:`C` 中的每一个计数值，按照每一个计数值将对应的元素值依次写回到原序列中就完成了排序。

例如我们对10以内的8个自然数的数组 A: [5, 3, 2, 7, 3, 9, 1, 7] 进行计数排序。我们需要开一个长度为10的数组 C，排序过程如下：

.. code-block:: none

   1、计数过程，从 A[0] 到 A[7] 依次遍历每一个元素值并进行计数: ++C[A[i]]

   A: [5, 3, 2, 7, 3, 9, 1, 7]  ==> C: [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]
       ^                                               ^
   A: [5, 3, 2, 7, 3, 9, 1, 7]  ==> C: [0, 0, 0, 1, 0, 1, 0, 0, 0, 0]
          ^                                      ^
   A: [5, 3, 2, 7, 3, 9, 1, 7]  ==> C: [0, 0, 1, 1, 0, 1, 0, 0, 0, 0]
             ^                                ^
   A: [5, 3, 2, 7, 3, 9, 1, 7]  ==> C: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0]
                ^                                            ^
   A: [5, 3, 2, 7, 3, 9, 1, 7]  ==> C: [0, 0, 1, 2, 0, 1, 0, 1, 0, 0]
                   ^                             ^
   A: [5, 3, 2, 7, 3, 9, 1, 7]  ==> C: [0, 0, 1, 2, 0, 1, 0, 1, 0, 1]
                      ^                                            ^
   A: [5, 3, 2, 7, 3, 9, 1, 7]  ==> C: [0, 1, 1, 2, 0, 1, 0, 1, 0, 1]
                         ^                 ^
   A: [5, 3, 2, 7, 3, 9, 1, 7]  ==> C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1]
                            ^                                ^
   2、回写过程，从 C[0] 到 C[9] 依次遍历每一个计数值并将对应值回写到原数组

   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [] 值0没有出现过，不回写
       ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1] 值1出现1次，回写1个1
          ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1, 2] 值2出现1次，回写1个2
             ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1, 2, 3, 3] 值3出现2次，回写2个3
                ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1, 2, 3, 3] 值4没有出现过，不回写
                   ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1, 2, 3, 3, 5] 值5出现1次，回写1个5
                      ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1, 2, 3, 3, 5] 值6没有出现，不回写
                         ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1, 2, 3, 3, 5, 7, 7] 值7出现2次，回写2个7
                            ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1, 2, 3, 3, 5, 7, 7] 值8没有出现，不回写
                               ^
   C: [0, 1, 1, 2, 0, 1, 0, 2, 0, 1] ==> A: [1, 2, 3, 3, 5, 7, 7, 9] 值9出现1次，回写1个9
                                  ^
   排序完成。

可见计数排序的思路非常简单，如果是对一定范围内的自然数进行编程也是非常方便的，因为元素值刚好可以构成从小到大的计数数组下标值。如果元素取值范围不是一定范围内的自然数，就需要将元素值和计数数组的下标值做一一对映。注意对映的规则要确保计数数组的下标对应的元素值是有序的。例如要排序的数据取值范围为从-100到100的整数，包括-100和100两个端点，一共201个可能值。那么我们一般就需要把-100对应为计数数组的 :math:`C[0]` 元素，把100对映为 :math:`C[200]`，中间的值保持有序地对映，可以总结为这样一条规律：元素值 :math:`j` 的计数值对映到 :math:`C[j+100]`。

.. admonition:: 练习

   编写一个对 :math:`n` 个奇数进行计数排序的程序，:math:`0\lt n \lt 100000`。所有奇数保证大于等于-199且小于等于401。

   输入两行，第一行一个整数 :math:`n`，第二行为 :math:`n` 个奇数 :math:`a_i`。

   输出一行，为排好序的 :math:`n` 个奇数，每两个数之间用一个空格隔开，行首和行尾不能有空格。

计数排序无所谓稳定不稳定，因为它很难实现对复杂结构数据的排序，也很难适应多关键字的排序。

它的空间复杂度为 :math:`O(K)`，有些时候计数过程结束后并不把数据回写到原数组，而是另外存储的，那么空间复杂度为 :math:`O(n+K)`。

以读写数据元素为基本运算，计数排序的计数过程遍历所有待排序数据，共 :math:`n` 个元素，回写排序过程遍历整个计数数组，共 :math:`K` 个元素，故时间复杂度为 :math:`O(n+K)`。

当 :math:`K` 过大时，无论空间还是时间都会变得很大，尤其是空间占用会变得难以承受。比如要对long long型取值范围内的整数排序，:math:`K=2^{64}`，计数数组占用的空间至少为 :math:`2^{52}` (TB)，恐怕全中国的计算机内存加起来也没有那么大。一般来说，计数排序适用于 :math:`K` 在万级以内的场景，一千以内效果最佳。

最后是一个必须要澄清的问题，时间复杂度 :math:`O(n+K)` 是什么级别？很多网站和教程上说是“线性”，是吗？错！按照正规的算法理论，这是\ :strong:`指数`\ 级！

.. warning::

   再次强调：按照正规的算法理论，数据规模的大小以占用多少个二进制位(bit)为单位，而不是数据的个数。凡是在数据规模中有涉及到数据的“值”的，例如这里的 :math:`K` 不是数据的数量而是其取值范围，就应视为指数级 :math:`2^L`，其中 :math:`L` 为数值 :math:`K` 的二进制位数。

对于一定的数据类型，比如int，每一个int型数据占用32个bits，输入 :math:`n` 个这样的数就占用 :math:`32n` 个bits，因此对应的数据规模实际上是 :math:`32n`。在衡量时间复杂度时，这样的常数系数会被略去，例如 :math:`O(32n)` 就是 :math:`O(n)`，:math:`O\bigl((32n)^2\bigr)=O(1024n^2)=O(n^2)`，:math:`O(\log{32n})=O(\log{32}+\log n)=O(\log n)`，如此而已。

但若是表示数据的值，情况就和数据数量不同了。例如这里的 :math:`K` 表示数据可能的取值有多少种，它表示的数据规模其实是它的二进制位数 :math:`L`，随着 :math:`L` 的增加，:math:`K` 以指数级增长。每当 :math:`L` 增加1，:math:`K` 的值就会翻倍。如果 :math:`L=10`，表示数据的值最多有1024种，如果增长1位，:math:`L=11`，数据的值就变成最多有2048种，这是指数型增长！

很多人误以为计数排序这样的 :math:`O(n+K)` 是线性时间，主要是因为把随着 :math:`L` 呈 :math:`2^L` 指数型增长误以为是随着 :math:`K` 呈线性增长。只看到了表面的 :math:`K` 而没有看到背后隐藏的 :math:`K=2^L`。事实上这个增长是很厉害的，只是大家没有机会看到所以才会误以为 :math:`O(n+K)` 是很高的效率。

假如我们真的有足够的内存开辟出一个长度为 :math:`2^{64}` 的数组来对long long型数据进行计数，那么最后的回写排序循环将会慢到天荒地老，大家在Hanoi塔问题里已经见识过 :math:`2^{64}` 这个数的可怕了吧？现在即便是从头到尾遍历一遍，哪怕用亿次以上的超算级别的计算机，恐怕没有一两百年也结束不了。如果 :math:`K` 达到128位的规模，那么按照密码学家最近的估计，哪怕把全世界所有计算资源，小到手机大到超算全部集中起来用于枚举，也需要超过宇宙寿命的时间才能枚举完！


桶排序
^^^^^^^^^^^^^^^^




基数排序
^^^^^^^^^^^^^^^^


