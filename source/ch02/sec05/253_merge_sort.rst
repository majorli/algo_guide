归并排序
++++++++++++++++

:strong:`归并排序`\ 是一种利用递归的思路设计的快速排序算法。归并排序的时间复杂度为 :math:`O(n\log n)`，达到了理论上的时间复杂度下限。但它并不是速度最快的排序算法，快速排序、堆排序在平均情况下的实际运行速度都比归并排序要略快一些。然而归并排序在实际应用中是用途非常广泛非常实用的高速排序算法，原因有三：

1. 归并排序的表现极其稳定，不受原序列有序程度的影响，对它来说没有什么最好情况、最差情况或者平均情况，一律是 :math:`O(n\log n)` 时间效率。
2. 归并排序适用于外部排序，例如存放在海量存储设备中的超大型数据库排序，基本上就是用的归并排序算法的外排序版本，而快速排序和堆排序都不太适合改造成外排序版本。
3. 归并排序的编程非常简单，只要会归并过程就可以轻松写出一个正确的归并排序来（关于归并过程，请参考3.4.10.1小节）。

归并排序是一种稳定的排序算法，它的缺点是有较大的内存空间使用，但是在算法竞赛问题中一般空间不太成为大问题。所以归并排序无论在算法竞赛问题中，还是在实践应用中都是非常重要的一种排序算法。


**归并排序的原理和实现**

归并排序的算法思路起源于对两个有序序列的归并过程的利用。假设要排序的序列可以分为前后两个部分，这两个部分各自都是有序的，例如整数序列 [1,3,4,5,1,2,6,7]，它的前4个数的子序列 [1,3,4,5] 和后4个数的子序列 [1,2,6,7] 各自都是有序子序列。那么对这个序列的排序就变得非常简单，只要用一次归并过程把前后两个有序子序列归并起来就可以了，这个过程是 :math:`O(n)` 时间的。

当然，在实际编程中，要原地归并前后两个子序列不是不可以，但是过程会比较复杂。所以编程的时候采用新开辟一块空间用作临时数组，把两个子序列归并到这个临时数组里面去，归并完成后再把这个临时数组里已经有序的新序列复制回原数组的方法。这个过程利用C++语言的动态内存管理功能和块复制功能可以轻松的实现。

以整数排序为例，例如我们要归并一个数组中指定的两个连续的有序子序列，原数组为 ``d[]``，要归并的两个连续子序列用三个位置变量 ``l, r, mid`` 表示，分别为含头不含尾的区域 ``[l, mid)`` 和 ``[mid, r)``，即前一子序列从 ``d[l]`` 到 ``d[mid-1]``，后一子序列从 ``d[mid]`` 到 ``d[r-1]``。

.. attention::

   计算机编程时遇到表示一个范围，一定要记住遵循“含头不含尾”的原则，相当于数学上的左闭右开区间。无论今后用什么语言编程，这是一个惯例。

我们可以先编写一个工具函数，用来实现上述的归并过程。在这个函数里，要用到C++动态内存管理功能和cstring库提供的内存块复制功能。对内存块操作不熟悉的可以回顾一下2.3节的内容，对C++动态内存管理不熟悉的请先回顾2.5节，若是归并过程也忘了的话，请复习3.4.10节。下面我们就直接给出数组中两个连续的有序子序列的归并过程工具函数：

.. literalinclude:: ../../codes/253_merge_sort.cpp
   :language: c++
   :lines: 1-3, 10-12, 51-76

虽然不能寄希望于待排序的原序列总是可以分为前后两个有序子序列，但是至少我们现在可以这样想，假如有办法把原序列一分为二，然后分别先对前后两个子序列进行排序，这样我们不就可以在前后都排序完成后，一次归并把整个序列变成有序的了吗？这就是归并排序的基本思路。

二分序列很简单，只要算出中间位置就可以了。问题是用什么方法对前后两个子序列分别排序呢？如果用插入排序，那么前后两次的排序时间都是 :math:`O(n^2)`，整个归并排序的时间复杂度也被限制在了 :math:`O(n^2)` 了，这样做毫无意义。所以不能简单地利用其他排序方法来做这件事情，这里我们要借助递归的思路。基本的思想就是把原序列分成前后两半，分别对它们进行同样方法的排序。即在对前一半进行排序的时候，仍然将其分为前后两半，分别进行同样的排序。对后一半的排序也一样，对第二次细分出来的四个子序列也一样。这就构成了一个递归的过程，只要这个过程总有一天可以有一种特殊情况使得其不需要再进一步二分递归下去，可以直接返回结果，那么这个递归就可行。

幸运的是，我们知道如果一个子序列已经被细分到只剩一个元素了，那么单个元素天生有序，它就不需要再进一步递归地去排序了，我们直接不去处理它就可以了。这个就是上述递归的二分归并排序的终止条件。现在我们就可以写出归并排序的算法结构了，:math:`A` 为要排序的序列，:math:`l,r` 分别为序列中要排序部分的左右端点位置，按照含头不含尾的原则，表示要对范围 :math:`[l, r)` 区间内的元素 :math:`A[l],\dots,A[r-1` 进行排序：

.. admonition:: 归并排序算法

   :math:`\text{MergeSort}(A, l, r):`

      :math:`mid\leftarrow\lfloor(l+r)/2\rfloor`

      :math:`\text{IF  }mid-l\gt1\text{  THEN  MergeSort}(A, l, mid)`

      :math:`\text{IF  }r-mid\gt1\text{  THEN  MergeSort}(A, mid, r)`

      :math:`\text{Merge}(A, l, r, mid)`

其中的子算法 :math:`\text{Merge}(A, l, r, mid)` 前面已经完成了代码编写，即归并过程的工具函数，所以编写这个程序就非常简单了吧。在编写代码之前，为了加深对递归过程的直观理解，我们先来看一个简单的实例，假设我们要对序列 [3, 2, 9, 1] 进行排序。

原序列长度为4，故分为 [3, 2] 和 [9, 1] 两个子序列并先后递归进行排序再进行归并
   
1. 归并排序 [3, 2]，其长度为2，故分为 [3] 和 [2] 两个子序列并先后递归进行排序再进行归并

   1. 归并排序 [3]，其长度为1，不做任何处理即结束
   2. 归并排序 [2]，其长度为1，不做任何处理即结束
   3. 归并 [3] 和 [2]，得到子序列 [2, 3]
   
2. 归并排序 [9, 1]，其长度为2，故分为 [9] 和 [1] 两个子序列并先后递归进行排序再进行归并

   1. 归并排序 [9]，其长度为1，不做任何处理即结束
   2. 归并排序 [1]，其长度为1，不做任何处理即结束
   3. 归并 [9] 和 [1]，得到子序列 [1, 9]
   
3. 归并 [2, 3] 和 [1, 9]，得到 [1, 2, 3, 9]

至此排序完成。对于长度不是2的幂次方的序列，其排序过程也是一样的，无非有些时候不同分支的结束情况会不同，这并不影响排序过程。例如对序列 [3, 2, 9, 1, 4] 进行排序：

原序列长度为5，按照除2取整得到的二分点为2，即分为 [3, 2] 和 [9, 1, 4] 两个子序列，先后递归排序再进行归并

1. 归并排序 [3, 2]，其长度为2，故分为 [3] 和 [2] 两个子序列并先后递归进行排序再进行归并

   1. 归并排序 [3]，其长度为1，不做任何处理即结束
   2. 归并排序 [2]，其长度为1，不做任何处理即结束
   3. 归并 [3] 和 [2]，得到子序列 [2, 3]
   
2. 归并排序 [9, 1, 4]，其长度为3，故被分为 [9] 和 [1, 4] 两个子序列并先后递归进行排序再进行归并

   1. 归并排序 [9]，其长度为1，不做任何处理即结束
   2. 归并排序 [1, 4]，其长度为2，分为 [1] 和 [4] 两个子序列先后进行递归排序再进行归并

      1. 归并排序 [1]，其长度为1，不做任何处理即结束
      2. 归并排序 [4]，其长度为1，不做任何处理即结束
      3. 归并 [1] 和 [4]，得到子序列 [1, 4]

   3. 归并 [9] 和 [1, 4]，得到子序列 [1, 4, 9]

3. 归并 [2, 3] 和 [1, 4, 9]，得到 [1, 2, 3, 4, 9]

归并结束。

下面是归并排序的代码：

.. literalinclude:: ../../codes/253_merge_sort.cpp
   :language: c++

在许多算法书中归并排序的主函数会用另一种写法：

.. code-block:: c++

   void merge_sort(int d[], int l, int r)
   {
           if (r - l == 1) return;
           int mid = (l + r) / 2;
           merge_sort(d, l, mid);
           merge_sort(d, mid, r);
           merge(d, l, r, mid);
   }

这两种写法本质上是一样的，你能看明白吗？

**归并排序算法分析**

归并排序在每一次归并的时候，会用到和被归并部分长度相等的临时空间。但是每次归并结束后这些空间会被释放，所以临时空间的占用不用积累，最大的时候等于原序列所占的空间，即最后一次归并的时候。所以归并排序的空间复杂度为 :math:`O(n)`。

从归并排序的过程可以看出，它对原序列中元素的有序程度完全没有感觉。无论原序列中的元素是不是有序、逆序，也不管其有序程度多大，算法总是不管不顾地进行不断二分不断归并，一次不会多一次不会少。因此归并排序的时间复杂度任何情况下都是一样的，无所谓最好、最差还是平均情况。

归并排序是一个非常典型的简单递归算法，其工作量可以用一个递推公式来表示。从算法的主过程可以看出，工作分为三部分，两次二分的递归调用和一次归并，递归的工作量各为原工作量的一半，归并的工作量为最多 :math:`n` 次元素比较。所以如果假设整个排序过程的工作量为 :math:`T(n)`，那么就有：

.. math::

   T(n)=2T({n\over2})+n,T(1)=0

可以用迭代法，也可以用递归树的方法来求解这个递推方程。这里不需要考虑数据量 :math:`n` 的取值情况，只需要假设它是2的幂次方就可以了，即假设 :math:`n=2^k`，也就是说 :math:`k=\log n`。对于不是2的幂次方的情况，我们在计算时间复杂度时就取恰好比它大的那个2的幂次方作为上界，比如对于 :math:`n=6`，我们可以取 :math:`n=8` 的情况作为它的上界，这并不会对结果的阶造成影响。

对所有基于二分的算法进行时间复杂度分析时，都可以这样只考虑 :math:`n=2^k` 的情况。用迭代法计算如下：

.. math::

   \begin{align}
   T(n)&=T(2^k)=2T({n\over2})+n=2T(2^{k-1})+n\\
       &=2[2T(2^{k-2})+{n\over2}]+n=2^2T(2^{k-2})+2n\\
       &=2^2[2T(2^{k-3})+{n\over4}]+2n=2^3T(2^{k-3})+3n\\
       &=\cdots\\
       &=2^kT(1)+kn=kn\\
   \therefore T(n)&=n\log n
   \end{align}

作为练习，大家可以试着用画递归树的方法来解一解这个递推方程。

最后要说明的是，归并排序是稳定的排序算法。为什么？还是请大家自己去思考。

