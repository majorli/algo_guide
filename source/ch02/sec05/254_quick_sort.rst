快速排序
++++++++++++++++

:strong:`快速排序`，简称\ :strong:`快排`，简单粗暴的算法名称彰显了目前为止人类所发明的最快的排序算法的霸气。快速排序是目前实际应用中速度最快的排序算法，它是一种不稳定的排序算法，实际应用中大量使用优化过的快排算法来进行不稳定排序，大多数编程语言内置的排序功能，比如C++语言algorithm库中的 ``sort()`` 函数、Java语言的容器排序方法等，都是基于快排的优化排序算法。

快速排序基于递归分区的思想进行设计，其基本思想分为三步：

1. 在待排序的序列中选出一个元素作为\ :strong:`基准(pivot)`；
2. 对序列进行分区，将小于基准值的元素分在左半边，大于基准值的元素全部分在右半边，基准值在中间，至于等于基准值的元素，放在左边还是右边都没有关系；
3. 分别对分区后形成的左半边和右半边再递归进行分区，直到分区的长度为1为止。

序列分区方法
^^^^^^^^^^^^^^^^

可见快速排序的关键步骤是对一段序列进行分区。由于上述第2步中对于那些等于基准值的元素到底放哪一边是无所谓的，导致在现实中存在很多种不同版本的分区代码写法。其实这些写法实际效果都是一样的，只要在分区之后，序列以某一个位置为界，此元素的值等于基准值，它之前的所有元素都小于等于基准值，它之后的元素都大于等于基准值就可以了。

网上介绍最多的是一种版本是选择待分区序列的第一个元素为基准，从两头开始向中间逐个比较元素，先从后向前找第一个小于基准值的元素将其放到前面，然后从前向后找第一个比基准值大的元素将其放到后面，不断循环这个过程直到前后两个位置交错了整个过程就结束了，最后把基准值插到中间交错的地方就可以了。这种方法是网上流传最广的方法，有许多的网页在详解这个分区过程，许多初级算法教材也用这种方法进行分区，大家可以自己去搜索相关资料学习。

前面这种分区方法虽然不是很难但是也不算简单，要理解它的原理不难，但是要准确地写出正确代码来却不是很容易，它对于两个哨兵位置的控制很精细，不容易一下子完全写对，而且不容易记住。另一个问题是代码需要在一个大循环内部嵌套两个小循环，小循环之外还可能要进行一些判断（有些写法需要，有些写法不需要）。最后一个问题，根据内部两个哨兵判断条件的不同，可以进行大于小于的判断，也可以进行大于等于或小于等于的判断，造成这种方法的写法纷繁复杂，在网上搜索，四篇文章里可能会出现四种不同的写法，给初学者造成很大困扰。

所以我们在这里将介绍另一种分区方法，来自被奉为经典的《算法导论》一书中使用的分区方法。这种方法画风就完全不同了，它只用一个从头到尾遍历每一个元素的循环来进行分区，没有前后的哨兵，没有嵌套的循环，思路和代码都相对简单，容易理解和记忆。要知道分支和判断都是开销比较大的结构，少用它们就能让代码的运行效率有所提高。而且《算法导论》这本书相当专业，不太适合中小学阶段的算法初学者，所以在教学网站、教材上都鲜有介绍这种分区方法的。因此我们特意把它拿出来，请大家学习记住这种方法。

.. warning::

   如果大家试着去看过《算法导论》，或者在网站上看过对该书中快速排序算法的解读，会发现在《算法导论》中所有的序列都是从1开始计数的。这是因为这本书是脱离开任何具体的编程语言而讲解纯粹的算法的，书中没有任何具体的程序，都是高度抽象的。但是我们在初学算法的时候使用C++语言，所以要改成符合C++习惯的从0开始计数，序列范围用含头不含尾规则来表示。

设序列为 :math:`A`，要分区的子序列范围为 :math:`[l, r)`，即从 :math:`A[l]` 到 :math:`A[r-1]`。我们将使用子序列的最后一个元素 :math:`A[r-1]` 为基准值，令 :math:`pivot\leftarrow A[r-1]`。然后我们将把范围 :math:`[l, r-1)` 划分为三段，第一段的范围为 :math:`[l, i)`，里面的元素都是小于基准值的，第二段的范围为 :math:`[i, j)`，里面的元素都是大于基准值的，第三段的范围为 :math:`[j, r-1)`，里面是还没有完成分区的元素。

初始的时候，因为还没有进行过分区，所以范围 :math:`[l, r-1)` 内的所有元素都属于第三段，因此我们初始化 :math:`i=j=l`，这样第一段的范围为 :math:`[l, i)=[l, l)` 即是一个元素都没有，第二段的范围为 :math:`[i, j)=[l, l)`，同样也是空的，而第三段的范围为 :math:`[j, r-1)=[l, r-1)` 就是所有待分区的元素。初始的状态如下图：

.. image:: ../../images/254_qsort_1.png

接下来使用位置 :math:`j` 从头到尾逐个将每一个元素和基准值 :math:`pivot` 进行比较，直到 :math:`j=r-2` 即元素 :math:`A[r-2]` 为止，逐步建立起正确的第一段和第二段。在此过程中的处理方法很简单，假设在某一步已经建立了如下图所示的三段，蓝色为小于基准值的第一段，红色为大于等于基准值的第二段，淡灰色为尚待处理的第三段：

.. image:: ../../images/254_qsort_2.png

下一步要处理的是当前 :math:`j` 所指向的元素 :math:`A[j]`。先看 :math:`A[j]\ge pivot` 的情况，这种情况下，:math:`A[j]` 应该放在第二段中，所以这时什么都不需要做，继续下一个元素的判断即可。结果如下图：

.. image:: ../../images/254_qsort_3.png

假如 :math:`A[j]\lt pivot`，那么要把 :math:`A[j]` 的值放到第一段中去。观察上面的图可以发现，受益于含头不含尾的规则，此时第一段的右端点位置 :math:`i` 恰好值向着第二段的第一个元素，所以我们只要交换 :math:`A[i]` 和 :math:`A[j]` 的值，并且把 :math:`i` 移动到下一个位置就可以继续下一个元素的判断了。结果如下图：

.. image:: ../../images/254_qsort_4.png

上述这个过程循环下去，直到最后一个元素 :math:`A[r-2]` 处理完毕，这时候的情况应该如下图所示：

.. image:: ../../images/254_qsort_5.png

最后要把 :math:`pivot` 这个值插入到两段中间去，可以发现这时候正好 :math:`A[j]=pivot`，而且 :math:`i` 正好指向第二段的第一个元素。所以很简单地，让 :math:`A[r-1]\leftarrow A[i]`，然后让 :math:`A[i]\leftarrow pivot` 就可以了。真个分区过程至此结束，结果如下图：

.. image:: ../../images/254_qsort_6.png

.. tip::

   处理刚开始的时候，把 :math:`A[r-1]` 的值作为基准值暂存在了临时变量 :math:`pivot` 中，所以在分区处理过程中出现要交换元素值的时候，:math:`A[r-1]` 可以直接用做交换值的中间变量，真是便利啊！

记住，分区结束后，要把基准元素最后所在的位置作为返回值返回出去，这个方法的返回值就是 :math:`i` 的值。

光看上面这样的描述可能还是有点糊涂，让我们来看一看《算法导论》书中给出的一个实例，给整数序列 [2, 8, 7, 1, 3, 5, 6, 4] 进行分区。

.. code-block:: none

   1: 初始状态：
        j
        v
    [|| 2  8  7  1  3  5  6 | 4 ]
        ^
        i
   2: 第1次比较，A[j] < pivot，所以交换 A[i] 和 A[j]，并 ++i，然后 ++j 进入下一轮
           j
           v
    [ 2 || 8  7  1  3  5  6 | 4 ]
           ^
           i
   3: 第2次比较，A[j] >= pivot，所以什么都不做，直接 ++j 进入下一轮
              j
              v
    [ 2 | 8 | 7  1  3  5  6 | 4 ]
          ^
          i
   4: 第3次比较，A[j] >= pivot，所以什么都不做，直接 ++j 进入下一轮
                 j
                 v
    [ 2 | 8  7 | 1  3  5  6 | 4 ]
          ^
          i
   5: 第4次比较，A[j] < pivot，所以交换 A[i] 和 A[j]，并 ++i，然后 ++j 进入下一轮
                    j
                    v
    [ 2  1 | 7  8 | 3  5  6 | 4 ]
             ^
             i
   6: 第5次比较，A[j] < pivot，所以交换 A[i] 和 A[j]，并 ++i，然后 ++j 进入下一轮
                       j
                       v
    [ 2  1  3 | 8  7 | 5  6 | 4 ]
                ^
                i
   7: 第6次比较，A[j] >= pivot，所以什么都不做，直接 ++j 进入下一轮
                          j
                          v
    [ 2  1  3 | 8  7  5 | 6 | 4 ]
                ^
                i
   8: 第7次比较，A[j] >= pivot，所以什么都不做，直接 ++j 进入下一轮
                             j
                             v
    [ 2  1  3 | 8  7  5  6 | 4 ]
                ^
                i
   9. 至此 j 抵达最后一个位置，比较结束，将 A[i] 值填入 A[j]，pivot 的值填入 A[i]
                             j
                             v
    [ 2  1  3 | 4 | 7  5  6  8 ]
                ^
                i
   10. 分区结束，返回位置 i

从上面的示例可以看出：

1. 假设待分区序列一共有 :math:`k` 个元素，那么总共需要进行元素比较 :math:`k-1` 次，属于 :math:`O(k)` 时间。
2. 位置 :math:`i` 从 :math:`l` 开始，每发生一次元素交换，就增加1，所以整个分区过程中总共需要进行的元素交换次数等于 :math:`i-j`，即分区后基准值所在位置位于整个序列中的相对位置。
3. 当待分区序列本身严格增序的时候，例如 [1,2,3,4,5] 这样的序列，每一次元素比较都是 :math:`A[j]\lt pivot`，所以每次比较都会造成元素交换，共交换 :math:`n-1` 次，这是效率最低的情况。
4. 当待分区序列逆序（并不需要严格逆序）的时候，每一次元素比较都是 :math:`A[j]\ge pivot` 的情况，所以不会产生元素交换，这是分区效率最高的情况。
5. 当待分区序列严格增序或者逆序（并不需要严格逆序）的时候，划分出的左右两个区域有一个分区长度为0，另一个长度为 :math:`n-1`，基准值元素位于序列的头部或尾部。

上述分区过程可以写成一个工具函数，用以今后在快排主函数中调用：

.. literalinclude:: ../../codes/254_quick_sort.cpp
   :language: c++
   :lines: 1-2, 5-6, 20-33


快速排序的实现和分析
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

有了



快排的最好情况和平均情况时间复杂度都是 :math:`O(n\log n)`，而且它的实际工作量比其他 :math:`O(n\log n)` 排序算法（归并、堆排）要小，运行速度是最快的。快排有最差情况，出现在待排序序列本身已经有序时，此时快排会退化成冒泡排序或者选择排序，时间复杂度为 :math:`O(n^2)`。但是除了一些故意恶心人的算法竞赛题以外，实际应用中很少出现把一个已经排好序的序列拿来用快速排序再排一次的情况，所以快速排序是实际应用中速度最快的排序算法，被广泛使用。

