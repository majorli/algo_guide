插入排序
++++++++++++++++

:strong:`插入排序`\ 的算法思路就不像冒泡和选择排序这样简单粗暴了，但是也很容易理解，它的思路来源于扑克牌游戏。玩过扑克牌的人都知道，在发牌阶段大多数人都会随时整理好手里的牌。一般人理牌的方法都是这样的，保持手里已有的牌按大小有序排列好，每拿到一张新的牌，就按顺序检查手里的牌，找到一个合适的位置把新牌插进去。这样在整个发牌阶段手里的牌就总是有序的，发完牌就可以开始玩了。这个理牌的初始状态就是每次拿到第一张牌的时候，手里只有一张牌，那当然就是天然有序的。

插入排序的过程与此相同，从仅由第一个元素构成的天然的初始有序子序列开始，逐步构建更大的有序子序列，直到整个序列全部有序就完成了排序。构建更大的有序子序列的过程就是把后面部分的无序子序列中第一个元素插入到前面已经有序的子序列中合适的位置里去，这由一次查找插入位置和一次搬移部分元素两次操作共同完成。

假设在一个长度为 :math:`n` 的序列 :math:`A` 中，前 :math:`m` 个元素 :math:`A[0],\dots,A[m-1]` 是已经有序的子序列，此后的部分为无序子序列。那么下一次构建有序子序列的过程即将 :math:`A[m]` 插入到有序子序列中去，使得有序子序列的范围扩展到 :math:`A[0],\dots,A[m]` 这前 :math:`m+1` 个元素。

为了完成 :math:`A[m]` 的插入过程，我们可以先用一个临时变量 :math:`t` 保存下 :math:`A[m]` 的值，然后在有序子序列中从后向前扫描每一个元素，如果元素值大于 :math:`t` 就把它向后搬一个位置，直到遇到第一个小于等于 :math:`t` 的元素，将 :math:`t` 的值写入它后面那个位置。这样就完成了一次插入，可以形象地把这个过程理解为“逐个拉开那些比自己大的元素，在插入位置拉出一条缝然后把自己塞进去”。让我们看一个示例，假设有序列 [1, 3, 5, 2, 4]，前3个元素为已经构建好的有序子序列，现在要插入第4个元素2，过程如下：

.. code-block:: none

   1: 初始状态，m = 3, 令 t = a[3], 令 j = m - 1 = 2

      a = [1, 3, 5, 2, 4], t = 2
                 ^  ^
                 j  m

   2: a[j] = 5 > t, 将其值后移一个位置, 令 a[j+1] = a[j], --j, 继续向前查找

      a = [1, 3, 5, 5, 4], t = 2
              ^     ^
              j     m

   3: a[j] = 3 > t, 将其值后移一个位置, 令 a[j+1] = a[j], --j, 继续向前查找

      a = [1, 3, 3, 5, 4], t = 2
           ^        ^
           j        m

   4: a[j] = 1 < t, 查找结束，插入点为其后一个位置, 令 a[j+1] = t, 插入完成

      a = [1, 2, 3, 5, 4], t = 2
           ^        ^
           j        m

插入过程还要注意边界情况，即如果第一个元素 :math:`A[0]` 都比要插入的元素大，那么下一轮查找的时候，位置变量会减小为 :math:`-1`，出现这种情况说明要插入的元素应该插入到 :math:`A[0]` 处。因此在向前查找插入点的判断时要注意判断位置变量小于0的情况，而且位置变量不能使用无符号数据类型。

插入排序就是从 :math:`m=1` 开始，不断重复上面的有序子序列扩建过程，直到 :math:`m=n`，即 :math:`A[n-1]` 插入结束后，完成排序。以序列 [3, 2, 5, 4, 1] 为例，插入排序过程如下所示（用圆括号表示有序子序列，方括号表示无序子序列）：

.. code-block:: none

      (3)[2, 5, 4, 1]

   1: (2, 3)[5, 4, 1]

   2: (2, 3, 5)[4, 1]

   3: (2, 3, 4, 5)[1]

   4: (1, 2, 3, 4, 5)

算法可以用伪代码描述如下：

.. admonition:: 插入排序算法

   :math:`\text{InsertionSort}(A, n):`

      :math:`\text{FOR  }m\leftarrow 1\text{  TO  } n-1\text{  DO}`

         :math:`t\leftarrow A[m]`

         :math:`j\leftarrow m-1`

         :math:`\text{WHILE  }j\ge0\text{  AND  }A[j]\gt t\text{  DO}`

            :math:`A[j+1]\leftarrow A[j]`

            :math:`j\leftarrow j-1`

         :math:`A[j+1]\leftarrow t`

和冒泡、选择排序一样，插入排序只需要使用一个额外的变量，用来临时存放要插入的值。所以算法的空间复杂度也是 :math:`O(1)`。

接下来让我们分析一下算法的时间复杂度。要对一个长度为 :math:`n` 的序列 :math:`A` 完成插入排序，需要先后进行 :math:`n-1` 轮元素插入，从 :math:`A[1]` 到 :math:`A[n-1]`。要完成元素 :math:`A[m]` 的插入需要在其前面的 :math:`m` 个位置中找到它的插入点，最少要进行一次元素比较，最多要进行 :math:`m` 次。我们分最好、最差和平均三种情况分别计算插入排序的工作量。

最好情况下，每一个元素的插入都只需要进行一次元素比较就能找到其插入位置。这意味着对于任何一个元素 :math:`A[m],(m=1,2,\dots,n-1)`，都满足 :math:`A[m-1]\le A[m]`。换句话说，原序列 :math:`A` 本身就是有序的。这时候整个插入排序总共要进行的元素比较次数（即总工作量）为：

.. math::

   W_{best}(n)=\underbrace{1+1+\cdots+1}_{n-1\text{ 个 }1}=n-1=O(n)

最坏情况下，每一个元素的插入都需要和它前面的每一个元素进行比较才能确定插入位置。这意味着对于任何一个元素 :math:`A[m],(m=1,2,\dots,n-1)`，它前面的有序子序列中的每一个元素都比它大。大家可以试着用反证法证明一下，这种情况只有在原序列 :math:`A` 本身是完全逆序的时候才会出现。这时候的总工作量为：

.. math::

   W_{worst}(n)=1+2+\cdots+(n-1)=\frac{n(n-1)}{2}=O(n^2)

平均情况，我们要借用概率论的知识才能计算，不过实际上理解和计算都还是很简单的。所谓平均情况，就是指对于任何一个元素 :math:`A[m],(m=1,2,\dots,n-1)`，它的实际插入位置是前面 :math:`m` 个可能位置中的哪一个的可能性是一样的。即实际插入位置在 :math:`m` 个候选位置中等概率地分布着，可能是 :math:`A[0]`，可能是 :math:`A[1]`，......，可能是 :math:`A[m-1]`，大家都有可能，而且可能性相等。因为在这 :math:`m` 个候选位置中必有而且仅有一个真正的位置，所以如果把这 :math:`m` 个位置的可能性（概率）加起来一定等于1，:math:`m` 个相等的数相加等于1，那么这个数一定等于 :math:`1\over m`。

在插入元素 :math:`A[m]` 的时候，假如其实际插入位置是 :math:`A[m-1]`，则需要进行1次元素比较，这种可能性是 :math:`1\over m`。假如其实际插入位置是 :math:`A[m-2]`，则需要进行2次元素比较，这种可能性同样是 :math:`1\over m`。依此类推，假如其实际插入位置是 :math:`A[1]` 则需要进行 :math:`m-1` 次元素比较，这种可能性也是 :math:`1\over m`。假如其实际插入位置是 :math:`A[0]`，则需要进行 :math:`m` 次元素比较，这种可能性依然是 :math:`1\over m`。因此，插入元素 :math:`A[m]` 时需要进行的元素比较的平均次数（数学期望）就是：

.. math::

   E(m)=1\times{1\over m}+2\times{1\over m}+\cdots+m\times{1\over m}={1\over m}(1+2+\cdots+m)={1\over m}\frac{m(m+1)}{2}=\frac{m+1}{2}

这样我们就能计算出平均情况下插入排序总工作量的期望值了：

.. math::

   \begin{align}
   W_{avg}(n)&=E(1)+E(2)+\cdots+E(n-1)=\frac{1+1}{2}+\frac{2+1}{2}+\cdots+\frac{n-1+1}{2}\\
             &={1\over2}(2+3+\cdots+n)={1\over2}\cdot\frac{(n+2)(n-1)}{2}=\frac{(n+2)(n-1)}{4}=O(n^2)
   \end{align}

综上所述，可以得出结论：插入排序在最坏和最差情况下的时间复杂度都是 :math:`O(n^2)`，最好情况下时间复杂度为 :math:`O(n)`，最好情况是指原序列本身完全有序，最坏情况是指原序列本身完全逆序。

上述结论听起来好像插入排序和冒泡、选择排序在时间复杂度上没什么明显区别，但是实际上插入排序要比选择排序快很多，冒泡排序更是无法与之相比。这从总工作量的准确表达式上可以很明显地看出来，平均情况下的工作量差不多是冒泡、选择排序平均情况下工作量的一半。而且插入也是一种“飞过去”的操作，只需要搬运元素值一次。

另外，插入排序是一种稳定的排序算法，这并不难看出来，请大家自行思考分析。

.. hint::

   在实践中，插入排序的速度远快于选择排序，选择排序略快于优化的冒泡排序，普通的冒泡排序速度最慢。事实上，对3000个以内的整型数排序，插入排序的表现通常不差于快速排序。加上代码简单，又是稳定排序，不失为一种实用的排序算法。

参照算法伪代码就可以很方便地写出标准的插入排序C++程序：

.. literalinclude:: ../../codes/252_insertion_sort.cpp
   :language: c++

但是，如果我们愿意付出一点代码编写上的麻烦，插入排序还能更优秀，它可以优化为一种实际运行性能相当接近 :math:`O(n\log n)` 时间的稳定排序算法！

插入排序的华丽转身：二分插入排序
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



