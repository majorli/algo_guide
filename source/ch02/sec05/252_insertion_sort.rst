插入排序
++++++++++++++++

:strong:`插入排序`\ 的算法思路就不像冒泡和选择排序这样简单粗暴了，但是也很容易理解，它的思路来源于扑克牌游戏。玩过扑克牌的人都知道，在发牌阶段大多数人都会随时整理好手里的牌。一般人理牌的方法都是这样的，保持手里已有的牌按大小有序排列好，每拿到一张新的牌，就按顺序检查手里的牌，找到一个合适的位置把新牌插进去。这样在整个发牌阶段手里的牌就总是有序的，发完牌就可以开始玩了。这个理牌的初始状态就是每次拿到第一张牌的时候，手里只有一张牌，那当然就是天然有序的。

插入排序的过程与此相同，从仅由第一个元素构成的天然的初始有序子序列开始，逐步构建更大的有序子序列，直到整个序列全部有序就完成了排序。构建更大的有序子序列的过程就是把后面部分的无序子序列中第一个元素插入到前面已经有序的子序列中合适的位置里去，这由一次查找插入位置和一次搬移部分元素两次操作共同完成。

假设在一个长度为 :math:`n` 的序列 :math:`A` 中，前 :math:`m` 个元素 :math:`A[0],\dots,A[m-1]` 是已经有序的子序列，此后的部分为无序子序列。那么下一次构建有序子序列的过程即将 :math:`A[m]` 插入到有序子序列中去，使得有序子序列的范围扩展到 :math:`A[0],\dots,A[m]` 这前 :math:`m+1` 个元素。

为了完成 :math:`A[m]` 的插入过程，我们可以先用一个临时变量 :math:`t` 保存下 :math:`A[m]` 的值，然后在有序子序列中从后向前扫描每一个元素，如果元素值大于 :math:`t` 就把它向后搬一个位置，直到遇到第一个小于等于 :math:`t` 的元素，将 :math:`t` 的值写入它后面那个位置。这样就完成了一次插入，可以形象地把这个过程理解为“逐个拉开那些比自己大的元素，在插入位置拉出一条缝然后把自己塞进去”。让我们看一个示例，假设有序列 [1, 3, 5, 2, 4]，前3个元素为已经构建好的有序子序列，现在要插入第4个元素2，过程如下：

.. code-block:: none

   1: 初始状态，m = 3, 令 t = a[3], 令 j = m - 1 = 2

      a = [1, 3, 5, 2, 4], t = 2
                 ^  ^
                 j  m

   2: a[j] = 5 > t, 将其值后移一个位置, 令 a[j+1] = a[j], --j, 继续向前查找

      a = [1, 3, 5, 5, 4], t = 2
              ^     ^
              j     m

   3: a[j] = 3 > t, 将其值后移一个位置, 令 a[j+1] = a[j], --j, 继续向前查找

      a = [1, 3, 3, 5, 4], t = 2
           ^        ^
           j        m

   4: a[j] = 1 < t, 查找结束，插入点为其后一个位置, 令 a[j+1] = t, 插入完成

      a = [1, 2, 3, 5, 4], t = 2
           ^        ^
           j        m

插入过程还要注意边界情况，即如果第一个元素 :math:`A[0]` 都比要插入的元素大，那么下一轮查找的时候，位置变量会减小为 :math:`-1`，出现这种情况说明要插入的元素应该插入到 :math:`A[0]` 处。因此在向前查找插入点的判断时要注意判断位置变量小于0的情况，而且位置变量不能使用无符号数据类型。

插入排序就是从 :math:`m=1` 开始，不断重复上面的有序子序列扩建过程，直到 :math:`m=n`，即 :math:`A[n-1]` 插入结束后，完成排序。以序列 [3, 2, 5, 4, 1] 为例，插入排序过程如下所示（用圆括号表示有序子序列，方括号表示无序子序列）：

.. code-block:: none

      (3)[2, 5, 4, 1]

   1: (2, 3)[5, 4, 1]

   2: (2, 3, 5)[4, 1]

   3: (2, 3, 4, 5)[1]

   4: (1, 2, 3, 4, 5)

算法可以用伪代码描述如下：

.. admonition:: 插入排序算法

   :math:`\text{InsertionSort}(A, n):`

      :math:`\text{FOR  }m\leftarrow 1\text{  TO  } n-1\text{  DO}`

         :math:`t\leftarrow A[m]`

         :math:`j\leftarrow m-1`

         :math:`\text{WHILE  }j\ge0\text{  AND  }A[j]\gt t\text{  DO}`

            :math:`A[j+1]\leftarrow A[j]`

            :math:`j\leftarrow j-1`

         :math:`A[j+1]\leftarrow t`


