排列组合打表与杨辉三角形
++++++++++++++++++++++++++++++++++++++++

在算法问题中，有时候会需要反复用到一定范围内的多个排列数或组合数，如果在每一次需要用到的时候去进行计算就会出现重复劳动。不仅是可能会先后重复计算相同的排列组合数，就算两次计算的是不同的排列组合数，也会出现重复的乘除法计算。比如先前计算过一次 :math:`P_{10}^5=10\times9\times8\times7\times6`，后面又计算了一次 :math:`P_9^3=9\times8\times7`，这两次乘法运算就是重复的。

遇到这种问题，最好的办法是先计算好所需范围内所有的排列数或组合数，存放在一张表格中，需要使用的时候直接从表中读取。当然了，打表的过程要最优化，即用最少的运算次数来进行打表，这就需要一些数学上的技巧。


排列数打表
^^^^^^^^^^^^^^^^

经过上一节的练习，我们已经知道使用 unsigned long long 类型可以容纳所有 :math:`n\le20` 的排列数，对于更大的 :math:`n`，也可以容纳一部分 :math:`m` 比较小的排列数。这里我们设法用最快的速度打出一张 :math:`n\le20` 的排列数表来，存放在一张二维数组中，行号表示 :math:`n`， 列号表示 :math:`m`。由于 :math:`0\le m\le n`，所以这张表只占据二维数组主对角线下方的三角形区域，如下所示：

.. math::

   \begin{matrix}
   P_0^0&-&-&-&\cdots&-\\
   P_1^0&P_1^1&-&-&\cdots&-\\
   P_2^0&P_2^1&P_2^2&-&\cdots&-\\
   P_3^0&P_3^1&P_3^2&P_3^3&\cdots&-\\
   \vdots&\vdots&\vdots&\vdots&\ddots&-\\
   P_{20}^0&P_{20}^1&P_{20}^2&P_{20}^3&\cdots&P_{20}^{20}\\
   \end{matrix}

问题是怎样来计算这张表可以让运算次数最少，直接用上一节的方法来逐个计算肯定是最差的方法，存在大量重复计算。类似这样的打表一定是使用动态规划的递推方法，即按照一定的顺序进行计算。首先填写不需要计算的初值，这里显然就是表格第一列的所有 :math:`P_n^0`，它们恒等于1，不需要计算。然后我们需要找到一个特定的递推公式，可以由已经计算过的值通过简单计算得到还没有计算过的值。这样我们只要按照递推公式约定的顺序逐个去推导出所有值就可以了。

例如这张排列数表，我们可以按行进行填写，每行的第一个值直接填写为1，后面可以按照这样的递推公式来推导：:math:`P_n^{k+1}=P_n^k\cdot(n-k)`。这是根据排列数公式推导来的，通过在连乘运算加上一个括号：

.. math::

   P_n^{k+1}=n\cdot(n-1)\cdot\cdots\cdot(n-k)=\bigl(n\cdot(n-1)\cdot\cdots\cdot(n-k+1)\bigr)\cdot(n-k)=P_n^k\cdot(n-k)

这个递推公式在 :math:`k=0` 的时候也成立，所以完全适用于对 :math:`P_n^1` 到 :math:`P_n^n` 的计算，可以填满一行中所有的排列数。

用这个方法打表，递一列的所有值都不需要计算，后面的值每一个都只需要计算一次乘法，这已经是非常快的一种打排列表的方法了。如果非要吹毛求疵，那么就是每次乘法的一个乘数需要用减法计算出来。所以还有没有连这次减法都省掉的打表法呢？当然是有的。

我们可以改变给排列数公式加括号的位置：

.. math::

   P_n^k=n\cdot(n-1)\cdot\cdots\cdot(n-k+1)=n\cdot\bigl((n-1)\cdot\cdots\cdot(n-k+1)\bigr)=n\cdot P_{n-1}^{k-1}

根据这个递推公式，除了第一列以外，表中每一个位置上排列数可以由其左上方的那个排列数乘上自己所在的行号（即 :math:`n`\ ）得到，这样就避免了减法运算。这个排列数打表过程可以用伪代码表示如下：

.. admonition:: 20以内排列数打表算法

   :math:`\text{PermsTable}(P)`

      :math:`\text{FOR  }n\leftarrow 0 \text{  TO  }20\text{  DO}`

         :math:`P[n][0]\leftarrow1`

         :math:`\text{FOR  }m\leftarrow 1 \text{  TO  }n\text{  DO}`

            :math:`P[n][m]\leftarrow n\cdot P[n-1][m-1]`

.. admonition:: 练习

   完成 :math:`0\le n\le 20` 范围内的排列数打表程序，并自行设法进行准确性测试。


组合数打表
^^^^^^^^^^^^^^^^

如果对一定范围内的组合数进行打表，表的形式和排列数表是一样的。使用二维数组来存放组合数表，以行号为 :math:`n`、列号为 :math:`m`，所有组合数 :math:`C_n^m` 都存在于主对角线的下方三角形区域内。假如我们要打表的范围为 :math:`0\le n\le62`，我们现在已经知道在这个范围内的所有组合数都是 unsigned long long 所能容纳的，则如下表：

.. math::

   \begin{matrix}
   C_0^0&-&-&-&\cdots&-\\
   C_1^0&C_1^1&-&-&\cdots&-\\
   C_2^0&C_2^1&C_2^2&-&\cdots&-\\
   C_3^0&C_3^1&C_3^2&C_3^3&\cdots&-\\
   \vdots&\vdots&\vdots&\vdots&\ddots&-\\
   C_{62}^0&C_{62}^1&C_{62}^2&C_{62}^3&\cdots&C_{62}^{62}\\
   \end{matrix}

在开始打表之前，让我们先看一下前几行的实际数值，比如前6行，即 :math:`0\le n \le 5`：

.. math::

   \begin{matrix}
   1& & & & & \\
   1&1& & & & \\
   1&2&1& & & \\
   1&3&3&1& & \\
   1&4&6&4&1& \\
   1&5&10&10&5&1\\
   \end{matrix}

我们发现，如果把主对角线上方三角形区域内的数字都设为0，那么除了第一列的 :math:`C_n^0` 恒等于1以外，其他每一个组合数都等于它左上方和正上方那两个组合数相加之和。这就是组合数打表的正确方式，只需要用到一次加法。

.. hint::

   如果在第一列左边再虚构一个全部为0的列，在第一行上方再虚构一个全部为0的行，那么所有的组合数都可以用它左上方和正上方两个数相加得到。数学里，这种在实际没有值的地方根据需要凭空视作有0值的做法很普遍，但是对于编程来说并没有什么太大意义。这么做只能浪费存储空间而已，而且会破坏原本二维数组行号就是 :math:`n`、列号就是 :math:`m` 的很完美的设定，所以我们不这么做。

事实上这个递推方式直接来自于上一节讲过的组合数递推性质 :math:`C_n^m=C_{n-1}^{m-1}+C_{n-1}^m`。虽然我们已经了解到用这个递推公式计算单个组合数是指数级别的时间复杂度，但是它却能够用于一整个范围内的组合数打表，是不是很神奇？其实道理很简单，问题还是出在重复计算上。

就从上面所列的6行组合数表来看，假设我们要计算 :math:`C_5^2=10`，第一轮递归会去计算 :math:`C_4^1` 和 :math:`C_4^2`。接下来为了计算 :math:`C_4^1`，会去递归计算 :math:`C_3^0` 和 :math:`C_3^1`，为了计算 :math:`C_4^2`，会去递归计算 :math:`C_3^1` 和 :math:`C_3^2`，现在 :math:`C_3^1` 已经出现了重复。再接下来重复会不断叠加，比如2次计算 :math:`C_3^1` 都会递归计算 :math:`C_2^0` 和 :math:`C_2^1`，为了计算 :math:`C_3^2` 又会递归计算 :math:`C_2^1` 和 :math:`C_2^2`，所以 :math:`C_2^1` 会被计算3次。

仅仅计算一个小小的 :math:`C_5^2` 就已经出现了那么多次重复计算，可见如果计算更大的组合数，重复计算不断叠加会造成多大的浪费。这就是用递推性质计算单个组合数为什么会演变成指数时间的原因。但是用来打表就不同了，因为我们的计算方向反过来了，从递归变成了递推，所以不会出现重复计算。使用递推公式是最快的组合数打表方式。

.. warning::

   用递归来实现递推，一旦递推公式中涉及两次递归的，往往就会造成重复计算，而后果就是不同程度的指数时间复杂度。所以有“能不递归就不递归，能用递推就不递归”的说法。

.. admonition:: 练习

   完成 :math:`0\le n\le 62` 范围内的组合数打表程序，并自行设法进行准确性测试。


杨辉三角形（Pascal三角形）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

可别小看了上面的组合数表，这张组合数表其实就是组合数学里面鼎鼎大名的Pascal三角形，由于中国南宋数学家杨辉在《详解九章算术》一书中也提出过这个三角形，所以在中国一般叫做杨辉三角形。可惜的是虽然杨辉比Pascal的研究要早了近400年，但是中国古代并没有把这些纯数学的研究深入和继续下去，西方世界也一直到很晚才了解到中国古代的数学成果，所以在国际上还是通行把这个组合数表叫做Pascal三角形。

数学上习惯把杨辉三角形排列成等腰三角形的形式的，比如




