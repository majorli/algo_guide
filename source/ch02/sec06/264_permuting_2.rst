全排列迭代算法
++++++++++++++++++++++++++

在算法问题中，如果需要生成排列，大多数是需要用到某一个序列的全排列。我们知道，全排列的排列数是一个量级很大的阶乘，当序列的元素数量达到21时，:math:`P_{21}^{21}=21!` 就已经超过了 unsigned long long 的取值范围，也就是说超过了 :math:`2^{64}`。这里又见到了我们熟悉的魔鬼数字 :math:`2^{64}`，大家应该很清楚它到底有多巨大了吧。而实际的算法问题，要排列的元素个数还常常要超过21个，所以用上一节介绍的循环型的算法批量生成所有排列已经变得很不现实，我们需要使用迭代型算法来逐个迭代生成排列，一旦找到题目所需要的解就不需要再继续迭代了。

全排列的迭代算法为所有可能的排列设定一种顺序规则，称为\ :strong:`迭代顺序`，把某一个排列作为参数交给迭代器，迭代器就会将其改为迭代顺序下的下一个或上一个排列，如此下去直到抵达迭代顺序下的最后一个或最前一个排列。每次迭代得到下一个排列的迭代器叫做\ :strong:`顺序迭代器`，反之称为\ :strong:`逆序迭代器`。本质上来说，顺序迭代和逆序迭代无非是一对反向操作，只要了解了其中一种的原理，归纳出另一种也就不成问题了。本节我们将仅对顺序迭代器的原理和实现进行讲解，下文说到迭代，若无特殊指明便是指顺序迭代。逆序迭代将留作本节的练习。

从上面的描述来看，迭代器进行的是原地排列，但是也很容易做到索引排列，因为对于全排列来说，索引排列就是把所有的索引值作为元素进行全排列而已。如果我们不希望破坏原有的数据，那么另外生成 [0,1,...n-1] 这样一个索引值序列并对它进行迭代即可，迭代结果即是每一种排列的索引表。

字典序全排列迭代算法
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

最为常见的迭代顺序是所谓的“字典序”。这里所说的字典序是借用了字符串字典序的排序规则，将每一个元素看成是一个字符，将整个排列看成是一个字符串，然后按照字符串字典序的规则进行排序。例如我们对整数序列 [1,2,3,4] 进行全排列，会得到以下24种排列，按照字典序排列如下：

.. code-block:: none

   [1, 2, 3, 4]
   [1, 2, 4, 3]
   [1, 3, 2, 4]
   [1, 3, 4, 2]
   [1, 4, 2, 3]
   [1, 4, 3, 2]
   [2, 1, 3, 4]
   [2, 1, 4, 3]
   [2, 3, 1, 4]
   [2, 3, 4, 1]
   [2, 4, 1, 3]
   [2, 4, 3, 1]
   [3, 1, 2, 4]
   [3, 1, 4, 2]
   [3, 2, 1, 4]
   [3, 2, 4, 1]
   [3, 4, 1, 2]
   [3, 4, 2, 1]
   [4, 1, 2, 3]
   [4, 1, 3, 2]
   [4, 2, 1, 3]
   [4, 2, 3, 1]
   [4, 3, 1, 2]
   [4, 3, 2, 1]

可以看到，字典序最小的 [1,2,3,4] 中任何两个相邻的元素之间都是顺序的，即前一个小于后一个。字典序最大的 [4,3,2,1] 则刚好相反，所有相邻元素之间都是逆序。可以想象字典序的排列和相邻元素之间逆序对的数量和位置是有关的，从一个排列出发去生成它的下一个排列，一定和调整排列中的逆序对有关。为了看清楚这个规律，下面我们给这些排列的元素之间添加大于号来标注出逆序对：

.. code-block:: none

   [1   2   3   4]
   [1   2   4 > 3]
   [1   3 > 2   4]
   [1   3   4 > 2]
   [1   4 > 2   3]
   [1   4 > 3 > 2]
   [2 > 1   3   4]
   [2 > 1   4 > 3]
   [2   3 > 1   4]
   [2   3   4 > 1]
   [2   4 > 1   3]
   [2   4 > 3 > 1]
   [3 > 1   2   4]
   [3 > 1   4 > 2]
   [3 > 2 > 1   4]
   [3 > 2   4 > 1]
   [3   4 > 1   2]
   [3   4 > 2 > 1]
   [4 > 1   2   3]
   [4 > 1   3 > 2]
   [4 > 2 > 1   3]
   [4 > 2   3 > 1]
   [4 > 3 > 1   2]
   [4 > 3 > 2 > 1]

经过观察，我们可以归纳出每一次顺序迭代所做的操作：

1. 可以发现，每一次迭代后，原排列中最后一个顺序对总是会变成逆序对。

   所以第一步：找到排列中最后一个顺序对 :math:`(a_i \lt a_{i+1})`。

2. 再观察每一次迭代后，原排列中最后一个顺序对变成逆序的规律，可以发现并不总是简单地互换两个相邻元素，而是要确保原顺序对中前面位置那个较小的元素不会一下子增加得过大，导致跳过一部分排列。换句话说，要把原排列中最后一个顺序对里比较小的那个元素尽量少地增加，只要让它足以成为逆序对即可。

   例如迭代 [1,4,3,2] 这个排列的时候，最后一个顺序对为 (1,4)，但是不能将其简单地改成 (4,1)，否则会导致直接跳过所有以 2 和 3 开头的排列。因此这种情况下应该把它变成仅比它大 1 的元素，即 2。

   所以第二步：在 :math:`a_i` 后面的所有元素 :math:`a_{i+1},\dots,a_{n-1}` 中找到所有大于 :math:`a_i` 的元素中的最小元素，设为 :math:`a_k`，然后交换 :math:`a_i` 和 :math:`a_k`。

   查找这个步骤其实很简单，由于 :math:`(a_i \lt a_{i+1})` 是原排列中的最后一个顺序对，所以从 :math:`a_{i+1}` 开始到末尾的所有元素都是逆序排放的，只需要从末尾元素开始逐个向前找到第一个比 :math:`a_i` 大的元素，就是要找的那个所有大于 :math:`a_i` 的元素中的最小者。但是我们会发现一个严重的问题：我们无法保证找到的那个 :math:`a_k` 一定大于 :math:`a_{i+1}`，即交换之后的新的 :math:`(a_i^\prime,a_{i+1})` 不一定是逆序。比如前面所举例的排列 [1,4,3,2]，做完第二步之后会得到 [2,4,3,1]，这显然不是正确的结果。因此事情到这里还没有结束。

3. 进一步仔细观察，我们发现原排列中最后一个顺序对 :math:`(a_i,a_{i+1})` 不仅变成了新排列中的一个逆序对，而且总是变成了新排列中的\ :strong:`最后一个`\ 逆序对！也就是说，新排列中从 :math:`a_{i+1}^\prime` 开始到末尾的所有元素是递增有序的。这样就直接搞定了第二步操作中引来的那个问题，因为原来的 :math:`a_i` 已经被交换到了后面部分，所以后面部分中至少有一个元素比新的 :math:`a_i^\prime` 小，我们只要在做完第二步的交换之后，对从 :math:`a_{i+1}` 开始到末尾的这一段进行排序，就自然确保了新的 :math:`(a_i^\prime,a_{i+1}^\prime)` 一定逆序。

   继续前面的例子，我们已经交换了 [1,4,3,2] 中的 1 和 2，变成了 [2,4,3,1]，接下来对 [4,3,1] 这个部分进行排序，得到 [2,1,3,4]，这就是所要的正确迭代结果。

   所以第三步：对从 :math:`a_{i+1}` 开始到排列末尾的部分进行升序排序。

以上三步就是字典序顺序迭代的过程，整个过程并不是太好理解，建议大家对上面的 [1,2,3,4] 全排列过程进行手工迭代演算，务必搞清楚这个算法过程。

实际编程的时候，由于排列元素不重复，所以最后一步排序可以使用任意的排序算法，建议可以直接调用C++算法库提供的 ``sort()`` 函数进行排序。下面这个程序，仍然以前十个大写字母为限，输入一个不大于10的整数 :math:`n`，迭代输出前 :math:`n` 个大写字母的全排列，并且为了说明怎样使用迭代算法来实现索引排列，我们使用了索引迭代的模式：

.. literalinclude:: ../../codes/264_next_perm.cpp
   :language: c++

.. warning::

   迭代型排列算法在生成新的一个排列时，是依据前一个排列而来的，所以迭代过程有所谓的起点和终点。[1,2,3,4] 这样的完全升序排列是起点，[4,3,2,1] 这样的完全逆序排列是终点。如果从中间任意一个排列开始迭代，那么无论是顺序迭代到终点还是逆序迭代到起点，都会造成遗漏一部分排列。

   因此如果采用原地迭代进行全排列，那么一般在情况不明的时候，开始排列之前首先要对容器进行排序，确保从起点（或者终点）开始。如果使用索引迭代的方式，如上面的程序所示，索引表是程序中人为初始化的，编程者可以确保初始化成起点或终点，或任意一个特定的开始点，而不需去关心容器中元素的排列情况。


.. admonition:: 练习

   认真阅读理解，完全掌握字典序顺序迭代的算法之后，完成逆序迭代算法的设计和编程，完整的程序和功能仿照上面的示例。


C++算法库的全排列生成函数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在C++的algorithm库中也提供了一对迭代生成全排列的函数 ``next_permutation()`` 和 ``prev_permutation()``，前者为顺序迭代，后者为逆序迭代。它们同样使用的是字典序规则。

