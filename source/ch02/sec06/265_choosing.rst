组合生成算法
++++++++++++++++++++++++

组合的生成算法和排列生成算法类似，但是更加简单。组合生成算法同样可以分为\ :strong:`索引组合生成`\ 和\ :strong:`原地组合生成`\ 两类，也可以按照运行模式的不同分为\ :strong:`循环模式`\ 和\ :strong:`迭代模式`\ 两类。

由于组合不关心元素之间顺序的特殊性质，实际问题中选取数一般总是少于元素总数，也很少出现需要在一个序列上原地去构建组合的情况。另外，当元素本身是取值不连续或者类型不同的时候，比如要对这样的一个元素集合 :math:`\{3.14, \pi, 2^{\pi}, {22\over7}, \log\pi \}` 进行五选三的组合，这种情况下要做原地组合生成也没有什么太好的算法。所以一般我们不建议使用原地生成组合的方法，而是生成索引组合，利用索引表去完成组合的选取。例如对于任何五选三的组合，我们只要能生成出下面这样十张索引表，就可以利用它们来对应到相应位置上的元素，从而完成所有的十种选择了：

.. code-block:: none

   [0, 1, 2]
   [0, 1, 3]
   [0, 1, 4]
   [0, 2, 3]
   [0, 2, 4]
   [0, 3, 4]
   [1, 2, 3]
   [1, 2, 4]
   [1, 3, 4]
   [2, 3, 4]


循环索引组合
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

循环模式生成索引的组合，和循环生成排列的原理是一样的，就是利用嵌套循环来进行选取。比如最简单的 :math:`n` 选 :math:`1` 的情况，只要一个单循环就可以遍历出从 :math:`0` 到 :math:`n-1` 的所有索引了：

.. code-block:: c++

   for (int index = 0; index < n; ++index) { // 选出并消费第 index 号元素 }

生成 :math:`n` 选 :math:`2` 的组合比生成 :math:`n` 取 :math:`2` 的排列简单不少。因为组合不关心元素之间的顺序关系，例如 {1,2} 和 {2,1} 二者是同一个组合，所以当外层循环已经选定了第一个元素的索引 :math:`i`，内层循环在选取第二个元素索引 :math:`j` 的时候不需要考虑 :math:`i` 之前的那些索引了，内层循环总是从它的外层循环当前选定的索引之后开始就可以。因此也就不需要设计什么是否已经占用的标志了，代码就会变得简单许多：

.. code-block:: c++

   for (int i = 0; i < n; ++i) {
           for (int j = i + 1; j < n; ++j) {
                   // 得到索引表 [i, j]，调用消费者函数
           }
   }

:math:`n` 选 :math:`3` 的组合无非就是内部再嵌套一层循环，如下所示：

.. code-block:: c++

   for (int i = 0, i < n; ++i) {
           for (int j = i + 1; j < n; ++j) {
                   for (int k = j + 1; k < n; ++k) {
                           // 得到索引表 [i, j, k]，调用消费者函数
                   }
           }
   }

要选的元素数量 :math:`m\le3` 时，就这样直接嵌套循环即可。:math:`m\gt 3` 时简单的嵌套循环就会变成典型的箭头形代码，此时就需要参考循环生成排列所用的方法，递归构造多层嵌套循环。

生成组合的嵌套循环在改写成递归模式的时候更加简单，没有额外的标志需要维护。递归函数还是需要有一个参数来表示当前的嵌套层数，最外层为 :math:`0`，最内层为 :math:`m-1`，最外层开始的时候要动态分配生成好空索引表，结束时要释放掉索引表的空间。层数达到 :math:`m` 的时候就调用消费者函数并结束递归。但是现在每一层循环的起点变得不同，最外层循环总是从0开始，所有内层循环则从它的上层循环所选定的索引位置的后一个索引开始。请看下面的示例程序：

.. literalinclude:: ../../codes/265_choose.cpp
   :language: c++

.. admonition:: 练习

   将上面的示例程序中的消费者函数改为输出索引表，并且尝试修改其代码，使得可以不用 ``start`` 这个辅助变量。完成之后多用几种 :math:`n,m` 值运行一下，看看生成的索引组合有什么规律。


迭代索引组合
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

索引的组合经过仔细观察也是有规律可循的。我们先规定索引表里的每一项索引值都是升序排列的，就如循环嵌套生成的索引表一样，即 ``index[0] < index[1] < ... < index[m-1]``。然后以五选三的十种索引表为例，按照上面的练习中看到的索引表生成顺序，观察索引表中三个位置上索引值的变化规律。为了观察方便，下面用小括号来表示 ``index[0]`` 所选中的位置，方括号表示 ``index[1]`` 所选中的位置，花括号表示 ``index[2]`` 所选中的位置：

.. code-block:: none

   [0, 1, 2]  ==>  (0) [1] {2}  3   4
   [0, 1, 3]  ==>  (0) [1]  2  {3}  4
   [0, 1, 4]  ==>  (0) [1]  2   3  {4}
   [0, 2, 3]  ==>  (0)  1  [2] {3}  4
   [0, 2, 4]  ==>  (0)  1  [2]  3  {4}
   [0, 3, 4]  ==>  (0)  1   2  [3] {4}
   [1, 2, 3]  ==>   0  (1) [2] {3}  4
   [1, 2, 4]  ==>   0  (1) [2]  3  {4}
   [1, 3, 4]  ==>   0  (1)  2  [3] {4}
   [2, 3, 4]  ==>   0   1  (2) [3] {4}

不难看出，从第一个索引组合 {0,1,2} 到最后一个 {2,3,4} 逐个变化的过程有一个明显的“行动模式”。每一次改变都是最后一个索引 ``index[2]`` 尝试向后移动一个位置，如果它已经在最后的位置而不能再后移了。那么就尝试让它的前一个索引 ``index[1]`` 后移一个位置，``index[1]`` 如果成功的后移了一个位置的话，那么 ``index[2]`` 就回到 ``index[1]`` 后面那个位置。如果 ``index[1]`` 也已经在它所能到达的最后一个位置了，那么就尝试后移 ``index[0]``，然后 ``index[1]`` 和 ``index[2]`` 整体回到紧挨着 ``index[0]`` 的后面。如果连 ``index[0]`` 也已经抵达它所能抵达的最后位置了，那么就没有哪个索引值可以后移了，迭代就结束了。

形象地说，就好像几个人在离开一堵墙一定距离的位置上排成一列纵队，离开墙壁最近的那个人是队尾，最远的那个人是队头。然后队尾那个人先开始往墙壁走去，直到撞到墙的时候，倒数第二个人向后退一个位置，同时把队尾那个人叫回自己身后。每撞一次墙倒数第二个人就往后退一个位置并把他叫回自己身后。重复以上操作，直到倒数第二个人也把队尾那个人挤到了墙边，谁也动不了了的时候，倒数第三个人开始往后移动，也是每次后移一个位置并把他后面那两个挤在墙边动弹不得的人叫回自己身后，然后继续从队尾开始重复刚才的运动直到三个人都挤到墙边动弹不得的时候，倒数第四个人开始后移......如此循环往复直到整个队伍整体被挤到墙边，谁也无法再往后移动一个位置的时候，迭代就结束了。



