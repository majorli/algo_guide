排列的生成算法(I)
++++++++++++++++++++++++++++++

许多算法问题会用到集合的排列，需要遍历一个容器中全部或部分元素的各种排列，这就需要用到排列生成算法。

排列生成算法可分为\ :strong:`原地排列`\ 和\ :strong:`索引排列`\ 两种类型。原地排列就是在原容器中直接修改元素顺序来生成排列，索引排列就是另外生成一张索引表，里面依次放置一种排列下从前往后各个元素在原容器中的位置（例如数组下标）。索引排列需要用到一个额外的索引表，占用空间略大一些，但不会破坏原容器的内容。对于全排列而言，索引排列其实就是对位置序列 :math:`[0,1,\dots,n-1]` 进行了一次全排列而已。

按照各种排列的生成方式，排列生成算法又可以分为\ :strong:`循环型`\ 和\ :strong:`迭代型`\ 两类。

循环型的算法通过一次运行循环生成所有排列，每生成一个排列，算法调用某一个函数来对这个排列进行解决问题所需的处理。因此我们需要事先定义好一个函数来接收排列并完成相应的处理功能。使用循环型排列生成算法的一般模式为：有一个用于生成排列的函数，称为\ :strong:`生产者`\ （producer）；有一个用于处理排列的功能函数，称为\ :strong:`消费者`\ （consumer）；主函数调用生产者，生产者批量生产出所有的排列，每生产一个排列就调用一次消费者，消费者根据解题需要对这个排列进行处理。

迭代型的算法一般只能用于全排列，实现迭代型排列生成的函数称为\ :strong:`迭代器`\ （iterator）。迭代器为所有的全排列规定一个特定的顺序，每运行一次它会根据当前的排列生成一个新的排列。按照迭代器所使用的顺序规则，如果生成的是下一个排列，则称顺序迭代器；如果生成的是上一个排列，则称逆序迭代器。如此下去直到所有排列全部生成完毕，再次调用迭代器会返回一个结束标志，比如返回逻辑值false。使用迭代型排序生成算法的一般模式为：主函数先通过初始化或排序等手段生成一个初始的全排列，然后将此排列作为参数不断循环调用迭代器，每调用一次得到一个新的排列，直到迭代过程全部结束。通常使用 ``do ... while`` 循环进行迭代，在循环内部对迭代得到的排列进行处理，当然也可以调用消费者函数。

本节主要介绍两种循环型的排列生成算法，迭代型的全排列算法将在下一节中介绍。


循环索引排列
^^^^^^^^^^^^^^^^

循环索引排序是以循环的方式一次性生成所有排列的索引表。它可以对一个容器中的前 :math:`n` 个元素进行取 :math:`m` 个排列，共生成 :math:`P_n^m` 种排列。因为这是一种索引排列，所以消费者函数至少需要接收三个参数：存放元素的容器，索引表，索引表的长度 :math:`m`。

我们的示例程序使用数组作为元素容器，元素为前十个大写字母。为了简单起见消费者函数的处理就是简单地输出获得的排列，先写好这个消费者函数，如下所示：

.. literalinclude:: ../../codes/263_loop_index_perm.cpp
   :language: c++
   :lines: 5-9

示例程序需要实现这样的功能，输入两个整数 :math:`n,m`，要求 :math:`0\lt m\le n\le 10`，然后输出前 :math:`n` 个大写字母中任取 :math:`m` 个的排列。

先来看最简单的情况，如果 :math:`m=1`，那么我们其实只用一个循环就可以遍历所有 :math:`P_n^1=n` 种排列了：

.. code-block:: c++

   for (int i = 0; i < n; ++i) { // 消费第i个元素 }

非常简单，这样一个单循环就相当于生成了所有长度为1的排列的索引表。那么如果 :math:`m=2` 怎么办？一般来说第一反应当然就是嵌套两层循环了。完全正确，只是有一个地方需要注意一下，在内层循环里生成排列中第二项元素的索引时要避开外层循环里当前已经占用的那个第一项元素的索引，简单地说就是不能和外层循环的循环变量重复。这也很好办，像下面这样写就可以了：

.. code-block:: c++

   for (int i = 0; i < n; ++i) {
           for (int j = 0; j < n; ++j) {
                   if (i == j) continue;
                   // 消费第i、j两个元素组成的排列
           }
   }

.. hint::

   上面这个方法是最为实用的生成n选2排列的方法，长度为2的排列就这么干，不用考虑更复杂的算法。

但是当 :math:`m=3` 时，再这样嵌套就有点显得不是很好了。首先三层嵌套的代码就已经开始变得臃肿，开始出现臭名昭著的“箭头形代码”的趋势。更要命的是最内层的用于生成排列中第3项元素索引的循环，要同时避开外面两层循环的循环变量，这样判断语句变得复杂并且费事：

.. code-block:: c++

   for (int i = 0; i < n; ++i) {
           for (int j = 0; j < n; ++j) {
                   if (i == j) continue;
                   for (int k = 0; k < n; ++k) {
                           if (k == j || k == i) continue;
                           // 消费第i、j、k三个元素组成的排列
                   }
           }
   }

可以想象如果 :math:`m\gt3`，这样的嵌套循环就完全没法写下去了，就算写出来也会成为天大的笑柄。怎么解决这两个问题？

先解决内层循环变量避开外层循环变量的判断问题。我们知道，循环变量就是前 :math:`n` 个元素的索引，从 :math:`0` 到 :math:`n-1`。根据不可重复排列的性质，已经被选中过的元素就不能再次被选中，即已经选中过的元素的索引不能再次被使用。所以我们可以实现设置一个表示有没有被选中过的逻辑型标志数组，长度为 :math:`n`，对应从 :math:`0` 到 :math:`n-1` 号元素的索引，某个元素被选中的时候就把对应的标志设为true，那么每一层循环里只要判断当前循环变量对应的标志是不是true就可以了。当排列发生变化，某一层循环将要进入下一轮（即该位置上的元素将要发生变化）时，别忘了要及时把当前选中元素的标志改回false，以便其他位置可以选它。经过这样的修改，上面的代码就变成了下面这样：

.. code-block:: c++

   bool mask[n] = { 0 };     // 初始化为全false
   for (int i = 0; i < n; ++i) {
           mask[i] = true;   // 选中 i 号元素
           for (int j = 0; j < n; ++j) {
                   if (mask[j]) continue; // j 号元素已经被选中过，跳过
                   mask[j] = true;   // 选中 j 号元素
                   for (int k = 0; k < n; ++k) {
                           if (mask[k]) continue; // k 号元素已经被选中过，跳过
                           // 消费第i、j、k三个元素组成的排列
                   }
                   mask[j] = false;  // 释放 j 号元素
           }
           mask[i] = false;  // 释放 i 号元素
   }

注意到最外层循环不需要判断索引 ``i`` 是否被选中过，因为每一层循环只会和自己的外层循环发生选择冲突，所以没有别人的选择能影响到它。最内层循环不需要设置选中标志 ``mask[k]``，因为它没有内层循环，所以它的选择不会影响到他人。

但是这个代码反而显得更加臃肿难堪了，嵌套循环的问题怎么解决？我们发现其实每一层循环干的事情是基本一样的，不同之处有三。首先，最外层循环不用判断是否冲突；第二，最内层循环不用设置标志和取消标志；第三，最内层循环要调用消费者函数。前两个问题很好解决，给最外层循环加上一次判断，在最内层循环也做一下标志处理又有什么关系。加上这些虽然像是画蛇添足，但却使得多层循环之间的代码已经趋于一致了。带来的好处是使得我们可以用递归调用来代替嵌套循环，即每次只循环一层，在循环内部递归调用自己，就相当于嵌套了一层循环。要实现递归，就需要有终止条件，恰好我们在每一层递归的时候也需要告诉函数现在是在处理排列中的第几项元素。所以我们可以给函数增加一个参数表示当前在第几层循环，这个参数从0开始，每递归调用一次就加1，直到它等于 :math:`m` 时就表示递归该终止了，:math:`0` 号到 :math:`m-1` 号位置的元素都已经选好了。这样也顺便解决了第三个问题，当递归抵达终止条件之时调用消费者函数。

这样我们就可以写出最终的循环索引排列函数了。在写代码之前要讲一个小小的语法知识点：静态局部变量。



递归原地排列
^^^^^^^^^^^^^^^^

