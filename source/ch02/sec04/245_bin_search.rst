二分法基础及二分查找
++++++++++++++++++++++++++++++++++

:strong:`二分法`\ 是一种重要的算法设计技巧。简单来说，二分法就是利用一定的判断规则，不断地将问题规模减半，从而使得规模较大的问题能够快速地缩减为规模较小的问题，从而实现快速地解决问题。采用了二分法设计的算法，其时间复杂度往往是 :math:`O(\log n)` 的级别，可以说非常之快。

二分法本质上是一种递归法，每次讲问题规模减半时不能使得问题的性质发生变化，变化的只是计算规模，因此可以利用递归法来使用同样的解法去求解缩减后的小规模问题。但是在实际编程时，大多数二分算法并不使用函数的递归调用，而是采用循环的方法来实现递归。递归只是思路，不是手段。

.. attention::

   一定要搞清楚，二分法不等于二分查找。二分查找只是一种二分算法，二分法是算法设计技巧。

另一个要注意的是二分法和分治法的区别。分治法是五大算法之一，是一种算法设计思想，以后我们会详细进行讲解。现在要搞清楚的二者的区别：

分治法是将一个难求解的大问题分解为多个规模较小性质相同的小问题，然后逐个求解各个小问题，得到一系列小问题的解，最后将这些小问题的解组合起来得出大问题的解。

二分法是将一个难求解的大问题的规模逐步减半，使问题本身的规模不断缩小，直至能够求出其解。

那么什么样的问题可以采用二分法来进行求解呢？一般来说，问题如果具有以下这些特点，就可以考虑采用二分法：

1. 问题要么有一个\ :strong:`确定`\ 的解 :math:`s`，要么无解。


2. 存在这样一个集合（注意：集合的元素是不重复的）\ :math:`S`，问题如果有解，那么解一定是这个集合中的某个元素，如果这个集合中的所有元素都不是问题的解，那么问题就无解。我们称这个集合 :math:`S` 为问题的\ :strong:`解空间`，称它的元素为问题的\ :strong:`候选解`。

   .. attention::

      候选解的个数可以是有限的也可以是无限的。


3. 候选解之间可以通过某一种特定的规则来进行比较，确定相互顺序。

   最常见的比较规则即为数的大小关系，但并不仅限于此。我们已经见过的一种并非数的大小关系的次序就是字符串的字典序，今后我们还会在图结构中看到所谓的图节点的“拓扑序”。总之，有一种明确的比较规则，能够\ :strong:`唯一确定`\ 不同候选解之间的“先后顺序”即可。

   纯粹数学上的概念，元素之间若能通过一种明确的比较规则来判定一个唯一的明确的先后顺序的集合，叫做\ :strong:`良序集`，元素之间的先后顺序就叫做\ :strong:`序`。常见的整数集合、有理数集合、实数集合等都是良序集，数与数之间的大小关系就是它们的序，用小于号 :math:`\lt` 就可以表示数与数之间的序关系。

   一般情况下，不管是整数、实数，还是字符串、图的节点，都用符号 :math:`\prec` 来表示“先于”关系，:math:`a\prec b` 表示在序关系上，:math:`a` 先于 :math:`b`。对于数的大小关系，相当于小于号 :math:`\lt`，而按照数轴左小右大的规则，我们也可以称较小的数在前、较大的数在后。

   当然了，等于和不等于这两个关系 :math:`=,\neq` 总是通用的。另外，和数的其他三个大小关系 :math:`\le,\gt,\ge` 对应，一般的序关系还有先于等于、后于和后于等于，符号分别为 :math:`\preceq,\succ,\succeq`。

   .. attention::

      为了表述方便，可能也是为了向“数”这个最古老最重要的数学概念致敬，通常我们把“先于”、“后于”的一般序关系也称为“小于”和“大于”。

   .. admonition:: 补充
   
      实际上，只有小于关系是必要的，其他关系都是补充性质的。使用大于、等于这些关系只是为了便利起见，因为所有其他关系都可以用小于关系表示出来。

      在C++语言中允许对任何自定义数据类型，通常是结构（struct），定义它们的关系运算，以便程序可以对自定义类型的数据进行大小比较。比如我们已经见过的C++ string，就可以直接用 ``==,!=,<,>,<=,>=`` 这六种关系运算来比较它们的字典序。而C++语言的规则规定，最少仅需要为自定义类型定义 ``<`` 运算就够了，这就是因为其他五种运算都可以用小于运算来实现。例如 ``>=`` 运算只要对 ``<`` 运算的结果取反就可以了，大于等于就是不小于。

      请大家思考一下，怎样仅用小于运算就能实现所有六种关系运算。


4. 给出解空间中的任意一个候选解 :math:`s_j`，我们有办法判断它是不是问题的解 :math:`s`，如果不是，那么我们还能进一步判断它比解大还是小。换句话说，我们可以对 :math:`s_j` 和 :math:`s` 进行序的比较。


满足以上四个条件的问题，可以用二分法求解。二分算法的基本框架如下：

.. admonition:: 二分算法基本框架

   参数：解空间 :math:`S`

   如果 :math:`S` 为空，那么问题无解，结束。

   从 :math:`S` 中找到位于中间位置的候选解 :math:`s_{mid}`

   如果 :math:`s_{mid}` 就是问题的解 :math:`s`，那么问题解决，返回解 :math:`s=s_{mid}`，结束。

   否则

       如果 :math:`s_{mid} \prec s`，那么解一定在 :math:`S` 的后一半中，所以用 :math:`S` 的后一半作为新的解空间递归本算法

       如果 :math:`s_{mid} \succ s`，那么解一定在 :math:`S` 的前一半中，所以用 :math:`S` 的前一半作为新的解空间递归本算法


下面我们看一个最简单也是最常见的入门例子，二分查找及其应用。


二分查找
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

:strong:`二分查找`\ 是一种非常快速地在有序数组（或其中连续的一段）中查找特定值的元素位置的算法，时间复杂度为 :math:`O(\log n)`。如果数组中存在有相同值的元素，那么二分查找也可以找到其中一个，但是找到的是哪一个却不能确定。所以二分查找一般会要求数组中的元素没有重复值，某些具体应用对于查到的是哪一个元素没有特别要求的，当然也可以，要看具体问题而定。

.. admonition:: 约定

   在算法描述中，说到“有序”，若没有特指的话，就是指从小到大的顺序。

需要特别注意的是，二分查找算法要解决的问题，其解空间是数组中元素的位置（或者叫下标），而不是数组中元素的值。这一点很多教材都没有特别说明，初学者很容易误以为解空间是元素值。

C++和所有其他编程语言中，数组或者向量、列表这一类的顺序表数据类型，其元素的位置都是从小到大的连续整数，C++数组的下标是从0开始排列的连续自然数。这符合解空间所需要的特征。其次，由于元素值本身也是有序的，所以我们可以用其中任意一个元素值和要查找的值进行比较，以确定要查找的值在该元素之前还是之后。最后，问题的解只有两种，要么存在某个元素，其值等于要查找的值，解就是该元素的位置，要么找不到，即无解。综上所述，在有序数组中查找某个特定值元素的位置这个算法符合采用二分法的条件。

要在有序数组中进行二分查找，我们需要三个变量。``left`` 和 ``right`` 分别表示要查找部分的左右两个端点，例如数组共有10个元素，要在整个数组中进行查找，那么初始时 ``left = 0, right = 9``，如果要在其中第3个到第7个元素这一段中查找，那么初始时 ``left = 2, right = 6``。另外还需要一个用来比对的中间位置变量 ``mid``，每一轮比对的时候，取 ``mid = (left+right)/2``，也就是左右端点的中间位置，这个位置的元素就是每次用来和要查找的值进行比较的元素。

从初始的左右端点开始，我们进行如下循环：在每一轮循环里，计算好 ``mid``，然后比较该处元素值和要查找的值，如果 ``mid`` 处的元素值恰好等于要查找的值，那么查找就成功结束了，``mid`` 就是问题的解；如果 ``mid`` 处元素更大，说明要查找的位置一定在 ``mid`` 前面，于是我们让 ``right = mid - 1`` 然后继续循环；反之若是 ``mid`` 处的元素值小了，说明要查找的位置一定还在 ``mid`` 的右边，于是我们让 ``left = mid + 1`` 并继续循环。每一轮循环之后，要么查找成功结束，要么查找范围缩减一半。

如果要没有任何元素的值等于要查找的值，那么上面这个循环一定会一轮一轮的进行下去，直到最后出现 ``left > right`` 的情况，通俗地说，左右颠倒了。出现左右颠倒，即说明查找失败，一般的惯例会返回-1表示查无此值。

下面的图是两个实例，分别表示了查找成功和查找失败的两种情况。











(待续)
