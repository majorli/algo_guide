Fibonacci数列
++++++++++++++++++++++++++

Fibonacci数列，中文一般翻译成“斐波那契数列”，是数学和自然科学中最为重要的一个整数数列。它说自己第二重要，就没有别的数列敢说自己第一重要。

Fibonacci数列得名于中世纪意大利的学者Fibonacci，这里还有一个有趣的故事，和兔子生小兔子有关。据说Fibonacci先生是在帮一位养兔子的朋友计算兔子的数量时发现的这个数列。有一天，Fibonacci先生的一位朋友来信说，他买了一对神奇的兔子，这种兔子永远不死而且会不断地以固定的速度生小兔子。更神奇的是，小兔子总是一公一母成双成对地出生。朋友觉得这下要发大财了，但是自己读书少，不太会算术，所以他请Fibonacci先生帮他算一算几个月之后他将拥有多少对这样的兔子。

.. image:: ../../images/243_fibo_1.png

经过严谨的分析计算，Fibonacci先生发现兔子的数量按这样的规律增长：

最初的第1个月有1对小兔子。

过完1个月，第2个月还是1对，因为小兔子需要1个月时间成长为大兔子。

再过1个月，到了第3个月，大兔子生出1对小兔子，加上它们自己，总共变成2对，1对大兔子和1对小兔子。

第3个月之后，大兔子又生出一对小兔子，而原来的小兔子成长为了大兔子，现在第4个月有了2对大兔子和1对小兔子，一共3对。

到了第5个月，原来的2对大兔子又各生出1对小兔子，原来的小兔子长成了1对大兔子，这样一共有了5对兔子......

就这样一直生生不息地下去，每个月兔子的数量等于前面两个月的数量之和。写成整数数列就是 :math:`1,1,2,3,5,8,13,21,34,\cdots`。

这就是Fibonacci数列，用现代数学的符号可以表示成一个递推公式：

.. math::

   \begin{cases}
   F(n)=F(n-1)+F(n-2),&(n\gt2)\\
   F(1)=F(2)=1
   \end{cases}

这个递推公式有两个初值 :math:`F(1)=F(2)=1`。这个数列中的第 :math:`n` 项 :math:`F(n)` 就称为第 :math:`n` 个Fibonacci数。

.. hint::

   有时候也会在前面加上一个 :math:`F(0)=0`，这往往是一些特殊问题为了数学上的便利而人为添加的，并不影响Fibonacci数列本身的性质。

Fibonacci先生恐怕自己都不会想到他发现的这个数列在数学、几何、艺术、音乐、自然、科学等各方面都有非常重要的意义和应用，大自然中有大量的规律和现象都遵循着它所规定的规律，不仅仅神奇兔子的数量和它有关，黄金比例、螺旋线、向日葵的花纹、组合数学、Pascal三角形......甚至一个人走楼梯有多少种走法，都和Fibonacci数列息息相关。

关于Fibonacci数列本身的知识和应用，这里不打算细讲，事实上也讲不完，有兴趣的可以自己上网或找相关的书籍查阅。这里我们重点要学习和比较计算Fibonacci数的两种算法，递归的算法和递推的算法。


递归计算Fibonacci数
^^^^^^^^^^^^^^^^^^^^^^^^^^

现在给出正整数 :math:`n`，要求出Fibonacci数 :math:`F(n)`。按照数列递推公式的形式，很容易想到一个简单的递归算法，用C++语言可以写出下面这样一个函数：

.. code-block:: c++

   unsigned long long fibo(unsigned int n)
   {
           if (n <= 2) return 1;
           return fibo(n - 1) + fibo(n - 2);
   }

这个函数的形式看上去非常简洁优美，计算结果也是无可挑剔，但这是一个典型的滥用递归的坏例子。大家可以编写一个简单的测试程序，加上测量耗时的功能试一试它的运算速度有多“快”。虽然每台电脑的性能不同，但是我们可以查看随着 :math:`n` 的增大，运算时间增加的趋势，在我的电脑上测试结果是：当 :math:`n <= 20` 时运算速度都在1ms以内，计算 :math:`F(30)` 使用了5ms，计算 :math:`F(40)` 就激增为约400ms，计算 :math:`F(50)` 居然花了约45s，再大的数字就不敢再尝试了。简直是慢到了随心所欲的程度！

为了分析这个算法的时间复杂度，我们先来测算一下这个递归算法的工作量。以加法运算为基本运算，这个算法在计算 :math:`F(1),F(2)` 时是直接返回其值的，工作量为0；在计算其他Fibonacci数的时候，它递归调用两次，然后再进行一次加法。用 :math:`T(n)` 表示计算Fibonacci数 :math:`F(n)` 的工作量，那么这个算法的工作量为：

.. math::

   T(n)=T(n-1)+T(n-2)+1,T(1)=T(2)=0

下面用迭代法来求解：

.. math::

   \begin{align}
   T(n)&=T(n-1)+T(n-2)+1\\
       &=[T(n-2)+T(n-3)+1]+[T(n-3)+T(n-4)+1]+1=T(n-2)+2T(n-3)+T(n-4)+1+2\\
       &=T(n-3)+3T(n-4)+3T(n-5)+T(n-6)+1+2+4\\
       &=T(n-4)+4T(n-5)+6T(n-6)+4T(n-7)+T(n-8)+1+2+4+8\\
       &=\cdots
   \end{align}

到这里虽然还没有迭代完成，但是已经可以从 :math:`1+2+4+8+\cdots` 这个余项形式很明显地看出来，当把所有的函数项全部规约为 :math:`T(1)` 或者 :math:`T(2)` 的时候，工作量的数值一定是一个2的指数的形式。这后面的计算比较复杂，这里就不详细说明了，只要记住，用这样的递归法来计算Fibonacci数，时间复杂度为 :math:`O(2^n)`，是一种无法容忍的慢速算法。

那么到底是什么原因造成了算法会如此之慢呢？原因是“重复计算”，它在运行过程中有大量的重复计算。比如调用 ``fibo(5)`` 会引起调用 ``fibo(4)`` 和 ``fibo(3)``；二者会分别发生调用 ``fibo(3)``、``fibo(2)`` 和 ``fibo(2)``、``fibo(1)``；而其中的 ``fibo(3)`` 又会再次调用 ``fibo(2)``、``fibo(1)``。整个过程中 ``fibo(3)`` 被调用2次，``fibo(2)`` 被调用3次，``fibo(1)`` 被调用2次，可见已经发生了多次重复计算。

也可以通过画递归调用树（注意不是计算工作量的递归树哦）来更加直观的看看重复调用的情况，比如我们要计算 :math:`F(8)`，为此我们调用函数 ``fibo(8)``：

.. image:: ../../images/243_fibo.png

图中用不同的颜色标出了每一种调用，可以看出整个过程中出现了大量的重复调用。``fibo(6)`` 被调用2次，``fibo(5)`` 被调用3次，``fibo(4)`` 5次，``fibo(3)`` 和 ``fibo(1)`` 各8次，最多的 ``fibo(2)`` 被重复调用了13次。C++程序调用函数会造成一些时间和空间上的开销，比如保存状态、复制参数、跳转、复制返回值、再次跳转、恢复状态等，虽然一次调用这点开销微不足道，但是如果出现指数级别的大量重复调用，那么这些开销积累下来就不容小视了。

更重要的是，这些大量的重复劳动带来的一个更大的时间浪费是多做了许多次加法运算（我们在衡量时间复杂度时就是用加法运算来作为基本工作量的）。比如上面的图中，树的每一次分叉都意味着此处有一次加法，总共有20次。而实际上笔算 :math:`F(8)`，从 :math:`F(3)` 开始向后推算，只需要计算6次加法即可。

随着 :math:`n` 的增大，递归计算Fibonacci数的程序中重复调用的次数以 :math:`2^n` 指数级增长，随之带来多余的加法次数同样以 :math:`2^n` 指数级别的增长，这就是这个算法运算速度慢到无法忍受的原因。

.. warning::

   Fibonacci数的递归算法是滥用递归导致翻车的反面典型。

   具有下面这两个特征的递归算法往往很容易演变成类似的指数时间算法：

   1. 有两次或更多次递归调用；

   2. 递归调用时，子问题的规模缩减是“按数量减少”，例如 :math:`T(n-1)` 或者 :math:`T(n-9)`，而不是“按比例缩小“，例如 :math:`T({n\over2})` 或者 :math:`T({5n\over6})` 这样的。

      按数量减少，哪怕每次减少的量很大，也是慢的！按比例缩小，哪怕每次缩小的比例很小，也是快的！

   一定要警惕这种模式，出现这种模式往往意味着这个算法不够好。

.. hint::

   其实上一节所讲的Hanoi塔算法也是一个具有这样的模式的递归算法，而它的时间复杂度也恰恰好是 :math:`O(2^n)`，但是没办法，这就是Hanoi塔问题的最优解了。

递推计算Fibonacci数
^^^^^^^^^^^^^^^^^^^^^^^^^^



