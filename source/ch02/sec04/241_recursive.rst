递归法介绍
++++++++++++++++++++++


递归的基本概念
^^^^^^^^^^^^^^^^^^^^^^

学习递归算法，主要涉及三个基本概念：:strong:`递归`、:strong:`递归法`、:strong:`递归调用`。首先要弄清楚它们是三个相互关联但不互相同的概念。

递归，是一个数学上的概念，在描述概念之前先来看两幅图。

.. image:: ../../images/241_recursive_1.png

这是大家都很熟悉的一组俄罗斯套娃玩具，一个大的娃娃里面套着一个一模一样但是尺寸略小的娃娃，这个略小的娃娃里面还套着一个更小一点的娃娃。这样一层一层的套下去，每次都是一模一样的娃娃，只是尺寸略小，直到最小的一个为止。

.. image:: ../../images/241_recursive_2.png

这个图就更经典了，这是1900年一位瑞士画家为Droste牌可可粉设计的包装盒。在这个盒子上画着一名护士，手上的托盘里放着一盒同样的Droste可可粉和一杯美味的热巧克力。神奇的是托盘上的那一盒\ :strong:`同样的`\ Droste可可粉。因为同样，所以在图中这个盒子上自然也画着同样的内容：一名护士，手上的托盘里放着一盒同样的Droste可可粉和一杯热巧克力......你可以想象这个过程还会如此继续下去，非常神奇。

这就是艺术史上非常著名的第一幅展现了递归效果的画，后来这一类的画作乃至电影电视作品呈现的递归效果，就被称为“Droste效应”，成为一种艺术流派。

上面这两幅图展示了现实生活中的递归现象，类似这样的现象还有许多许多，几乎遍及所有场合。比如雪花边缘的分形构造、比如大家耳熟能详的鬼畜故事“从前有座山，山上有座庙，庙里的老和尚对小和尚说：从前有座山，山上有座庙，庙里的老和尚对小和尚说：从前有座山，山上有座庙，庙里的老和尚对小和尚说：......”

后来数学家对递归现象进行了深入研究，得到了许多重要的结论和发现，他们对递归下了这样的定义：*递归是一种现象，当一物体由和它自身相同或和它自身同类型的组成部分构成的时候，就称该物体通过递归进行定义。*

数学上的定义总是很抽象，计算机科学家们则利用递归现象归纳出了一套用于设计算法的方法，称为递归法。递归法把大型的复杂问题层层转化为一个或数个与原问题具有相同结构的小问题来求解，层层递归下去直到规模缩小到可以直接求解的程度，得出最小规模问题的解，然后再层层原路返回，用已经得到的小问题的解来反过来构造出大问题的解，直至得到原问题的解。

使用递归法设计的算法就称为\ :strong:`递归算法`，是最为重要的一类算法。根据前面对递归法的描述可知，一个递归算法由\ :strong:`终止条件`、:strong:`递归过程`\ 和\ :strong:`返回过程`\ 三部分组成。

终止条件就是递归结束的条件，当问题规模已经小到可以直接求解时，我们就说递归达到终止条件了，应当结束了。如果一个递归算法没有终止条件，那么就会出现“从前有座山”这样的无限递归错误。

递归过程就是当终止条件还没有达到的时候，问题的规模还不足以直接求解，这时候就需要进一步分解问题，也就是进一步递归下去的过程。在实际编程的时候，递归过程通常用循环结构或者函数的递归调用来实现。

返回过程就是根据小问题的解来构造大问题的解的过程。一般当一次递归到达终止条件后，最小规模问题直接得出解开始，这些小问题的解就要沿着前面递归分解问题的路径原路返回，一路把已经得到的小问题解组合构造成上一层的较大问题的解，如此层层返回，直到回到最开始的原问题，从而构造出原问题的解。

所以我们可以得出递归算法框架的一般形式，所有递归算法都要遵循这样一个框架。在实际编程时，根据所用语言和技术手段的不同，代码可能呈现各种不同的样式，但是算法是唯一不变的。

.. admonition:: 递归算法的一般框架

   :math:`\text{Recursive}(p):`

      :math:`\text{IF  终止条件成立  THEN}`

         :math:`\text{直接计算出结果  }ans`

         :math:`\text{RETURN  }ans`

      :math:`ans_1 \leftarrow\text{ Recursive}(p_1)\text{  // 用较小规模的数据}p1\text{进行递归求解}`

      :math:`\vdots`

      :math:`ans_n \leftarrow\text{ Recursive}(p_n)\text{  // 原问题可能分解为多个较小规模问题}`

      :math:`\text{使用递归得到的多个小规模问题的解}ans_1,\dots,ans_n\text{构造出原问题的解}ans`

      :math:`\text{RETURN  }ans`

可以看到，递归算法的框架很简洁。开头第一段是终止条件判断，如果规模已经小到满足终止条件了就直接计算结果并返回。第二段是将问题分解为几个规模较小的问题并直接调用算法本身去求解，这一段对应的是递归过程。可以想象，如果分解下去的子问题的规模仍然不满足终止条件，那么它们也会进一步按照同样的规则分解自己并启动第二轮递归调用，如此循环下去。这是一个层层缩小规模层层递归调用的动态过程，但是写在算法描述或者程序代码里只是一轮递归调用而已。接下来就是把递归调用返回来的小问题的解组合起来构造出原问题的解，其实这也是一个层层返回的动态过程，整个过程是由一系列的RETURN返回串起来的，这是写在算法描述或者程序代码里只需要一段构造原问题解的步骤即可。

那么在实际拿到一个问题的时候，怎么样判断它是不是可以用递归算法呢？一般来说，能够用以下两个属性来定义解的问题具有递归特征，可以用递归法求解：

1、有终止条件：一个或多个简单的基本情况，能直接得到结果。

2、有递归规则：一系列可以让所有其他情况朝向基本情况退化的规则。

例如，可以用递归的方法来定义一个人的长辈：

1、基本情况：父母是长辈。

2、递归规则：长辈的长辈也是长辈。

.. warning::

   学习递归算法，有两条原则千万记住：

   1. 算法问题常会有多种算法可用，递归算法不一定是最优算法，往往递推会比递归更好（原则一：能用递推就不用递归）。

   2. 递归算法常会有多种实现方法，函数递归调用不一定是最好的实现方法，往往用循环会比用递归调用更好，因为函数调用耗时耗内存而且递归层数受内存限制，弄不好就容易爆空间（原则二：能用循环就不要递归调用）。

   总之，递归的设计和编程很简单，但调试和分析很麻烦。我们既不要害怕递归，也不要做递归的原教旨主义者。


下面我们来看两个简单的例子，找一找感觉。


例1：计算阶乘
^^^^^^^^^^^^^^^^^^^^^^^^^^^^


例2：寻找最大数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^






（待续）
