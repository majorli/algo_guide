中位数问题
++++++++++++++++

:strong:`中位数`\ （median），又称\ :strong:`中值`，是一个重要的统计指标。它是按顺序排列的一组数据中居于中间位置的数，可将数据划分为个数相等的两部分，其中一部分中所有数都大于等于中位数，另一部分中所有数都小于等于中位数。对于有限的数集，如果其中有奇数个数，那么可以通过把所有数排序后找出正中间的那一个作为中位数；如果有偶数个数，通常取最中间的两个数值的平均数作为中位数。

.. admonition:: 示例

   数列 [7,1,3,20,5] 的中位数是5。数列中比5小的数和比5大的数个数相等，都是2个。如果把这5个数排序后得到 [1,3,5,7,20]，可以发现5位于正中间的位置。

   数列 [1,3,10,2] 的中位数是2和3的平均数2.5。数列中比2.5小的数和比2.5大的数都是2个。如果把数列排序为 [1,2,3,10]，就可以直观地看出2和3是最中间的两个数，所以中位数取它们的平均数。

简而言之，一个数列的中位数就是将其排序后，位于最中间位置的数值。对于这个数列而言，其中比中位数小的数和比中位数大的数应当是数量相等的。所以也说“中位数可以将数列中的数据划分为个数相等的两个部分，其中一部分中所有数都大于等于中位数，另一部分中所有数都小于等于中位数”。

关于中位数，有一点概念必须澄清：它是一个单独的数，而不是数列中的一个元素！

如果给出一组数值，求它的中位数是很简单的，只需要对数组进行排序，然后根据元素个数的奇偶性来进行计算即可。

C++的模板算法库algorithm中提供了一个非常方便实用的快速排序函数 ``std::sort()``，可以用来对数组中指定的一段元素进行排序。调用 ``sort()`` 函数，只需要提供数组中要排序的那一段元素的头尾指针即可。要使用这个函数，需引入algorithm库并使用命名空间std，下面是用法示例：

.. code-block:: c++

   #include <algorithm>
   using namespace std;

   int a[100];
   for (int i = 0; i < 100; ++i) scanf("%d", &a[i]); // 读入100个元素

   sort(a, a + 10); // 对 a[0] 到 a[9] 之间的10个元素进行排序，注意含头不含尾的范围表示原则
   sort(a + 20, a + 40); // 对 a[20] 到 a[39] 之间的20个元素进行排序
   sort(a, a + 100); // 对 a[0] 到 a[99]，即整个数组进行排序

所以，假如有一个题目，要读入 :math:`n\le1000` 个整数并求其中位数，那么程序将非常简单：

.. code-block:: c++

   #include <cstdio>
   #include <algorithm>

   using namespace std;

   int main()
   {
           int n, a[1001];
           scanf("%d", &n);
           for (int i = 0; i < n; ++i) scanf("%d", &a[i]);  // 读数
           sort(a, a + n);  // 排序
           // 根据 n 的奇偶性来计算中位数并输出，保留2位小数
           printf("%.2lf\n", n % 2 ? (double) a[n/2] : (a[n/2] + a[n/2-1]) / 2.0);

   }

这个程序看懂了吗？看懂了我们就继续讨论一个更加复杂的问题。

现在有两个有序数组 :math:`A` 和 :math:`B`，各有 :math:`m` 和 :math:`n` 个元素，两个数组都已经完成升序排序，即元素从小到大排列。现在要求快速求出这两个数组中所有元素的中位数，时间复杂度不高于 :math:`O(\log(m+n))`。其中 :math:`0\le m,n \le 1000000`，但保证两个数组不会同时为空。

归并法求两个有序数组的中位数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

如果两个数组都是乱序的，为了求出它们所有元素的中位数，我们可以把两个数组的元素都合到一个大数组里，然后对大数组进行排序来求出中位数。但使用排序算法最快的时间复杂度为 :math:`O((n+m)\log(n+m))`，远大于问题所要求的上限 :math:`O(\log(n+m))`。这个方法的主要问题出在没有利用两个原始数组都已经有序这个条件。

那么即然两个数组都已经排好序了，我们可以用一种叫做\ :strong:`归并`\ 的操作把两个数组中的元素保持有序地合到另一个大数组里去，时间复杂度为线性的 :math:`O(n+m)`。归并操作非常重要，在大量的算法问题中会用到归并操作，基本排序算法中最重要的\ :strong:`归并排序`\ 也是基于归并操作来完成的，大家一定要熟练掌握。

其实归并操作非常简单，它的思路来源于整队。比如有两列队伍，都是按照身高从矮到高排列好的，现在要把两列队伍合并为一列，并且保持身高从矮到高排列。这个整队过程非常简单，从两列队伍各自排在队头的人开始，每次挑出两个队头中比较矮的那个人出列，排进新的队伍的尾部，如果队头两个人身高一样就任选其中一人即可。不断循环这一过程，直到某个队伍的人全部挑完，把另一个队伍中剩余的人按原顺序排到新队伍的后面就完成了。下面举个简单的例子来说明这个过程：

.. code-block:: none

   初始状态：

   队伍一: [1, 3]

   队伍二: [2, 6, 7]

   新队伍: []

   第1步：队伍一的队头1较小，挑出来放到新队伍尾部

   队伍一: 1, [3]

   队伍二: [2, 6, 7]

   新队伍: [1]

   第2步：队伍二的队头2较小，挑出来放到新队伍尾部

   队伍一: 1, [3]

   队伍二: 2, [6, 7]

   新队伍: [1, 2]

   第3步：队伍一的队头3较小，挑出来放到新队伍尾部

   队伍一: 1, 3, []

   队伍二: 2, [6, 7]

   新队伍: [1, 2, 3]

   第4步：队伍一已空，把队伍二剩下的部分按原顺序放到新队伍尾部

   队伍一: 1, 3, []

   队伍二: 2, 6, 7, []

   新队伍: [1, 2, 3, 6, 7]

按照这个方法，我们把两个数组读进来之后，可以归并到一个新的数组里去，然后在新数组里计算中位数即可。

.. literalinclude:: ../../codes/24A_lc04_merge.cpp
   :language: c++

这个算法思路很简单，程序很简洁，运行速度其实也挺快的，通常情况下这种方法就很好，推荐使用。但是归并算法有一个很大的问题是大量占用内存，因为它要把所有原数据都复制一份，所以空间复杂度高达 :math:`O(m+n)`。

归并过程实际上逐个把所有原数据都复制了一遍，算法的时间复杂度很显然是 :math:`O(m+n)`。所以这个基于归并的算法还远达不到问题的时间复杂度要求，不超过 :math:`O(\log(m+n))`。

我们需要一个更加快的算法，因为问题要求的时间复杂度为对数型，看到对数型的时间要求一定会想到二分法。这个世界上绝大多数达到对数时间的算法都是二分法。下面我们就要重点讲一讲怎么用二分法求两个有序数组的中位数。


二分法求两个有序数组的中位数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^




