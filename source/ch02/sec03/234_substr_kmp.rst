子串搜索及KMP算法
++++++++++++++++++++++++++++

:strong:`子串搜索`，也叫\ :strong:`子串匹配`，是字符串处理领域非常重要和常用的一种操作。一般的子串搜索操作是指，给定两个字符串 :math:`S` 和 :math:`P`，检查 :math:`P` 是不是 :math:`S` 的一个子串，如果是则返回 :math:`P` 第一次在 :math:`S` 中出现的位置，即 :math:`P` 的首字符 :math:`P_0` 在 :math:`S` 中的对应元素位置；如果不是一般就返回-1。

例如：字符串 ``abc`` 就是 ``1234abcd`` 的一个子串，它第一次出现的位置是4，但它不是字符串 ``1234ABCD`` 的子串，因为ASCII字符是区分大小写的。

通常我们把字符串 :math:`S` 称为\ :strong:`文本串`，把 :math:`P` 称为\ :strong:`模式串`。最基本的子串搜索，模式串就是要搜索的子串，所做的是一字不差的精确匹配。高级的子串搜索，模式串中可能含有通配符，比如用 ``*`` 表示0个或任意多个任意字符，用 ``?`` 表示0个或1个任意字符。最灵活也最难实现的是\ :strong:`正则表达式`\ 匹配，此时模式串是一个正则表达式，它有自己的词法规则，可以非常灵活地表示各种各样的字符串样式，例如正则式 ``^-?[1-9]\d*$`` 表示任意的整数样式的字符串，而 ``^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`` 能匹配小数样式的表达式。后两种高级的搜索也是我们常会把子串搜索称作子串匹配的原因，因为它们的功能已经超越了简单的搜索。

这一节我们讨论最基本的子串搜索算法，在文本串中一字不差地精确搜索模式串。

朴素的蛮力搜索算法
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

蛮力算法就是从文本串的头一个字符开始，作为起始位置与模式串进行比对，如果发现一致的子串，就返回起始位置，如果不一致就将起始位置移到文本串的下一个字符继续比对，直到找到子串或者找不到。

按照C++的习惯，字符串的字符从0开始编号，蛮力搜索的第一个起始位置是文本串的0号字符 :math:`S_0`。假设文本串长度为 :math:`n`，模式串长度为 :math:`M`，那么蛮力搜索的最后一个起始位置就应该是 :math:`n-M`，因为从这个位置到文本串的末尾还剩刚好 :math:`(n-1)-(n-M)+1=M` 个字符，再往后移剩余字符数量就不如模式串多了，不可能再存在和模式串相同的子串。

利用cstring库的 ``strncmp()`` 函数可以很简单地编写出这样一个函数：

.. code-block:: c++

   #include <cstdio>
   #include <cstring>
   
   int substr_search_bf(const char *s, const char *p);
   
   int main()
   {
           char s[81], p[11];
           scanf("%80s %10s", s, p);
           printf("%d\n", substr_search_bf(s, p));
   
           return 0;
   }
   
   int substr_search_bf(const char *s, const char *p)
   {
           int pos, n_s = strlen(s), n_p = strlen(p);
           for (pos = 0; pos <= n_s - n_p; ++pos)
                   if (strncmp(s+pos, p, n_p) == 0) break;
           return pos > n_s - n_p ? -1 : pos;
   }

这个蛮力算法非常简单易懂，但是它的时间复杂度是比较大的，是 :math:`O(nM)` 量级的，属于二阶的时间复杂度。

精确子串搜索有一个非常经典的算法，由算法界的三位大神D.E.Knuth、J.H.Morris和V.R.Pratt同时发明的。这个算法是每一本算法教科书都必讲、每一个学习算法的人都必学必会的超经典算法，就以三位发明者的姓氏首字母命名为KMP算法。它是迄今为止精确子串搜索最快的算法，也是算法史上最伟大的发明之一。下面我们要来讲解一下这个KMP算法。


KMP算法
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

KMP算法是对蛮力算法的改进，所以要理解KMP算法必须先了解蛮力算法不好的地方在哪里。

假设文本串 :math:`S` 为 ``ABCAABCB``，模式串 :math:`P` 为 ``ABCB``。下面我们先看看蛮力搜索的过程：

.. code-block:: none

   第1步：比对位置 pos = 0
   S: ABCAABCB
   P: ABCB
   第1步比对结果：失败，pos后移一位。

   第2步：比对位置 pos = 1
   S: ABCAABCB
   P:  ABCB
   第2步比对结果：失败，pos后移一位。

   第3步：比对位置 pos = 2
   S: ABCAABCB
   P:   ABCB
   第3步比对结果：失败，pos后移一位。

   第4步：比对位置 pos = 3
   S: ABCAABCB
   P:    ABCB
   第4步比对结果：失败，pos后移一位。

   第5步：比对位置 pos = 4
   S: ABCAABCB
   P:     ABCB
   第5步比对结果：成功，返回子串首位置4。

从这个过程可以看出，其实第1步比对失败后，比对位置 ``pos`` 并不需要傻傻地一个一个往后挪，至少可以直接跳到第4步那个位置 ``pos = 3``，因为第1次发生比对不符合的字符就是 ``S[3] = 'A'``。

而KMP算法的改进思路就是：:emphasis:`当一次比对失败时，利用已经匹配的那部分信息，将模式串尽可能多地移动到一个合适的位置，使得下一次比对可以从上一次匹配失败的那个位置开始继续进行`。

例如在上面这个例子里，第1步比对中匹配正确的字符有 ``S[0],S[1],S[2]``，直到 ``S[3]`` 发生错误。使用蛮力法，第2步又回过头去从 ``S[1]`` 开始比对，这就是蛮力算法时间复杂度为 :math:`O(nM)` 的原因。如果我们能让模式串在第1步比对失败后移动到一个合适的位置，使得第2步可以从 ``S[3]`` 直接继续，那么我们在比对完整个文本串之后，最多进行了 :math:`n` 次比对，时间复杂度将降到 :math:`O(n)`。这就是KMP算法的设计思路。

有了思路，我们还要解决一个具体问题：所谓“合适的位置”到底在哪里？是不是简单地把模式串移动到对准上一次匹配失败的字符位置开始就可以了？当然不是，例如看下面这个例子：

文本串 :math:`S`：``ABCABDABE``，模式串 :math:`P`：``ABCABE``，用索引 ``i,j`` 分别表示在文本串和模式串上的比对位置。

.. code-block:: none

   第1次比对，从 i = j = 0 开始
      i: 0  1  2  3  4 [5] 6  7  8
      S: A  B  C  A  B  D  A  B  E
      P: A  B  C  A  B  E
      j: 0  1  2  3  4 [5]
   比对结果：在 i = 5 处匹配失败。

这时候，如果简单地把模式串移动到和 ``S[5]`` 对齐的位置，会发现文本串中剩余字符数量不够了，就会得出搜索失败的结论。然而这是错误的！

仔细观察模式串，可以发现上一次匹配成功的前5个字符 ``ABCAB`` 有相同的前缀和后缀 ``AB``。所以我们应该把开头的那一段前缀 ``AB`` 移动到后面这一段后缀 ``AB`` 所在的位置，然后就可以从上一次匹配失败的位置 ``S[5]`` 开始继续比对了：

.. code-block:: none

   第2次比对，P移动到和 S[3] 对齐的位置，
   仍从上一次不匹配字符的位置 i = 5 处开始比对，对应的模式串位置为 j = 2
      i: 0  1  2  3  4 [5] 6  7  8
      S: A  B  C  A  B  D  A  B  E
      P:          A  B  C  A  B  E
      j:          0  1 [2] 3  4  5
   比对结果：匹配成功，返回子串首位置3。

现在我们可以找到一点头绪了。当某一次比对在某个字符处发生了不匹配，那么模式串要移动到的“合适位置”与已经匹配成功的那一部分里面有没有相同的前后缀有关。

设上一次比对时，第一对不匹配字符为 :math:`S_i \neq P_j`，即文本串位置 :math:`i`、模式串位置 :math:`j`，假设在已经匹配成功的部分模式串里面最长的相同前后缀长度为 :math:`l`，那么就应该把模式串首字符相对于文本串的位置移动到 :math:`i-l`，因为从这个位置到发生不匹配的字符位置 :math:`i` 之间恰有 :math:`l` 个字符，模式串移过来之后刚好长度为 :math:`l` 的前缀部分位于这一段区域里，最长的相同前后缀恰好充分利用起来。这时候我们可以从字符 :math:`S_i` 继续开始比对，与之比对的模式串字符为 :math:`P_l`，即 :math:`j\leftarrow l`。

按照这个规则，如果在上一次比对已经匹配成功的部分里没有相同前后缀，即相同前后缀的最大长度为0，比如在 ``"ABCDEFG"`` 中搜索 ``"ABCA"``：

.. code-block:: none

   第1次比对，从 i = j = 0 开始，到 i = 3 时匹配失败
      i: 0  1  2 [3] 4  5  6
      S: A  B  C  D  E  F  G
      P: A  B  C  A
      j: 0  1  2 [3]
   已经匹配的部分 "ABC" 中没有相同的前后缀，l = 0，所以 j = l = 0，相当于将模式串直接移动到 i 的位置

   第2次比对，i = 3， j = 0
      i: 0  1  2 [3] 4  5  6
      S: A  B  C  D  E  F  G
      P:          A  B  C  A
      j:         [0] 1  2  3
   第一个字符就匹配失败，已经匹配部分为空，整个模式串应该向后移动一个字符继续比对，但超长了，搜索失败


所以我们看到还有这样一种情况，比对时匹配部分长度为0，即第一个字符就不匹配，这时候就只能后移一个字符，:math:`i\leftarrow i+1,j\leftarrow 0`，然后继续开始比对。

下面我们来理一理思路，把算法的框架搭出来。设模式串中每一个字符 :math:`P_j` 之前的部分中最长的相同前后缀长度为 :math:`l_j`。对于模式串的第2个字符 :math:`P_1`，它前面的部分只有一个首字符，不存在前后缀，所以 :math:`l_1 = 0` 是固定的。对于模式串的首字符 :math:`P_0`，我们规定 :math:`l_0=-1`，这是为了方便在算法中实现“如果第一个字符就不匹配”情况发生时的处理。下面是KMP算法的伪代码：

.. admonition:: KMP算法

   :math:`\text{KMP_Search}(S,P):`

      :math:`i\leftarrow0,j\leftarrow0`

      :math:`\text{WHILE  }j\lt \text{Len}(P) \text{  AND  } \text{Len}(S)-i \ge \text{Len}(P)-j \text{  DO}`

         :math:`\text{IF  }j=-1\text{  OR  }S_i=P_j`

            :math:`\text{THEN  }i\leftarrow i+1,j\leftarrow j+1`

            :math:`\text{ELSE  }j\leftarrow l_j`

      :math:`\text{IF  }j=\text{Len}(P)`

         :math:`\text{THEN RETURN  }i-j`

         :math:`\text{ELSE RETURN  }-1`






（待续）
