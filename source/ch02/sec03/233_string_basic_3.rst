字符串处理基础知识(III)
++++++++++++++++++++++++++++++++

这一节我们对字符串处理的其他几个重要的基本知识点进行说明。

字典序
^^^^^^

在C++语言和所有的计算机编程语言里，字符串都是可以比较“大小”的，或者更准确地说，字符串是可以有序的。我们知道，实数也是有序的，实数的序依据的是它们的大小而定的。字符串本身并没有大小的区别，比如 "hello" 和 "world" 这两个字符串谁大谁小呢？因此字符串的序依据的不是它们本身的大小，而是依据组成字符串的字符在字符表中的顺序而确定的，称为\ :strong:`字典序`。

在算法编程的环境里使用的字符表是ASCII码表，共有127个字符，包括了数字、大小写字母、常见的标点符号、算术运算符号、空白符（空格、换行、tab）和其他一些控制字符，另外还有一个非常特别的空字符 ``'\0'``，对应的数值编号为0，在C-string里用于表示字符串结尾标志。

.. attention::

   在C语言标准库cstdio、cstring、cstdlib中都定义了一个C语言宏 ``#define NULL 0``，所以如果引入过这几个库之一，就可以用 ``NULL`` 来代替 ``'\0'``。但是实际上在C++语言中，出于 ``NULL`` 这个用法有很麻烦的多义性，比如它可以用来表示整数0、可以表示空字符、也可以用来表示空指针，所以C++不推荐使用这个符号。

   在字符串处理时如果要表示空字符，建议还是使用 ``'\0'``，如果要表示空指针，则应该用 ``nullptr`` 这个符号。

字符在字符表中的顺序由它们在表里的编号的大小来确定。所以空字符是最小的字符。在ASCII编码表中，常见的用于字符串的字符顺序如下：

.. code-block:: none

   '\0' < '\t' < '\n' < ' ' < '0' < ... < '9' < 'A' < ... < 'Z' < 'a' < ... < 'z'

完整的ASCII码表可以查询相关资料，但知道上面这些字符的顺序关系在做一般的字符串处理时就足够了。

知道了字符的编码顺序之后就很容易理解字符串的字典序规则了，规则一共就三条：

1. 按照从左到右的顺序逐个比较两个字符串对应位置上的字符大小，直到找到第一个字符不相等的位置或有一个字符串结束。
2. 第一个字符不相等位置上，哪个字符串的字符小这个字符串的字典序就小；如果有一个字符串结束了还没有找到字符不相等的位置，那么短的那个字符串的字典序小（对于C-string，短的更小的规则是天然适应的，因为短的那个字符串在结尾处有一个天然最小的空字符）。
3. 如果一直没有找到字符不相等的位置，而两个字符串同时结束了，那么认为二者的字典序相同（这也就是两个字符串长度相同、每一个位置上的字符都相等）。

按照这一套比较规则，我们可以举几个例子：``"ABCD" < "BCD"``，``"AB" < "ab"``，``"X" < "XYZ"``，``"hello" < "world"``。可见对于纯英文字母构成的字符串，它们的排列顺序和英语词典中对单词的排列顺序是一致的，这也是字典序这个名称的由来。但是如果是纯数字字符构成的整数形式的字符串，却并不是和它们对应的数值顺序一致的，例如 ``"87" < "9"``，而整数87显然比9大。这一点一定要记住。

C语言标准库cstring中的 ``strcmp()`` 和 ``strncmp()`` 两个函数就是根据字典序来比较两个字符串（或字符串片段）的大小的。而对于C++ string则更加简单直观，我们可以直接用关系比较运算符 ``==, !=, <, >, <=, >=`` 来对两个string进行字典序比较。


C-string小结
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

现在我们对字符串处理的一些基本概念和最基本的一些操作都已经学完了。字符串是一类重要的信息类型，字符串处理是计算机信息处理中最为重要的技术之一。从概念本身来讲，字符串就是由一连串连续字符构成的信息串，只是不同的编程语言对于字符串的表示形式各有不同，其内在本质都是相同的。

在C++语言来说，C-string和C++ string类都是其表示字符串的形式。从C语言继承而来的C-string最大的优势是速度快，所以现在许多的程序还在坚持使用C-string来进行字符串处理。常用的C-string处理都采用cstring库中的C语言标准库函数，前面已经看到过许多，在cstdio库中也提供了几套用于字符和C-string输入输出的库函数。这些库函数最大的特点也是速度非常的快，如果用C-string来进行字符串处理，就离不开这些库函数的使用。下面对它们进行一个小结。

**8个C-string常用库函数**

与C-string基本处理相关的库函数全部由cstring库提供，使用前必须引入 ``#include <cstring>``。

1. ``size_t strlen(const char *s);``

   获取C-string ``s`` 的实际长度。

2. ``size_t strlen(const char *s, size_t maxlen);``

   获取C-string ``s`` 的实际长度，但以 ``maxlen`` 为上限，即如果长度超过 ``maxlen`` 则返回 ``maxlen`` 的值。

3. ``char *strcpy(char * dst, const char * src);``

   将C-string ``src`` 的内容复制到C-string ``dst`` 中，返回值就是指向 ``dst`` 的指针。

   需注意，此函数复制时并不考虑 ``dst`` 的长度是否足够，因此可能引起超限错误，需要程序自己确保足够的空间。

4. ``char *strncpy(char * dst, const char * src, size_t len);``

   将C-string ``src`` 中最多 ``len`` 个字符复制到C-string ``dst`` 中，返回值就是指向 ``dst`` 的指针。

   需注意，若 ``src`` 的实际长度超过 ``len``，那么复制之后不会自动在 ``dst`` 中添加空字符 ``'\0'`` 作为结尾标志，因此这种情况下 ``dst`` 不保证有正确的结尾。

5. ``int strcmp(const char *s1, const char *s2);``

   比较 ``s1`` 和 ``s2`` 的字典序，若二者相等，则返回0；若 ``s1`` 先于（小于）``s2`` 则返回一个负数；若 ``s1`` 后于（大于）``s2`` 则返回一个正数。

6. ``int strncmp(const char *s1, const char *s2, size_t n);``

   比较 ``s1`` 和 ``s2`` 的字典序，返回值的规则和 ``strcmp()`` 函数相同，但是最多只比较前 ``n`` 个字符。

7. ``char *strcat(char *restrict s1, const char *restrict s2);``

   将 ``s2`` 的内容拼接到 ``s1`` 的后面，返回指向 ``s1`` 的指针。

   需注意：此函数并不考虑 ``s1`` 中的长度是否足够，因此可能引起超限错误，需要程序自己确保足够的空间。

8. ``char *strncat(char *restrict s1, const char *restrict s2, size_t n);``

   将 ``s2`` 中最多 ``n`` 个字符拼接到 ``s1`` 的后面，返回指向 ``s1`` 的指针。

**C-string输入输出**

与C-string的输入输出相关的库函数都在cstdio库中提供，使用前必须引入 ``#include <cstdio>``。

1. ``scanf()`` 和 ``printf()``。

   此二者是最为常用的C-string输入输出函数，占位符为 ``%s``。在输入时，可以添加长度限制 ``%ns``，其中 ``n`` 是一个整数，表示最多读入 ``n`` 个字符，不包括最后的结尾标志 ``'\0'``。因此这个长度限制至少应该要比实际的字符数组长度小1。例如：

   .. code-block:: c++

      char s[81];
      scanf("%80s", s);  // 请注意这里限制的长度是80而不是81
      printf("You entered: %s\n", s);

   优点：功能强大灵活，可以和多个别的数据同时输入输出。例如：

   .. code-block:: c++

      char s[81];
      unsigned short age;

      scanf("%80s %hu", s, &age);  // 请注意这里限制的长度是80而不是81
      printf("NAME is %s, AGE = %hu\n", s, age);

   缺点：``scanf()`` 只能输入以“单词”为单位的字符串，即字符串中不能出现空白符（空格、tab、换行）。例如上面那个例子中，如果要输入的名字是Bill Gates，那么就会出错，``s`` 只会读到Bill就结束了。

2. ``gets()`` 和 ``puts()``

   这两个函数称为“按行”读写字符串的一对函数。顾名思义，按行读写就是一行一行的读和写，所谓“行”就是以换行符 ``'\n'`` 为间隔的字符串，中间允许有空格、tab等任何只要不是 ``'\n'`` 的字符。

   首先来看按行输入字符串的函数 ``gets()``，它的函数原型是 ``char *gets(char *str);``。这个函数从标准输入设备stdin，通常就是键盘，读取一行字符，存放于 ``str`` 并自动在末尾添加空字符 ``'\0'`` 以标志字符串结尾。它的返回值就是 ``str``。这个函数在按行读入字符串之后，会自动把最后的换行符 ``'\n'`` 舍弃掉。

   按行输出字符串的函数 ``puts()`` 的函数原型是 ``int puts(const char *s);``。它将字符串 ``s`` 输出到标准输出设备stdout，通常就是终端窗口。它会自动在字符串输出完成后再额外输出一个换行符 ``'\n'``，不需要程序自己去进行换行，这也就是它被称为按行输出函数的原因。

   例如，下面这个简单的程序是一个复读机程序，它可以不断地复制你输入的每一行文字，直到遇到一个空行（只含一个换行符的行）：

   .. code-block:: c++

      #include <cstdio>
      #include <cstring>
      
      int main()
      {
              char s[80];
              while (strlen(gets(s))) puts(s);
              return 0;
      }

   看上去很好用，对不对？在过去的好时光里，``gets()`` 和 ``puts()`` 是算法编程时非常好用非常受欢迎的一对按行读写字符串的函数。然而现在我们却要强烈建议大家不要使用这一对函数，为什么呢？如果我们去编译上面这个简单的小程序，十有八九会得到这样一句警告：

   ``warning: this program uses gets(), which is unsafe.``

   意思是：这个程序使用了不安全的 ``gets()`` 函数。

   更有甚者，有些环境（例如苹果的MacOS）下编译时可能不会警告，但是每次运行程序的时候都会先输出这一条警告信息。这样，程序就不可能通过了。而且，现在算法竞赛使用的C++98标准还可以使用这一对函数，但从C++11开始干脆就已经从语言的cstdio库中删除了这一对函数。

   为什么会这样呢？如果你对C-string处理非常熟悉，或者对编程时的常见bug非常熟悉的话，可能已经猜到了原因：``gets()`` 函数对读入的字符串长度没有限制！它会傻傻地一直读到第一个遇到的换行符为止，并把所有读入的字符都存放在它的参数所指向的地址开始的内存空间里，不管是不是超限。而这个漏洞已经多次被黑客利用来植入病毒、蠕虫等有害代码。所以，我们不要使用这对函数，这里对它们进行介绍只是为了让大家认识它们俩，毕竟还有不少算法书里会用它们，遇到的时候能看懂就可以了。

   .. warning::

      任何时候不要在你的程序中使用 ``gets()`` 和与之配套的 ``puts()`` 函数。如果程序需要按行读写字符串，那么使用下面介绍的这一对 ``fgets()`` 和 ``fputs()`` 函数。

3. ``fgets()`` 和 ``fputs()``

   这一对函数是用来替代前面所述的不安全的 ``gets()`` 和 ``puts()`` 的。它们的功能同样是按行读写字符串，但和前面那一对函数有所不同。

   按行读取字符串函数：``char *fgets(char *str, int size, FILE *stream);``。这个函数现在有了三个参数，第一个参数 ``str`` 是要读入字符串的位置；第二个参数 ``size`` 是读字符量的上限，每次读取最多读 ``size-1`` 个字符，因为后面还要有一个位置放结尾空字符；第三个参数 ``stream`` 是输入设备，如果是标准输入设备键盘就直接写stdin，如果是从某个文件读入那么就是这个文件的指针（打开文件时返回的指针，很多教科书上管这个东西叫文件的\ :strong:`句柄`）。

   与之配套的按行输出字符串函数：``int fputs(const char *s, FILE *stream);``。这个函数现在除了要输出的字符串 ``s`` 以外也多了一个 ``stream`` 参数，猜猜也知道这是表示输出设备的参数，如果是标准输出设备终端窗口就直接写stdout，如果是写入到某个文件那么就是这个文件的句柄。

   要注意，``fputs`` 函数不像它的前任 ``puts()`` 函数那样会在输出字符串之后自动添加一个换行。``puts()`` 会这么做是因为它是和 ``gets()`` 配套使用的，而 ``gets()`` 函数在读入完成后会自动删除行末的换行符，所以 ``puts()`` 觉得它有责任添加回去。但是 ``fputs()`` 是和 ``fgets()`` 配套使用的，``fgets()`` 在输入完成后并不会删除行尾的换行符！如果字符串末尾是一个换行符，那么这个换行符会被保留在字符串里面！所以 ``fputs()`` 就觉得自己没必要画蛇添足去加一个换行。

   现在我们可以把上面这个复读机程序改写为安全的版本了：

   .. code-block:: c++
      
      #include <cstdio>
      
      int main()
      {
              char s[80];
              while (fgets(s, 80, stdin)[0] != '\n') // size=数组长度80，无需减1，但每次最多读79个字符
                      fputs(s, stdout);
              return 0;
      }
   
   ``fgets()`` 读入的字符串，末尾很可能是一个换行符。如果我们认为换行符不是我们要的字符串的一部分，那么就需要自己编写代码来删除这个可能存在的 ``'\n'``，代码如下：

   .. code-block:: c++

      int last = strlen(s) - 1;
      if (s[last] == '\n') str[last] = '\0';


4. ``getchar()`` 和 ``putchar()``


（待续）
