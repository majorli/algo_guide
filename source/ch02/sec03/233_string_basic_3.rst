字符串处理基础知识(III)
++++++++++++++++++++++++++++++++

这一节我们对字符串处理的其他几个重要的基本知识点进行说明。

字典序
^^^^^^

在C++语言和所有的计算机编程语言里，字符串都是可以比较“大小”的，或者更准确地说，字符串是可以有序的。我们知道，实数也是有序的，实数的序依据的是它们的大小而定的。字符串本身并没有大小的区别，比如 "hello" 和 "world" 这两个字符串谁大谁小呢？因此字符串的序依据的不是它们本身的大小，而是依据组成字符串的字符在字符表中的顺序而确定的，称为\ :strong:`字典序`。

在算法编程的环境里使用的字符表是ASCII码表，共有127个字符，包括了数字、大小写字母、常见的标点符号、算术运算符号、空白符（空格、换行、tab）和其他一些控制字符，另外还有一个非常特别的空字符 ``'\0'``，对应的数值编号为0，在C-string里用于表示字符串结尾标志。

.. attention::

   在C语言标准库cstdio、cstring、cstdlib中都定义了一个C语言宏 ``#define NULL 0``，所以如果引入过这几个库之一，就可以用 ``NULL`` 来代替 ``'\0'``。但是实际上在C++语言中，出于 ``NULL`` 这个用法有很麻烦的多义性，比如它可以用来表示整数0、可以表示空字符、也可以用来表示空指针，所以C++不推荐使用这个符号。

   在字符串处理时如果要表示空字符，建议还是使用 ``'\0'``，如果要表示空指针，则应该用 ``nullptr`` 这个符号。

字符在字符表中的顺序由它们在表里的编号的大小来确定。所以空字符是最小的字符。在ASCII编码表中，常见的用于字符串的字符顺序如下：

.. code-block:: none

   '\0' < '\t' < '\n' < ' ' < '0' < ... < '9' < 'A' < ... < 'Z' < 'a' < ... < 'z'

完整的ASCII码表可以查询相关资料，但知道上面这些字符的顺序关系在做一般的字符串处理时就足够了。

知道了字符的编码顺序之后就很容易理解字符串的字典序规则了，规则一共就三条：

1. 按照从左到右的顺序逐个比较两个字符串对应位置上的字符大小，直到找到第一个字符不相等的位置或有一个字符串结束。
2. 第一个字符不相等位置上，哪个字符串的字符小这个字符串的字典序就小；如果有一个字符串结束了还没有找到字符不相等的位置，那么短的那个字符串的字典序小（对于C-string，短的更小的规则是天然适应的，因为短的那个字符串在结尾处有一个天然最小的空字符）。
3. 如果一直没有找到字符不相等的位置，而两个字符串同时结束了，那么认为二者的字典序相同（这也就是两个字符串长度相同、每一个位置上的字符都相等）。

按照这一套比较规则，我们可以举几个例子：``"ABCD" < "BCD"``，``"AB" < "ab"``，``"X" < "XYZ"``，``"hello" < "world"``。可见对于纯英文字母构成的字符串，它们的排列顺序和英语词典中对单词的排列顺序是一致的，这也是字典序这个名称的由来。但是如果是纯数字字符构成的整数形式的字符串，却并不是和它们对应的数值顺序一致的，例如 ``"87" < "9"``，而整数87显然比9大。这一点一定要记住。

C语言标准库cstring中的 ``strcmp()`` 和 ``strncmp()`` 两个函数就是根据字典序来比较两个字符串（或字符串片段）的大小的。而对于C++ string则更加简单直观，我们可以直接用关系比较运算符 ``==, !=, <, >, <=, >=`` 来对两个string进行字典序比较。


含空白符的字符串
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



C-string输入输出小结
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

（待续）
