字符串处理基础知识(II)
++++++++++++++++++++++++++++++++

**子串**

:strong:`子串`\ （substring），又叫\ :strong:`子字符串`，是字符串处理技术中特别重要的一个基本概念。子串是指一个字符串中的任意一个连续片段，子串单独拿出来也是一个字符串。例如 "abc" 是 "abcdef" 的子串，它是由后者的前三个连续字符构成的字符串。又如 "world" 是字符串 "hello world" 的子串。

特殊地，一个字符串中的任何一个单独的字符都构成这个字符串的子串。例如 "a", "b", "c" 都是字符串 "abc" 的子串。

更特殊的，空字符串 "" 是任何一个字符串的子串，字符串本身也是它自己的一个子串。所以空字符串 "" 也有而且只有一个子串，就是空字符串 "" 本身。

.. hint::

   长度为 :math:`n` 的字符串，它的子串个数是 :math:`O(n^2)` 的量级。

请注意，子串和上一节的子序列问题中所说的子序列是不同的。子串必须是连续的一个片段，而子序列可以不连续，只要保持字符的顺序不变即可。

子串的最基本操作有两个：提取和搜索。

:strong:`子串提取`，也叫\ :strong:`字符串切片`，是指从一个字符串中切出指定的一个片段（通常是指定起始位置和长度），获得一个子串的操作。

:strong:`子串搜索`，也叫\ :strong:`子串匹配`，是指在一个字符串中搜索是否存在与另一个字符串相同的子串的操作。

**C-string的子串处理**

cstring库中提供了一些库函数用于C-string的子串操作，但功能并不是特别强，但能满足大多数最基本的需要。

由于C-string天生的数组性质，子串提取是相当方便的，一般情况下使用 ``strncpy()`` 函数即可。cstring标准库提供了两个用于复制C-string的库函数：``strcpy()`` 和 ``strncpy()``。前者用于完整地复制一个字符串的内容到另一个字符串中去，后者则可以额外指定复制的最大字符数，如果源字符串有那么多个字符就复制那么多个字符，如果没有就复制到源字符串末尾为止。这两个函数的用法如下：

.. code-block:: c++
   
   char s1[20] = "hello world";
   char s2[20] = { 0 }, s3[20] = { 0 }, s4[20] = { 0 };
   
   strcpy(s2, s1);         // 完整地复制s1到s2中去，s2成为 "hello world"
   strcpy(s3, s1+6);       // 复制从s1[6]开始到s1末尾的所有内容复制给s3，即 "world"
   strncpy(s4, s1+7, 2);   // 从s1[7]开始复制2个字符给s4，即 "or"


.. warning::

   1. 使用 ``strcpy()`` 和 ``strncpy()`` 时一定要注意，目标位置的可用空间是否足够需要编程人员自己来保证，C++不会检查复制时会否发生数组超限。
   2. 函数参数的顺序是目标字符串在前，源字符串在后，这一点很容易搞错。
   3. ``strncpy()`` 函数在复制完指定数量的字符后并不会自动在目标末尾添加空字符 ``'\0'``，这也是编程人员自己的责任。

实际上，自己写一个根据起始位置和长度提取子串的工具函数也很简单，请大家务必尝试一下。

cstring库当然也提供了用于子串搜索的库函数，``strstr()`` 和 ``strcasestr()``，后者和前者唯一的区别是搜索时忽略大小写，所以我们仅对 ``strstr()`` 的用法进行简单的介绍。

.. hint::

   事实上，子串搜索是一个非常重要的算法类型，包括许多经典的搜索和匹配算法，比如经典的KMP算法、比较复杂的通配符匹配、非常强大但也复杂的正则表达式匹配等。以后我们会专题学习这些算法。但是在实际编程时如果仅是最普通的子串搜索，那么使用库函数是更好的选择。

如果去看 ``strstr()`` 函数的说明，可以发现它接受两个参数，前一个叫 ``const char *haystack``，意思是“干草堆”，后一个叫 ``const char *needle``，意思是“针”，函数的原型如下：

.. code-block:: c++

   char *strstr(const char *haystack, const char *needle);

看来英语里并没有“大海捞针”这个成语，但一定有“干草堆里找针”这种说法，而早期C语言标准库的设计者们显然认为子串搜索就是一件类似“干草堆里找针”的麻烦事情。想必大家一定猜到哪个参数是源字符串，哪个参数是要去找的那个子串了吧？对的，这个函数的功能就是从干草堆字符串 haystack 中去搜索第一个和针字符串 needle 内容一致的子串，返回的是子串的起始位置指针。如果找不到这根针，那么返回的是空指针 ``NULL``。特殊地，如果针是空字符串，那么返回的就是干草堆的指针。

例如：

.. code-block:: c++

   char s1[20] = "hello world", s2[20] = "or";

   char *p1 = strstr(s1, s2);           // 将返回指向s1中第一次出现 "or" 的首位置，即 s1+7
   char *p2 = strstr(s1, "World");      // 将返回空指针NULL，表示搜索不到 "World"
   char *p3 = strcasestr(s1, "World");  // 忽略大小写后，将返回s1+6


.. admonition:: 问题

   请大家思考一下，假如在干草堆中不止有一根针，如何利用 ``strstr()`` 函数把所有这些针的位置都依次找出来？例如，从 "this is the Mississippi" 中搜索 "is"，一共会有4个，你能不能编一个程序把它们从前往后一个个地都找出来吗？一定要动手试一试哦。

相比之下，C++ string的子串处理功能就强大多了，使用起来也更加方便。但是现在先不做介绍，留待以后遇到时在说。接下来先让我们学习两个字符串处理的基础题：最长无重复字符子串和Z字形变换。这两个题目来自著名的力扣（LeetCode）网站，它们在处理技巧上比上一节的两题略有提升。



最长无重复字符子串（LeetCode#3）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

问题：输入一个长度不超过80的字符串 :math:`s`，找出其中最长的不含重复字符的子串的长度。

例如：

输入 ``"abcabcbb"``，应输出3，因为其中最长的无重复字符子串为 ``"abc"`` 或 ``bca`` 或 ``cab``，长度均为3，没有比这更长的了。

输入 ``"aaaaaaaa"``，应输出1。

输入 ``"pwwkew"``，则应输出3，对应的子串为 ``"wke"`` 或 ``"kew"``。

假如暴力枚举输入字符串中的所有子串，并逐个遍历子串中是否有重复字符，那么这个算法的时间复杂度会非常高。我们前面说过，一个长度为 :math:`n` 的字符串，其子串数量为 :math:`O(n^2)` 级。判断一个字符串中是否有重复字符，需要从头到尾遍历每一个字符，是 :math:`O(n)` 级别的运算，所以这种暴力枚举法的时间复杂度为 :math:`O(n^3)` 级别，显然太慢了。

事实上，我们可以通过记录每一个字符在字符串中上一次出现的位置，实现一遍扫描解决问题，时间复杂度为 :math:`O(n)`。

设 :math:`s` 的长度为 :math:`n`，用一个整数数列 :math:`p_{ch}` 来存放每一个ASCII字符 :math:`ch` 在 :math:`s` 中上一次出现的位置。位置的取值范围为 :math:`[0,n-1]`。

用两个位置索引 :math:`i` 和 :math:`j` 分别表示无重复字符子串头尾两端的位置，初始值全部为0。然后我们让 :math:`j` 从头到尾地扫描 :math:`s` 中的每一个字符 :math:`s_j,(j=0,1,\dots,n-1)`。每扫描一个字符就做如下操作：

1、如果 :math:`p_{s_j} \ge i`，也就是说字符 :math:`s_j` 上一次在 :math:`s` 中出现的位置不在子串头位置 :math:`i` 之前，说明在子串 :math:`[s_i \cdots s_j]` 内，已经有和 :math:`s_j` 重复的字符出现过了，位置就是在 :math:`p_{s_j}` 上。例如下面这种情况：

.. code-block:: none

   s: abcdefghcbd
      ^       ^
      i=0     j=8
   
   此时'c'字符上一次出现的位置为：p['c'] = 2，而 i = 0

这种情况下，今后的无重复字符子串的头部就应该从该字符上一次出现的位置之后开始了，所以我们应该把 :math:`i` 调整为 :math:`p_{s_j}+1`，然后把 :math:`p_{s_j}` 改为 :math:`j`：

.. code-block:: none

   s: abcdefghcbd
         ^    ^
         i=3  j=8
   
   调整后，i 变为 p['c']+1 = 3，而表示'c'字符上一次出现的位置的 p['c'] 则改为了 j = 8

这样，子串 :math:`[s_i \cdots s_j]` 就能始终保持无重复字符，并且随着 :math:`j` 的逐渐后移，一直跟踪着 :math:`s` 中的所有无重复字符子串。

2、如果 :math:`p_{s_j} \lt i`，说明字符 :math:`s_j` 没有在 :math:`s` 中出现过，或者在子串 :math:`[s_i \cdots s_j]` 之前出现过，已经不在当前考虑的范围内了。例如上面这个例子，当 :math:`j` 继续向后移动一个字符时：

.. code-block:: none

   s: abcdefghcbd
         ^     ^
         i=3   j=9
      
   字符'b'曾经出现过，位置为 p['b'] = 1，但是当前 i = 3 > 1
   这说明上次那个'b'现在已经不用考虑了，相当于从来没有出现过

所以这种情况下只要简单地更新一下 :math:`s_j` 的出现位置，让 :math:`p_{s_j}=j` 即可。

3、上述步骤处理完之后，:math:`i` 和 :math:`j` 就指向了一个新的无重复字符子串，长度为 :math:`j-i+1`，而我们的算法就是要统计出每一个这种长度中的最大值，这应该是一个很熟悉的操作了吧。

下面就是实现上述算法过程的程序代码：

.. literalinclude:: ../../codes/232_lc3.cpp
   :language: c++

.. note::

   由于ASCII字符编码的最大值为127，所以位置数组 ``pos`` 的长度设为128。

   使用了块操作一次性给 ``pos`` 数组的所有元素设置初始值-1，如果忘了块操作和 ``memset()`` 函数的用法，请复习这里：:ref:`批量赋值<ref_130_memset>`。


.. admonition:: 问题

   这个题目还有另一种 :math:`O(n)` 时间的算法，它不记录每一个字符上一次出现的位置，而是记录它出现的次数。当某个字符第一次出现重复的时候，它根据一定的规则去调整 :math:`i` 和 :math:`j` 的值。这个算法在思路上和我们用的算法是一致的，都是滑动窗口的思路，只是在实现方式上略有改变。请大家动脑筋想一想，自己设计出这种算法并编程验证。



Z字形变换（LeetCode#6）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



（待续）


