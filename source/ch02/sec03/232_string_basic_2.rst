字符串处理基础知识(II)
++++++++++++++++++++++++++++++++

**子串**

:strong:`子串`\ （substring），又叫\ :strong:`子字符串`，是字符串处理技术中特别重要的一个基本概念。子串是指一个字符串中的任意一个连续片段，子串单独拿出来也是一个字符串。例如 "abc" 是 "abcdef" 的子串，它是由后者的前三个连续字符构成的字符串。又如 "world" 是字符串 "hello world" 的子串。

特殊地，一个字符串中的任何一个单独的字符都构成这个字符串的子串。例如 "a", "b", "c" 都是字符串 "abc" 的子串。

更特殊的，空字符串 "" 是任何一个字符串的子串，字符串本身也是它自己的一个子串。所以空字符串 "" 也有而且只有一个子串，就是空字符串 "" 本身。

.. hint::

   长度为 :math:`n` 的字符串，它的子串个数是 :math:`O(n^2)` 的量级。

子串的最基本操作有两个：提取和搜索。

:strong:`子串提取`，也叫\ :strong:`字符串切片`，是指从一个字符串中切出指定的一个片段（通常是指定起始位置和长度），获得一个子串的操作。

:strong:`子串搜索`，也叫\ :strong:`子串匹配`，是指在一个字符串中搜索是否存在与另一个字符串相同的子串的操作。

**C-string的子串处理**

cstring库中提供了一些库函数用于C-string的子串操作，但功能并不是特别强，但能满足大多数最基本的需要。

由于C-string天生的数组性质，子串提取是相当方便的，一般情况下使用 ``strncpy()`` 函数即可。cstring标准库提供了两个用于复制C-string的库函数：``strcpy()`` 和 ``strncpy()``。前者用于完整地复制一个字符串的内容到另一个字符串中去，后者则可以额外指定复制的最大字符数，如果源字符串有那么多个字符就复制那么多个字符，如果没有就复制到源字符串末尾为止。这两个函数的用法如下：

.. code-block:: c++
   
   char s1[20] = "hello world";
   char s2[20] = { 0 }, s3[20] = { 0 }, s4[20] = { 0 };
   
   strcpy(s2, s1);         // 完整地复制s1到s2中去，s2成为 "hello world"
   strcpy(s3, s1+6);       // 复制从s1[6]开始到s1末尾的所有内容复制给s3，即 "world"
   strncpy(s4, s1+7, 2);   // 从s1[7]开始复制2个字符给s4，即 "or"


.. warning::

   1. 使用 ``strcpy()`` 和 ``strncpy()`` 时一定要注意，目标位置的可用空间是否足够需要编程人员自己来保证，C++不会检查复制时会否发生数组超限。
   2. 函数参数的顺序是目标字符串在前，源字符串在后，这一点很容易搞错。
   3. ``strncpy()`` 函数在复制完指定数量的字符后并不会自动在目标末尾添加空字符 ``'\0'``，这也是编程人员自己的责任。

实际上，自己写一个根据起始位置和长度提取子串的工具函数也很简单，请大家务必尝试一下。

cstring库当然也提供了用于子串搜索的库函数，``strstr()`` 和 ``strcasestr()``，后者和前者唯一的区别是搜索时忽略大小写，所以我们仅对 ``strstr()`` 的用法进行简单的介绍。

.. hint::

   事实上，子串搜索是一个非常重要的算法类型，包括许多经典的搜索和匹配算法，比如经典的KMP算法、比较复杂的通配符匹配、非常强大但也复杂的正则表达式匹配等。以后我们会专题学习这些算法。但是在实际编程时如果仅是最普通的子串搜索，那么使用库函数是更好的选择。

如果去看 ``strstr()`` 函数的说明，可以发现它接受两个参数，前一个叫 ``const char *haystack``，意思是“干草堆”，后一个叫 ``const char *needle``，意思是“针”，函数的原型如下：

.. code-block:: c++

   char *strstr(const char *haystack, const char *needle);

看来英语里并没有“大海捞针”这个成语，但一定有“干草堆里找针”这种说法，而早期C语言标准库的设计者们显然认为子串搜索就是一件类似“干草堆里找针”的麻烦事情。想必大家一定猜到哪个参数是源字符串，哪个参数是要去找的那个子串了吧？对的，这个函数的功能就是从干草堆字符串 haystack 中去搜索第一个和针字符串 needle 内容一致的子串，返回的是子串的起始位置指针。如果找不到这根针，那么返回的是空指针 ``NULL``。特殊地，如果针是空字符串，那么返回的就是干草堆的指针。

例如：

.. code-block:: c++

   char s1[20] = "hello world", s2[20] = "or";

   char *p1 = strstr(s1, s2);           // 将返回指向s1中第一次出现 "or" 的首位置，即 s1+7
   char *p2 = strstr(s1, "World");      // 将返回空指针NULL，表示搜索不到 "World"
   char *p3 = strcasestr(s1, "World");  // 忽略大小写后，将返回s1+6


.. admonition:: 问题

   请大家思考一下，假如在干草堆中不止有一根针，如何利用 ``strstr()`` 函数把所有这些针的位置都依次找出来？例如，从 "this is the Mississippi" 中搜索 "is"，一共会有4个，你能不能编一个程序把它们从前往后一个个地都找出来吗？一定要动手试一试哦。

相比之下，C++ string的子串处理功能就强大多了，使用起来也更加方便。但是现在先不做介绍，留待以后遇到时在说。接下来先让我们学习两个字符串处理的基础题：最长无重复字符子串和Z字形变换。这两个题目来自著名的编程能力训练与测试网站“力扣”（LeetCode），它们在处理技巧上比上一节的两题略有提升。


最长无重复字符子串（LeetCode#3）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Z字形变换（LeetCode#6）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



（待续）


