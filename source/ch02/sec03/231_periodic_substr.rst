字符串处理基础
++++++++++++++++++++++++++++++++

**基本概念**

字符串说到底就是由一系列字符按照一定顺序排列而成的，我们目前只处理ASCII字符串，在C++语言中就是一连串的char。正如前面所说，C++有继承自C语言的C-string和自己特有的C++ string类型两种字符串解决方案。

1、传统的C-string采用一个char型数组来存放字符串，以一个空字符 ``\0`` 来标识字符串的结尾，例如：

.. code-block:: c++

   char str[10] = "Hello\n";

就是一个字符串，在内存中，这个C-string的实际存储情况是：

.. image:: ../../images/231_cstring.png


由于C-string本质上就是一个数组，所以可以用访问数组元素的方式访问其中的单个字符，例如 ``str[0]`` 就是第1个字符 ``'H'``。也可以方便地使用指针，还记得数组的名字就是指向第一个元素的指针吗？所以 ``*(str+5)`` 就是第6个字符 ``'\n'``，这是一个“换行”字符（newline）。每个C-string的最后一定要用一个空字符 ``'\0'`` （NULL）来标识结尾，否则C++就不知道该到哪里结束了，这个特殊的空字符的实际数值就等于0，所以可以视作整数0，也可以视作逻辑值false，这就给C-string的字符串处理带来了很大的便利。

.. attention::

   正因为有一个空字符收尾，C-string才成为了字符串，而不是普通的字符数组。但是这个空字符是不计入字符串的长度的。

.. warning::

   和数组一样，采用C-string方式处理字符串，最大的危险是长度超限。一定要记住，长度为n的数组，最多能存放的字符串长度为n-1！因为至少要留出一个元素的位置来存放收尾的空字符。

要处理C-string方式的字符串，需要引入C语言标准库cstring，其中包含了一些最基本的字符串处理函数，例如测量长度、收尾相接、复制内容、字典序比较、子串搜索等。它们的共同点是速度快，使用简单，但是功能有限，有几个函数使用起来还有点怪异。

2、C++的string类型则是一个定义完好的封装起来的类，它的底层是向程序员隐蔽起来的，但它开放了许多功能强大的成员函数供编程使用。定义一个C++ string非常方便，和定义一个基本数据类型的变量一模一样，例如：

.. code-block:: c++

   string str = "Hello\n";


要访问string中指定位置的字符，也有两种方法，和C-string非常类似。通常我们也用 ``[]`` 下标运算符，例如 ``str[1]`` 就可以访问到第2个字符 ``'e'``。也可以用和指针非常相似的迭代器来访问元素，``str.begin()`` 返回头迭代器，指向第1个字符，``str.end()`` 则返回尾迭代器，指向最后一个字符的后面一个位置。所以 ``*(str.begin()+1)`` 就是第2个字符 ``'e'``，而 ``*(str.end()-1)`` 则是最后一个字符 ``'\n'``。我们可以自己定义一个类型为 ``string::iterator`` 的变量来存放迭代器。例如下面这段代码片段会从尾到头逆向地输出字符串中的每一个字符：

.. code-block:: c++

   for (string::iterator it = str.end(); it >= str.begin(); --it)
           cout << *it;

string是一个定义完好的C++类，它除了速度比C-string略慢外，其他各方面都比C-string要优秀得多。例如它没有长度超限的危险，它可以自动根据内容来调整自己占用的空间，它的成员函数也比cstring库函数丰富和强大得多。

在后面的内容中我们先使用C-string来进行简单字符串处理，当对C-string及其常用操作有了一定的了解，能够阅读一些简单的程序代码的时候就将转为全面使用C++ string。这一节我们先来看两个非常简单的问题：周期串判断和子序列判断。这是《算法入门经典（第2版）》第三章的两个练习题，都是来自OJ网站UVa的题目。


.. index:: 【周期串】, 〖UVa455〗

周期串问题（UVa455）
^^^^^^^^^^^^^^^^^^^^^^

:strong:`周期串`\ 是指这样一种字符串，它是由某一个非空字符串重复若干次之后得到的。例如 "abcabcabcabc" 就是一个周期串，它是由 "abc" 重复4次之后得到的，也可以认为是由 "abcabc" 重复2次得到的。:strong:`周期`\ 是指被重复的那个短字符串的长度，所以一个周期串可能有多个周期。例如前面举的这个例子里，如果把它看作是 "abc" 重复4次，那么它的周期就是3；如果看作是 "abcabc" 重复2次，那么周期就是6。所有周期中最小的那个叫做\ :strong:`最小正周期`。

特别要注意，任何一个非空字符串都可以看成是由它自己重复1次得到的，所以任何非空字符串都可视作是一个以它自身的长度为周期的周期串。例如 "abcabcabcabc" 的周期可以是12，"Hello,World!" 也可以看作是一个周期为12的周期串。

现在，输入一个长度不超过80个字符、不含空白字符的非空字符串，请给出它的最小正周期。例如输入 "abcabcabcabc"，那么输出3；如果输入 "Hello,World!" 那么输出12。

**解题思路**

一个字符串 :math:`s`，若其长度为 :math:`n`。那么它的周期可能有哪些呢？显然周期的取值范围一定是在区间 :math:`[1,\lfloor n/2 \rfloor]` 内的，而且这个周期一定能被 :math:`n` 整除。所以我们需要从1开始逐个测试这个范围内的每一个 :math:`n` 的因数是不是 :math:`s` 的周期，第一个找到是周期的因数就是最小正周期，所以数都测试失败那么周期就是 :math:`n`。

这就是算法的大框架，可以这样描述：

.. admonition:: 最小正周期算法

   :math:`\text{Min_Period}(s):`

      :math:`n \leftarrow \text{len}(s)`

      FOR :math:`p = 1 \to n/2`

         IF :math:`n \neq 0 \mod p` THEN continue

         IF :math:`\text{IsPeriod}(s, n, p) = \text{true}`

         THEN Return :math:`p`

      Return :math:`n`

第二步要解决如何判断一个数是不是周期的问题，也就是算法中调用的那个子算法 :math:`\text{PeriodicTest}(s, p)`。

测试的原理也很简单，我们只要对原字符串 :math:`s` 的所有长度为 :math:`p` 的分段进行逐个比较是否相等即可，设 :math:`n=kp`，则有：

.. math::

   s[0:p-1] = s[p:2p-1] = \cdots = s[(k-1)p:n-1] \iff p \text{是} s \text{的周期}

这个过程的算法描述如下：

.. admonition:: 判断是否周期算法

   :math:`\text{IsPeriod}(s, n, p):`

      FOR :math:`j = p \to n-p`

         IF :math:`s[0:p-1] \neq s[j:j+p-1]` THEN Return :math:`\text{false}`

      Return :math:`\text{true}`


**程序编写**

有了上述算法，要写出这样一个程序就不难了。我们现在用C-string来进行处理，首先要了解一些必要的C-string处理技术。

1、表示

C-string用字符数组表示。题中说明了输入的字符串长度不超过80个字符，但是考虑到最后还要有一个额外的空字符作为结尾，所以我们需要定义一个长度至少为81的字符数组用来接收输入的字符串。

2、输入

用cstdio库的标准输入函数 ``scanf()`` 可以输入不含空白符的字符串，占位符为 ``%s``。函数允许在占位符中提供一个限制长度，如果输入超长就会被截断为这个长度。

3、长度

用cstring库提供的函数 ``strlen()`` 即可方便地获取字符串的长度。

4、比较

cstring库提供了两个函数 ``strcmp()`` 和 ``strncmp()`` 来比较字符串，如果相等就返回0，否则就返回二者的字典序之差（按照字典对词语的排序方法对字符串进行排序，越前面的字典序越小）。这两个函数的不同之处在于，前者比较两个字符串的大小，后者比较两个字符串规定长度内的大小。

代码如下：

.. literalinclude:: ../../codes/231_period.cpp
   :language: c++



.. index:: 【子序列】, 〖UVa10340〗

子序列问题（UVa10340）
^^^^^^^^^^^^^^^^^^^^^^




（待续）
