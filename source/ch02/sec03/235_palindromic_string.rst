回文字符串
++++++++++++++++++

我们在前面简单数值算法时曾将讲过回文的概念，当时我们主要着眼于回文数，严格地说是回文整数的相关问题，现在我们要重点讲一讲回文字符串的一些基本算法。

我们已经知道回文的概念，所以回文字符串的概念就不言而明了，当然就是从左到右念和从右到左念完全一样的字符串，比如 ``"level"``，比如 ``"ABCDCBA"``。在这一节，我们先解决最基本的问题，怎样判断一个字符串是否为回文串。然后我们设法来解决一个经典的回文串问题，最大回文子串问题。

解决最大回文子串问题的方法有很多，我们先通过蛮力法来了解一些基本知识，然后学习一种比较容易理解和编程的方法：中心扩展法，它的时间复杂度是 :math:`O(n^2)`。由于中心扩展法编程比较简单，不使用什么复杂的数据结构，消耗空间仅为常数级的 :math:`O(1)`，时间上也能满足大多数提高组及以下难度算法题的限制，所以是初期比较好用的一种算法，需要认真学习掌握。

最大回文子串问题的另一个 :math:`O(n^2)` 时间算法是一种动态规划法，但它并不是很好。如果没有经过一些复杂的优化，根据在LeetCode网站实测的结果，它的运行时间是中心扩展法的20多倍之多，而且空间复杂度同样高达 :math:`O(n^2)`，因此我们只打算对它进行一个简单的原理介绍。希望能够让大家对五大经典算法设计方法中最灵活最难掌握的动态规划法有一个初步的认识，当然有兴趣的话也可以自己动手试一试。

而最经典的最大回文子串问题解法是一个叫做Manacher算法的方法，通常习惯用谐音称呼它为\ :strong:`马拉车算法`。这个算法非常高明，非常精妙，时间复杂度低至 :math:`O(n)`，但是这个算法非常复杂，非常难掌握。普及组和提高组水平时一般不太指望能在考场上快速地写出一个正确的马拉车算法程序来，所以我们将在后面的章节再详细介绍马拉车算法，现阶段能熟练掌握中心扩展算法即可。


回文串的判断
^^^^^^^^^^^^^^^^^^^^

我们在前面3.1.3节回文数专题中曾经学过判断回文整数的方法，通过把整数前后反转然后判断是否和原数相等即可判断原数是否为回文数。现在我们要判断一个字符串是不是回文串，当然我们可以延续这一思路，先用原字符串所有字符前后反转的顺序生成一个新的字符串，然后比较新字符串和原字符串是否相等来进行判断。但是这种方法不够好，既浪费时间又浪费空间。

要知道字符串这种东西和整数有一个很大的区别，字符串可以用位置索引来直接获取其中每一个位置上的字符，而整数每一位上的数码却没有那么容易地想取就取到的。所以我们可以利用字符串这一特性，用两个不同的位置指针分别指向首字符和尾字符。这样就可以直接比较首字符和尾字符是否相同，如果相同那么让首位置后移一个字符，尾位置前移一个字符继续比较，直到两个位置交错而过（此时字符串为回文串）或者在二者交错之前就发现有字符不同（不是回文串）。这个简单的模拟过程应该很好理解吧，下面直接出代码：

.. literalinclude:: ../../codes/235_ispalin.cpp
   :language: c++

这个简单的程序里面提供了两个版本的判断函数，``is_palin()`` 函数使用了数组加下标的形式来访问C-string中指定位置的字符，而指针版的 ``is_palin_p()`` 函数则采用两个字符型指针来一前一后地迭代访问字符。

.. admonition:: 补充

   数组版和指针版，二者的运行效果是完全一样的，但是有些人会说，指针迭代版本的速度更快一些。这是有道理的。如果用数组加下标的方式来访问某个字符，例如 ``s[i]``，那么程序要计算指针加法 ``s + i``，然后能找到这个字符所在的内存地址从而取得这个字符；如果使用指针，那么指针本身就是地址，直接就可以访问这个字符。所以数组版在取字符的时候会比指针版多计算一次指针加法，这就是指针迭代版本速度更快一些的原因。

   但是在实际应用中，大家完全不用担心这一点点的速度差距。在现代计算机芯片的强大运算能力和现代C++编译器的强大优化能力下，这点速度差异微不足道，尤其是在使用C-string这种本身就以速度见长的表示方式时，二者几乎没有任何差别。除非字符串的长度非常非常的巨大，数十甚至数百万位。

   对于速度相对较慢的C++ string，差异就会略大一些。为此C++提供了一种叫做string迭代器 ``string::iterator`` 的东西来代替原先的指针用以快速访问字符串中的字符，这东西其实就是包装过的指针，我们在下一节会进行介绍。即使这家伙光类型名就这么长，用起来也挺麻烦，但在对运行速度要求极严格的场合还是很有必要的。不过我们要知道，即使是C++ string，也要在字符串长度达到万这个级别的时候二者之间才会有可感知的速度差异。



最长回文子串（蛮力、动态规划和中心扩展）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

接下来我们要尝试解决“最长回文子串”这个经典的回文串问题：给出一个非空字符串 :math:`S`，找出其中最长的回文子串。如果答案有多个，那么返回从左到右顺序的第1个。

注意：这个问题必然有解，因为单字符的字符串都是回文串，所以对于任何非空字符串，至少有长度为1的回文子串。

一、蛮力法

蛮力法，就是暴力枚举 :math:`S` 的每一个子串，判断其是否为回文串。枚举时按照子串长度从大到小的顺序，这样第一个找到的回文子串就是长度最大的了。

暴力枚举需要用到两层嵌套循环。设 :math:`S` 的长度为 :math:`n`，外层循环是子串长度 :math:`L`，从 :math:`n` 到 :math:`1` 的逆向循环。内层循环是从左到右所有具有长度 :math:`L` 的子串，即从 :math:`S[0:L-1]` 到 :math:`S[n-L:n-1]`。在内层循环里逐个对这些子串进行回文串判断，只要找到一个就是答案，就直接退出所有循环。显然这是一个 :math:`O(n^3)` 的算法。

在实际编程时，我们当然不会傻到真的每次复制出子串来进行回文串判断。为了尽量提高运行效率，我们一般都会修改一下上面讲过的那种回文串判断函数，让函数接受一左一右两个指针，然后对这两个指针所指定的范围进行判断。这样在程序里我们就不需要进行来来回回地子串复制，只要操作一对位于原字符串 :math:`S` 上的指针就可以实现判断了。下面是这个蛮力法的程序：

.. literalinclude:: ../../codes/235_mps_bf.cpp
   :language: c++

为了观察算法的运行速度，我在程序里加入了测运行时长的功能，并随机生成了五个测试点数据，分别是长度为10、100、1000、10000、100000的五个字符串。运行结果如下：

.. code-block:: none

   $ ./mps_bf < mps_1.in
   A
   time elapsed = 0 ms.

   $ ./mps_bf < mps_2.in
   LJL
   time elapsed = 0 ms.

   $ ./mps_bf < mps_3.in
   MOM
   time elapsed = 2 ms.

   $ ./mps_bf < mps_4.in
   MLVLM
   time elapsed = 228 ms.

   $ ./mps_bf < mps_5.in
   LMLXLML
   time elapsed = 22888 ms.

可以看出，当字符串长度为10000个字符时，速度已经相当慢了。最后一个测试点字符串长达10万个字符时，运行时间超过了22秒。这样的算法如果用于实际解题肯定是要吃到TLE的。

.. hint::

   蛮力的算法本身虽然不值一提，但是在程序编制时却是用了许多C-string处理的常用技巧。比如指针代替位置、双指针指定子串、循环时用字符是否为 ``'\0'`` 作为循环条件等，都是早期纯C语言阶段就积累起来的C-string处理最为常用也是最为重要的技巧。

   在算法竞赛中，由于C++ string的速度确实比较慢，所以现在还是有许多人宁愿使用功能较弱、风险和难度都较大的传统C-string来进行字符串处理。所以如果你也希望能熟练掌控C-string，那么get这些技能是必不可少的。

   务必请认真地读懂这个程序，遇到不太懂的，可以自己尝试着改一改没有看懂的地方，运行一下看看会发生什么变化。这是一种读懂别人程序的重要方法。


二、动态规划法



.. index:: 最大回文子串：中心扩展法

三、中心扩展法










（待续）
