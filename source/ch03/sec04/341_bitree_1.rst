二叉树(I) 基础知识
+++++++++++++++++++

二叉树的概念
^^^^^^^^^^^^

在这一部分的引论节中我们已经了解了树和森林的概况和相关的一些概念，也已经了解到了所有的树和森林类数据结构中最为重要的一种，即\ :strong:`二叉树`\ （binary tree），它是指所有节点都最多只有两个子节点的树。一个节点的两个子节点习惯上分别称之为\ :strong:`左子节点`\ （left child）和\ :strong:`右子节点`\ （right child）。如果将一个节点的左子节点视为根节点，从它开始的所有后代节点共同构成的子树称为这个节点的\ :strong:`左子树`\ （left subtree），以其右子节点为根的部分就称为它的\ :strong:`右子树`\ （right subtree）。

二叉树每一层上的节点数量是有规律可循的。按照树结构的定义，根所在的层为第0层，在这一层上只能有一个根节点，所以第0层有且仅有一个节点。因为一个二叉树节点最多只有2个子节点，所以每一层的节点数最多是上一层节点数的2倍。设第 :math:`i` 层上的最大节点数量为 :math:`N_i`\ ，则下一层上 :math:`N_{i+1}=2N_i`\ ，其中 :math:`i=0,1,2,\cdots`\ ，初值 :math:`N_0=1`\ 。很容易看出，这是一个等比数列，公比为2，首项为1。因此，二叉树单层最大节点数为：

.. math::

   N_i=2^i, (i=0,1,2,\cdots)

由此，使用等比数列求和的方法就很容易得到一棵高度为 :math:`h` 的二叉树的最大可能节点数量 :math:`N(h)` 了。

.. math::

   N(h) = N_0 + N_1 + N_2 + \cdots + N_{h-1} = 2^0 + 2^1 + 2^2 + \cdots + 2^{h-1} = 2^h - 1

根据上面的描述，我们很容易想象出一棵完美的二叉树应该有的样子，就像下面这样：

.. image:: ../../images/341_bitree_1.png

这当然是最完美的一种二叉树了，在这样的二叉树中，每一层都恰好排满了节点，我们把这样的二叉树叫做\ :strong:`满二叉树`\ 。

满二叉树第 :math:`i` 层上的节点数量一定恰好等于二叉树这一层的最大可能节点数 :math:`2^i`\ ，而一棵高度为 :math:`h` 的满二叉树的总节点数也一定恰好是相同高度的二叉树的最大可能节点数 :math:`2^h-1`\ 。例如上图中这棵高度为4的满二叉树，它的节点数就是1+2+4+8=15=2\ :superscript:`4`\ -1个。

显而易见，如果节点数恰好为 :math:`2^h-1` 这种形式的数值，那么组织成满二叉树，高度为 :math:`h`\ ，这是最低可能的高度了。所有基于二叉树操作的算法，树高越低，效率越高，因此满二叉树确实是最完美的。

但是实际应用中不可能保证节点数总是恰为 :math:`2^h-1` 个的。因此我们一般就退而求其次，希望在任意的节点总数 :math:`n` 下，二叉树最好能组织成下面这种样子：

.. image:: ../../images/341_bitree_2.png

也就是说，除了最低的那一层以外，其他各层都是满二叉树的形式，而最低那一层上的节点，从左到右连续地排列，直到排完。这样的二叉树是接近完美的，我们称之为\ :strong:`完全二叉树`\ 。于是，现在我们可以认为满二叉树是完全二叉树的一种特例。

完全二叉树是实际应用中所能追求的最接近完美的二叉树了，它也有很多优秀的性质：

1. 若一棵完全二叉树的高度为 :math:`h \ge 1`\ ，那么它的总节点数 :math:`n(h)` 满足 :math:`2^{h-1} \le n(h) \le 2^h-1`\ 。
2. 若节点总数为 :math:`n \ge 1`\ ，那么完全二叉树的高度为 :math:`h(n)=\left\lceil \log (n+1) \right\rceil`\ 。

.. admonition:: 练习

   用数学方法证明上面的三个性质。

现在我们可以得到这样的结论：\ :emphasis:`二叉树中最为完美的组织形式为完全二叉树，为了确保数据访问效率最高，使用二叉树的算法要尽力将二叉树维持为完全二叉树或极其接近完全二叉树`\ 。

但是俗话说，世上不如意事十有八九，如果不人为地在程序中对树的形状进行监控和修整，自然生长的二叉树通常会长成各种奇怪的形状，比如：

.. image:: ../../images/341_bitree_3.png

这就算是比较好的了，还有最差的情况，从树根开始总是向着一个方向延伸，于是变成这样：

.. image:: ../../images/341_bitree_4.png

这种最差情况下，树的高度等于树中的节点数，数据访问的效率最低，实际上这是退化成了线性表。不光是二叉树，任何形式的树在应用中都要注意，绝对不能让它退化成线性表。

.. important::

   如果保持好树的形态，使其尽可能地接近或成为完全二叉树，是所有基于二叉树的算法所需要关注的问题。要实现这一目标并不简单，比如后面要讲的二叉检索树，就需要通过不断地检查和旋转来保持身材，使之成为一棵平衡二叉检索树，否则就很容易退化，失去了二叉检索树的价值。但是检查和旋转的所谓平衡二叉树算法是比较复杂的，更加复杂的还有红黑树的平衡算法。这些技术在初学阶段可以不必掌握，但是要有所了解。

当然了，千万不要忘记只有一个树根的树也是一棵二叉树，它既是最优秀的满二叉树，又是退化成线性表的最差劲状态。

从上面这种退化状态也可以看出一个结论，一棵高度为 :math:`h` 的二叉树至少有 :math:`h` 个节点。所以我们可以得出通常意义下二叉树的高度和节点数之间的关系：

1. 高度为 :math:`h` 的二叉树，其节点数 :math:`n(h)` 的取值范围为：:math:`h \le n(h) \le 2^h-1`\ 。
2. 节点数为 :math:`n` 的二叉树，其高度 :math:`h(n)` 的取值范围为：:math:`\left\lceil \log(n+1) \right\rceil \le h(n) \le n`\ 。
3. 给定节点数，完全二叉树的高度达到最低，退化二叉树高度达到最高。
4. 给定高度，满二叉树的节点数达到最大，退化二叉树的节点数达到最小。

二叉树的遍历
^^^^^^^^^^^^

一个数据结构最重要的操作就是要能够访问存储在其中的数据。二叉树不是线性数据结构，很难像线性表一样通过一个位置值来访问到某一个特定的节点，要指定一个节点在二叉树中的所在位置，一般需要用一条路径，比如左左右左右这样的。这样就比较麻烦了，所以一般对树（或者森林、网、图这样的非线性数据结构）中元素的访问，多采用\ :strong:`遍历`\ （traversal）的方法，即按照某种\ :strong:`确定的规则`\ ，沿一条\ :strong:`途径所有节点`\ 且\ :strong:`不重复`\ 的路线\ :strong:`完整地`\ 游历整棵树，从而\ :strong:`依次`\ 访问到所有的数据项。遍历的规则也叫做遍历的\ :strong:`序`\ ，不同序的遍历，访问元素的顺序就不同。

二叉树有四种常见的遍历序：层序（layer-order）、先序（pre-order）、中序（in-order）和后续（post-order），其中层序遍历又分为从左到右和从右到左两种。而先中后三种序的遍历则是数据结构和算法中最重要最基础的知识之一，需要熟练掌握。
