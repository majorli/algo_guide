二叉树(V) 后序遍历和遍历算法分析
++++++++++++++++++++++++++++++++++

这一节学习后序遍历及其两种实现，然后分析一下二叉树遍历算法的时间复杂度。

后序遍历的概念及其递归实现
^^^^^^^^^^^^^^^^^^^^^^^^^^

后序遍历，显然就是按照“左右中”的顺序，先遍历左子树，再遍历右子树，最后访问根节点的遍历方法，子树的遍历当然也是用后序遍历的规则，构成一个递归过程。

.. image:: ../../images/345_postord_concept.png

所以后序遍历的递归算法只不过是将先序或者中序遍历递归算法中访问根节点的那一句放放到最后面而已：

.. admonition:: 二叉树后序遍历算法

   :math:`\text{PostOrderedTraversal}(tree, visit):`

   :math:`\ \ \ \ \ \ \ \ \text{IF}\ \ \ \ tree = \text{NULL}\ \ \ \ \text{THEN}\ \ \ \ \text{RETURN}`

   :math:`\ \ \ \ \ \ \ \ \text{PostOrderedTraversal}(tree.left, visit)`

   :math:`\ \ \ \ \ \ \ \ \text{PostOrderedTraversal}(tree.right, visit)`

   :math:`\ \ \ \ \ \ \ \ visit(tree)`

看起来一切都是那么简单得顺理成章，让我们仍然用前节的那棵示例二叉树来模拟一下后序遍历的过程。和中序遍历相比，现在只需要改变一下表示子树遍历序列的括号位置就可以了。例如第一轮的时候得到的待定后序序列就是 ``(...) (...) 1``\ ，前一个括号里将来放左子树的后序序列，后一个括号里将来放右子树的后序序列。整个过程如下图所示：

.. image:: ../../images/345_postord_1.png

最终得到的后序遍历序列为 ``7 8 4 5 2 9 6 3 1``\ 。

.. admonition:: 练习

   仍然使用上一节示例程序所用的结构定义，完成递归调用方式的二叉树后序遍历函数：

   .. code-block:: c++

      void post_ord_trav(BiTree tree);

   访问节点的方式仍然仅为输出节点数据即可。

   编写 ``main()`` 函数，构造一些不同形状的二叉树来进行测试。

后序遍历序列的特点和先序遍历一样，根据一个给定的后序序列，我们可以马上知道根节点是什么，但是无法区分出左右两棵子树的后序序列。因此，若一个后序序列和一个中序序列搭配起来，也可以还原出原二叉树的形态。

但是后序序列加上先序序列的组合是无法还原二叉树的，因为仍然没有办法区分子树。例如下面这两棵非常简单的二叉树，它们本身并不相同，但是有完全相同的先序序列和后序序列：

.. code-block:: none

      1                 1
     /                   \
    2                     2

这两棵二叉树的先序遍历序列都是 ``1 2``\ ，后序遍历序列都是 ``2 1``\ 。

.. admonition:: 练习

   给定先序遍历序列 ``1 2 3`` 和后序遍历序列 ``3 2 1``\ ，试着找出所有可能的二叉树。


后序遍历的非递归实现
^^^^^^^^^^^^^^^^^^^^

后序遍历的非递归实现和中序遍历非常相似，只有很小的一点改动。

先来回顾一下中序遍历的非递归算法。算法中最核心的部分是一个栈，它用来依次存放从某个节点（最初是根节点）开始一路向左向下探索过程中途径的各个子树根节点。当出现回溯的时候，如果是从左支回溯到父节点，按照算法压栈的顺序，父节点一定在栈顶，所以依照“左中右”的顺序访问栈顶节点并弹栈，然后将其右儿子作为接下来要遍历的子树树根即可。如果发生从右支的回溯，根据中序遍历规则，父节点肯定已经从栈中弹掉了，如果父节点是爷爷节点的右儿子，即上一层也是从右支回溯，那么爷爷节点也一定已经从栈中弹掉了，依此类推，一路向上回溯总归会归结于两种情况：要么抵达了一次从左支的回溯，处理这一回溯即可，要么一路右回溯直到整棵树的根节点，整个中序遍历过程结束。

综上所述，中序遍历的规则决定了非递归算法时只要遇到回溯，无论是从左还是从右的，都可以一样地进行处理，因为右回溯总会自动归结到左回溯的情况去（或者遍历结束）。后序遍历的非递归算法基本上也是这样一种思路，栈的用法是一样的，只是现在遇到了一个小小的问题：后序遍历在发生回溯的时候，不同的回溯方向处理方法不一样。从左支回溯的时候，要先进入父节点的右子树而不能访问父节点；从右支回溯的时候才访问父节点。这就需要我们能够知道回溯是来自于左支的还是右支的。

为此我们需要一个辅助变量：上一次刚访问掉的节点。梳理一下可以发现，从右支回溯的情况有两种，一种是右子树为空树，另一种是上一次访问的右儿子节点。因此从右支回溯的判断依据就是：栈顶的节点没有右儿子或者上一次访问的节点就是栈顶节点的右儿子。

所以后序遍历非递归算法中处理回溯时要判断回溯的方向，如果是从左支返回的（栈顶节点有右子树而且上一次访问的不是它的右儿子）就把接下来要遍历的子树设置为栈顶节点的右子树。反之则访问栈顶节点并弹栈，同时千万记得要更新表示上一次访问的节点的辅助变量，并将接下来要遍历的子树设置为空。


二叉树遍历算法分析
^^^^^^^^^^^^^^^^^^



