二叉树(V) 后序遍历和遍历算法分析
++++++++++++++++++++++++++++++++++

这一节学习后序遍历及其两种实现，然后分析一下二叉树遍历算法的时间复杂度。

后序遍历的概念及其递归实现
^^^^^^^^^^^^^^^^^^^^^^^^^^

后序遍历，显然就是按照“左右中”的顺序，先遍历左子树，再遍历右子树，最后访问根节点的遍历方法，子树的遍历当然也是用后序遍历的规则，构成一个递归过程。

.. image:: ../../images/345_postord_concept.png

所以后序遍历的递归算法只不过是将先序或者中序遍历递归算法中访问根节点的那一句放放到最后面而已：

.. admonition:: 二叉树后序遍历算法

   :math:`\text{PostOrderedTraversal}(tree, visit):`

   :math:`\ \ \ \ \ \ \ \ \text{IF}\ \ \ \ tree = \text{NULL}\ \ \ \ \text{THEN}\ \ \ \ \text{RETURN}`

   :math:`\ \ \ \ \ \ \ \ \text{PostOrderedTraversal}(tree.left, visit)`

   :math:`\ \ \ \ \ \ \ \ \text{PostOrderedTraversal}(tree.right, visit)`

   :math:`\ \ \ \ \ \ \ \ visit(tree)`

看起来一切都是那么简单得顺理成章，让我们仍然用前节的那棵示例二叉树来模拟一下后序遍历的过程。和中序遍历相比，现在只需要改变一下表示子树遍历序列的括号位置就可以了。例如第一轮的时候得到的待定后序序列就是 ``(...) (...) 1``\ ，前一个括号里将来放左子树的后序序列，后一个括号里将来放右子树的后序序列。整个过程如下图所示：

.. image:: ../../images/345_postord_1.png

最终得到的后序遍历序列为 ``7 8 4 5 2 9 6 3 1``\ 。

.. admonition:: 练习

   仍然使用上一节示例程序所用的结构定义，完成递归调用方式的二叉树后序遍历函数：

   .. code-block:: c++

      void post_ord_trav(BiTree tree);

   访问节点的方式仍然仅为输出节点数据即可。

   编写 ``main()`` 函数，构造一些不同形状的二叉树来进行测试。

后序遍历序列的特点和先序遍历一样，根据一个给定的后序序列，我们可以马上知道根节点是什么，但是无法区分出左右两棵子树的后序序列。因此，若一个后序序列和一个中序序列搭配起来，也可以还原出原二叉树的形态。

但是后序序列加上先序序列的组合是无法还原二叉树的，因为仍然没有办法区分子树。例如下面这两棵非常简单的二叉树，它们本身并不相同，但是有完全相同的先序序列和后序序列：

.. code-block:: none

      1                 1
     /                   \
    2                     2

这两棵二叉树的先序遍历序列都是 ``1 2``\ ，后序遍历序列都是 ``2 1``\ 。

.. admonition:: 练习

   给定先序遍历序列 ``1 2 3`` 和后序遍历序列 ``3 2 1``\ ，试着找出所有可能的二叉树。


后序遍历的非递归实现
^^^^^^^^^^^^^^^^^^^^


二叉树遍历算法分析
^^^^^^^^^^^^^^^^^^



