二叉树(III) 先序遍历与深度优先搜索
+++++++++++++++++++++++++++++++++++++

二叉树还有三种重要的遍历方法，是学习二叉树时最为重要的基础知识，分别是\ :strong:`先序遍历`\ （也叫\ :strong:`前序遍历`\ ）、\ :strong:`中序遍历`\ 和\ :strong:`后序遍历`\ 。这一节先看先序遍历。

先序遍历的递归实现
^^^^^^^^^^^^^^^^^^^^^^

我们知道，树结构是一种可以递归定义的数据结构，二叉树当然也是。任何一棵二叉树都可以被定义为一个根节点和它的左右两棵子树，而两棵子树也都是二叉树，这就是二叉树的递归定义。其中根节点和两棵子树都可以为空，如果根节点为空那么它的左右子树也就必然为空，这时候这棵二叉树就叫做一棵\ :strong:`空树`\ 。

.. important::

   根据二叉树的递归定义，在实现一棵二叉树的时候，实际上树就是子树，而树也可以用根节点来表示。在程序里一个节点变量（通常是指向节点的指针）同时可以有三种含义：首先它当然是指示了一个节点，其次它可以代表了以该节点为根的一棵二叉树，而二叉树和二叉子树其实都是二叉树。

二叉树的先序遍历（Pre-ordered traversal）是指以这样一种顺序来进行遍历：\ :emphasis:`先访问根节点，然后遍历其左子树，然后遍历其右子树，对左右子树的遍历采用相同的规则`\ ，如下图所示：

.. image:: ../../images/343_pre_ord_concept.png

可以看出，这显然是一个递归过程，可以用下面的算法来描述：

.. admonition:: 二叉树先序遍历算法

   :math:`\text{PreOrderedTraversal}(tree, visit):`

   :math:`\ \ \ \ \ \ \ \ \text{IF}\ \ \ \ tree == \text{NULL}\ \ \ \ \text{THEN}\ \ \ \ \text{RETURN}`

   :math:`\ \ \ \ \ \ \ \ visit(tree)`

   :math:`\ \ \ \ \ \ \ \ \text{PreOrderedTraversal}(tree.left, visit)`
                                                    
   :math:`\ \ \ \ \ \ \ \ \text{PreOrderedTraversal}(tree.right, visit)`

其中算法参数 :math:`tree` 是要遍历的二叉树的根节点，:math:`tree.left` 和 :math:`tree.right` 分别是它的左右子节点，:math:`visit` 是访问节点中数据项的方法。

根据前面介绍的\ ``树=子树=根节点``\ 的原则，左右子节点也用来表示左右子树，左右子树同时也是二叉树，所以上述算法只用两次递归调用就可以完成先序遍历，最前面的判断语句是递归终止条件，即遇到空树就直接返回。

下面看一个具体例子，我们要对下面这样一棵二叉树进行先序遍历：

.. image:: ../../images/343_pre_ord_example.png

总的原则就是按照先根、后左子树、后右子树的顺序进行递归的遍历，我们用灰色表示还没有被访问到的节点，用绿色表示已经被访问过的节点，用虚线框表示下一步要遍历的子树。整个过程一共9步，完整地访问所有9个节点各一次，如下图所示：

.. image:: ../../images/343_pre_ord_r_1.png

.. image:: ../../images/343_pre_ord_r_2.png

对其中某些片段进行分析。观察树中以节点4为根的子树，它的左子树为节点7，右子树为节点8。第3步进入这棵树，先访问根节点4，随后在第4步访问了节点7之后，其左子树已经全部遍历完了，于是下一步就进入它的右子树，即节点8。第5步节点8也访问完之后，这棵以节点4为根的子树就遍历完了，于是第6步就进入它的父节点2的右子树，即节点5。

再观察第7步，此时进入了以节点6为根的子树，第8步先访问其根节点6，但是它没有左子树，所以下一步直接进入它的右子树，即节点9。第9步访问完右子树的根节点9，发现它没有子树，所以整个以6为根的子树部分遍历就结束了。这时候应该回到节点6的父节点3的右子树，但是节点3没有右子树，所以节点3开始的子树部分也遍历完了。进一步回到节点3的父节点1，这是整棵树的根节点，而且节点3是节点1的右子树，这就说明整棵树的先序遍历全部结束了。最终得到的先序遍历序列为：\ ``124785369``\ 。

.. admonition:: 先序遍历序列的特点

   先序遍历得到的节点访问序列的特点是：\ :emphasis:`序列的第一个元素对应了整棵树的根节点，但是后序的所有元素无法分清属于那棵子树。`

   例如先序序列 ``123``\ ，我们可以确定根节点一定是 ``1``\ ，但是后面的 ``23`` 就无法确定是什么节点了，事实上下面几种二叉树的先序序列都是 ``123``\ ：

   .. code-block:: none

        1            1        1       1        1
       / \          /        /         \        \
      2   3        2        2           2        2
                  /          \         /          \
                 3            3       3            3

   \ :emphasis:`仅凭一个先序序列，无法还原出二叉树。`

深度优先搜索
^^^^^^^^^^^^

上一节我们看到过二叉树的层序遍历是和宽度优先搜索相对应的，现在我们将看到先序遍历是和深度优先搜索相对应的。如果要在一棵二叉树中搜索一个特定的节点，按照先序遍历的顺序逐个节点去查找的过程就叫做\ :strong:`深度优先搜索`\ （DPS）。宽度优先搜索是先探索所有同层节点，逐层向下推进直到树叶，所以叫做宽度优先。深度优先搜索顾名思义就是尽量向下探索直到叶子节点，沿一个方向一路走到叶子还没有找到那么再往回一层，换另一个方向继续向下探索。向下探索的过程叫做下探，往回换方向的过程叫做回溯。和BPS一样，DPS也不仅仅是针对二叉树的，它能适用于任何形状的树，甚至是图结构。

.. hint::

   五大算法中的回溯算法和分支限界算法就是基于BPS和DPS两种搜索来构造的，所以BPS和DPS是极其重要的基础算法，在后面讲解回溯算法时会进行详细介绍。

为什么说二叉树的DPS就是依先序遍历的顺序进行的搜索，可以看一下上面这个例子的遍历过程。我们用箭头标出了整个遍历的节点游历顺序，其中红色箭头对应了下探过程，蓝色箭头对应回溯过程。

.. image:: ../../images/343_bitree_dps.png

可以看出，遍历的过程果然就是沿着DPS的搜索方式完成的。首先从根节点开始一路沿着左支下探，直到最左端的节点，然后一层一层的回溯，每回溯一层就尝试去访问它的右支。一旦回溯进入右支，仍然按照同样的规则，先沿着左支一路下探到最左下位置的节点，然后层层回溯。注意，沿左路下探抵达的最左端的节点并不一定是叶子节点，而是指没有左子树的那个节点，如本例中的节点6。

所以理论上我们可以用上面的先序遍历算法来改造成二叉树的DPS算法，只要在访问节点的方法 :math:`visit` 中进行条件判断，一旦发现了符合条件的搜索结果，立即终止遍历过程即可。但是在实际编程的时候却是存在一些问题的，事实上要彻底终止一个递归过程可能会比较麻烦，有可能需要设置额外的标识变量（flag）来表明一次函数返回是正常的递归返回还是要终止整个递归过程。

另外，递归进行先序遍历本身也有一点小小的不足。我们知道利用函数的递归调用来实现递归过程时空间和时间都会有比较多的消耗，如果二叉树的结构比较庞大，深度很深的话，递归过程可能会耗尽内存，造成栈溢出错误（Stack Overflow），这是一个和段错误一样经典的运行时错误。

.. admonition:: 题外话

   全世界最著名的问答网站就叫做StackOverflow，可见这个错误在软件开发领域有多么的“深入人心”。

尽管很少会有一棵真正的二叉树大到能导致Stack Overflow的程度，但如果是在DPS算法中就不一定了，DPS算法要搜索的树往往不是真实存在的生成好的树，而是随着搜索不断生长的虚拟的树。如果用递归的方法来进行DPS，发生栈溢出还是很有可能的，而且时间效率也会受影响。

因此，我们还是希望能有一种不采用递归调用来实现的DPS算法，在二叉树就是非递归方式的先序遍历算法。

先序遍历非递归实现
^^^^^^^^^^^^^^^^^^^^



