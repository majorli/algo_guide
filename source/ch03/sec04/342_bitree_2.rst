二叉树(II) 层序访问与宽度优先搜索
+++++++++++++++++++++++++++++++++++

前面学习了二叉树的基本知识和链式、顺序两种存储结构的实现方法。但是我们发现，光这些完全不足以有效地使用二叉树结构，甚至无法有效地创建出一棵二叉树。

造成这一问题的原因是树结构的特殊性。对于一棵二叉树中的某一个节点，不能像线性表元素一样有一个确定的毫无歧义的序号来标定它所在的位置。要让计算机程序知道二叉树中某一个节点的位置，需要一个从根节点出发的路径。因此，如果我们只有一系列的数据项是不足以创建出所需要的二叉树的，还需要每一个数据项的路径，或者确定每一个数据项路径的规则才行。

在实际应用中，二叉树的节点路径规则可以是多种多样的，不同的规则能生成出不同的二叉树。经典的二叉树节点规则有二叉检索树规则、红黑树规则等。这一节我们将介绍一种最简单的层序访问规则，按从上到下的顺序从根节点所在的0层依次访问直到最底层，在同一层中按照从左到右的顺序依次访问所有节点，遇到空节点直接跳过。这个规则可以归纳为\ :strong:`从上到下、从左到右`\ 。

如果我们要在二叉树中搜索某个满足特定条件的节点，我们可以按照层序规则逐个节点地扫描搜索，这就是著名的\ :strong:`宽度优先搜索`\ （BPS）策略。当然了，层序访问或宽度优先搜索都不局限于二叉树，事实上任何结构的树都可以按层序规则来访问节点，而宽度优先搜索甚至能用于网状结构（例如图）的搜索。

对一个数据结构中的所有元素按照一定规则完整地进行一次访问，不重复、不遗漏，在数据结构和算法领域称为对这种数据结构的一次\ :strong:`遍历`\ （traversal）。对一棵树（当然包括二叉树）中的所有节点完整地按层序访问一遍就称为一次\ :strong:`层序遍历`\ （layer-order traversal）。层序规则的实现一般要依赖于使用一个队列。

.. attention::

   接下来的所有示例程序中我们一律采用链式结构来实现二叉树，毕竟这是最为自然最为常见的一种实现形式。顺序结构一般仅用于完全二叉树，最常见的是用来构造堆结构，我们将在介绍堆的时候再使用。

层序创建完全二叉树
^^^^^^^^^^^^^^^^^^

仅给定一个数据项序列但没有规定节点定位规则的时候，我们可以按照层序的规则来创建出一棵完全二叉树。在没有对节点定位规则做多余假设的情况下，默认采用层序来构造完全二叉树是最合理的设想了，因为完全二叉树是层数最少，空间利用最合理的情况。

设给定了一个长度为 :math:`n` 的序列 :math:`a[0..n-1]`\ ，显然 :math:`a[0]` 是要作为根节点的。:math:`a[1]` 和 :math:`a[2]` 分别是根节点的左右两个子节点，它们位于树的第2层。随后第3层上的节点为 :math:`a[3]` 到 :math:`a[6]` 一共4个，依次分别是 :math:`a[1]` 的左右子节点和 :math:`a[2]` 的左右子节点。依此类推直到最后一层的最后一个节点 :math:`a[n-1]`\ 。

如果我们没有一种有效的辅助数据结构，仅是靠序列编号本身来推算数据项应该在哪一个节点上，那么创建过程会非常复杂。比如我们可以计算出来 :math:`a[10]` 的所在节点位置应该是第4层左起第4个位置，是其父节点的右儿子。那么接下来就要找到它的父节点，通过计算可以知道是第3层的第2个节点。但是为了定位过去，我们还得再向上找父节点的父节点，即第2层的第1个节点。然后再向上定位到根节点。这是一个不断向上回溯，直到根节点，然后再按照回溯路径一路访问下来的过程，太麻烦了，我们需要一种更好的办法。更好的办法就是用一个队列来作为辅助数据结构，下面我们就来看看怎样做到。假设我们的序列为 {1, 2, 3, 4, 5, 6}，一共6个整数。

第一步先读入第1个数据项1，它一定是根节点。于是我们先创建出一个根节点，放入数据项1，然后将其入队。结果如下图所示：


二叉树的层序遍历
^^^^^^^^^^^^^^^^


二叉树的层序销毁
^^^^^^^^^^^^^^^^^^^^



