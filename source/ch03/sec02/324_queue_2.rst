队列：C++实现、STL容器
++++++++++++++++++++++++

本节介绍如果自己编程实现链式队列，并介绍STL库提供的两种队列容器：队列 ``queue`` 和有点奇怪的双头队列 ``deque``\ 。事实上，\ ``deque`` 与其说是一种队列的变种，更不如说是向量 ``vector`` 的一种变种。至于优先级队列容器 ``priority_queue``\ ，我们留到以后讲解完堆这种高级数据结构之后再做介绍。

链式队列的实现
^^^^^^^^^^^^^^

我们用C++语言实现一个标准意义上的队列，采用链式存储结构，支持模板类型，用编程管理来模拟封装。根据前面的介绍，我们应该把数据节点、底层单链表和具体的成员变量都隐蔽起来，对外只提供以下功能接口：

1. 创建一个新队列，初始为空队列。
2. 元素入队。
3. 访问队头元素。
4. 队头元素出队。
5. 判断队列是否为空。
6. 获取队列长度。

所以我们只要模仿以前实现过的单链表代码就可以很方便地实现这样一个链式队列，而且由于队列的访问限制，我们甚至不需要提供指示器之类的元素定位访问能力。如果有点忘记了，可以回顾一下这里：:doc:`../../ch03/sec01/318_linkedlist_2`\ 。

所有操作的原理我们在上一节已经介绍过了，这里先直接给出代码再进行说明。

.. literalinclude:: ../../codes/324_linked_queue.cpp
   :language: c++
   :lines: 3-48

.. note::

   相信真正理解了上一节介绍的链式队列原理之后是很容易看懂上面这段代码的，这里做一些简单说明：

   1. 节点结构 ``_Node`` 是队列结构 ``LinkedQueue`` 的内部结构，如我们在介绍链表的C++实现时所给出的代码，这个节点结构的全名应该在前面加上其父结构名称的命名修饰，即 ``LinkedQueue<T>::_Node``\ 。但是由于我们所有用到这个节点结构的代码都是定义在外部结构 ``LinkedQueue<T>`` 内的，也就是说是在 ``_Node`` 的命名空间内，所以我们实际上可以在代码中省略命名修饰。
   2. 元素入队时，我们先将队尾指针所指向的空节点的元素值赋为要入队的元素值，这样这个空节点就变成了一个有效的元素节点，它是队列实际上的尾节点。然后我们要生成一个新节点作为它的后继，这个新节点就是新的队尾指针指向的空节点。最后别忘了修正队列长度。
   3. 元素出队时，我们把队头指针改成它的后继，然后销毁原队头指针指向的队头元素节点即可，同样别忘了修正队列长度。
   4. 元素出队和访问队头元素两个操作，都有可能遇到空队列的情况，对于空队列进行这样的操作就会引发错误操作或者让获得的结果不确定。所以我们在这两个操作中都做了预判处理，但是二者处理预判的方式不一样，这里有什么不同，又是什么原因，请自行弄懂。
   5. 最后别忘了，凡是用到动态内存的结构，都需要有一个析构函数以便清除掉所有占用的空间。

.. admonition:: 练习

   模仿上面的代码，编写一个具体类型的链式队列结构并编写 ``main()`` 函数进行测试，要求如下：

   1. 元素类型为 ``int``\ 。
   2. 不提供 ``head()`` 函数以访问队头元素，而是在元素出队的时候同时返回被出队元素的值。
   3. 可以不采用封装惯例形式。

STL队列容器
^^^^^^^^^^^^



STL双头队列容器
^^^^^^^^^^^^^^^^

