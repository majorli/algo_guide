栈的应用：表达式求值
++++++++++++++++++++

求表达式的值是最常见的数学运算之一，也是计算机软件最常见的任务之一。例如最简单的整数四则运算表达式，只允许使用加减乘除四则运算和括号（允许嵌套），所有运算数都是整数，但要注意其值不一定是整数。

对于人类来说，要计算一个整数四则运算表达式的值有可能计算会比较麻烦，但是对表达式的理解一定是很简单的。哪怕表达式看上去再复杂，四则运算和括号的使用规则都是从小就非常熟练的，只要认真地去一步一步计算即可。但是对于计算机来说，给定一个字符串形式的四则运算表达式，最大的挑战是要让软件看懂这个表达式，而计算本身根本就不是什么问题。

计算机要对表达式求值，首先要分析表达式的词法，分解出运算符和运算数，对于运算数要将其从字符串形式转为整数。经过词法分析，一个字符串形式的表达式就会被拆解成一个记号（token）序列，这些记号有两种类型，一种是运算符，另一种是运算数。

完成词法分析之后，要对得到的记号序列进行语法分析，根据运算优先级（乘除优先级高于加减）和括号的位置确定计算顺序。语法分析结束之后即可按照分析结果逐步完成计算。

所以计算机要完成一个表达式的求值，前后共要进行词法分析、语法分析和求值三个步骤。由于不同运算有不同优先级，通过加括号又可以调整计算顺序，所以数学表达式的计算过程可以非常灵活。但是计算机最不喜欢的就是灵活，计算机希望表达式能够没有括号、没有优先级、总是从左到右或者从右到左按固定的顺序运算。

为此人们发明了\ :strong:`前缀表达式`\ 和\ :strong:`后缀表达式`\ 两种新的表达式形式，同时把人类使用的通常的表达式称为\ :strong:`中缀表达式`\ 。

前缀、中缀和后缀表达式
^^^^^^^^^^^^^^^^^^^^^^

所谓的前缀、中缀、后缀表达式，是指三种不同的表达式形式，是指运算符放在运算数的前面、中间还是后面而言的。比如通常的数学表达式 ``1 + 2``\ ，运算符加号是放在两个运算数中间的，所以叫做中缀表达式，如果写成前缀表达式就是 ``+ 1 2``\ ，写成后缀表达式就是 ``1 2 +``\ 。前缀表达式和后缀表达式是由波兰逻辑学家 Lukasewicz 发明的，所以前缀表达式也叫做\ :strong:`波兰表达式`\ ，后缀表达式叫做\ :strong:`逆波兰表达式`\ 。

前缀和后缀表达式是不允许使用括号的，也没有运算优先级。在把通常的中缀表达式转换为相应的前缀或后缀表达式时，需要使表达式按正确的运算顺序沿一个固定的方向排列，前缀表达式从右向左，后缀表达式从左向右。于是人们发现这两种表达式形式特别适用于计算机求值。

**前缀表达式**

例如普通的表达式 ``1 - 2 * 3``\ ，写成前缀表达式时应该把运算符 ``-`` 和 ``*`` 都放在各自的运算数之前，按照优先级，乘法先算，所以先把 ``2 * 3`` 写成 ``* 2 3``\ ，而减法的两个运算数分别为 ``1`` 和 ``* 2 3``\ ，因此最终的前缀表达式为 ``- 1 * 2 3``\ 。

计算机计算前缀表达式时，使用一个栈用来存放运算数。它只要机械地从右向左进行扫描，每遇到一个运算数就把这个数压栈，每遇到一个运算符就从栈中弹出两个运算数进行计算并把计算结果重新压入栈中，如此下去直到整个表达式扫描完毕，栈中留下的那个数就是表达式的值。例如示例中的这个表达式的运算过程如下：

.. code-block:: none

   表达式：+ 1 * 2 3

   初始栈：[]
   
   第1步：读到运算数3，压栈，栈变成 [3]

   第2步：读到运算数2，压栈，栈变成 [3, 2]

   第3步：读到运算符*，从栈中先后弹出2和3，计算2 * 3 = 6，压栈，栈变成 [6]

   第4步：读到运算数1，压栈，栈变成 [6, 1]

   第5步：读到运算符-，从栈中先后弹出1和6，计算1 - 6 = -5，压栈，栈变成 [-5]

   表达式扫描完毕，栈中应该只剩下一个元素，即计算结果-5

遇到有括号的表达式，处理的方法也是一样的，无非最内层的括号有最高的运算优先级而已。例如 ``(3 + 4) * 5 - 6``\ ，优先级最高的运算是 ``(3 + 4)``\ ，先将其变成 ``+ 3 4``\ ，然后将乘法部分变成 ``* + 3 4 5``\ ，最后再将减法部分也变成前缀形式，得到最终的前缀表达式 ``- * + 3 4 5 6``\ 。

.. admonition:: 练习

   1. 仿照前面所示的步骤，手工进行前缀表达式 ``- * + 3 4 5 6`` 的运算，得到正确的计算结果。
   2. 手工将下列中缀表达式转换为前缀表达式并完成运算，检查计算结果：

      ``1 - 2 - 3``

      ``12 + 13 * 14 - 15 / 16``

      ``1 + ((2 + 3) * 4) - 5``


**后缀表达式**

实际上在计算机软件中现在前缀表达式使用的情况不多见，更重要的是后缀表达式。具体的原因和表达式优化有关，现在不需要深究，我们只要知道这个结论即可。也正因为如此，在算法问题中基本也只会出现后缀表达式有关的问题，我们需要熟练地掌握后缀表达式的生成和运算方法，能熟练地编写相关的程序。

.. warning::

   后缀表达式的生成和计算是目前为止遇到的最大难点，也是一大重点。

首先仍然用 ``1 - 2 * 3`` 为例来看看怎样生成后缀表达式。和生成前缀表达式的时候一样，还是按照运算顺序来逐个部分的变为后缀形式。首先将 ``2 * 3`` 变成 ``2 3 *``\ ，随后处理减法部分，前后两个操作数分别为 ``1`` 和 ``2 3 *``\ ，所以写成 ``1 2 3 * -`` 的形式，这就是最终的后缀表达式。

后缀表达式生成好之后，计算方法是和计算前缀表达式时几乎一样的，区别有两个地方，一是现在我们从左向右扫描，二是弹出运算数时先弹出的数为右运算数、后弹出的数为左运算数。以计算 ``1 2 3 * -`` 为例：

.. code-block:: none

   表达式：1 2 3 * -

   初始栈：[]

   第1步：读到运算数1，压栈，栈变成 [1]

   第2步：读到运算数2，压栈，栈变成 [1, 2]

   第3步：读到运算数3，压栈，栈变成 [1, 2, 3]

   第4步：读到运算符*，从栈中先后弹出3和2，计算2 * 3 = 6，压栈，栈变成 [1, 6]

   第5步：读到运算符-，从栈中先后弹出6和1，计算1 - 6 = -5，压栈，栈变成 [-5]

   表达式扫描完毕，栈中应该只剩下一个元素，即计算结果-5

再如中缀表达式 ``(3 + 4) * 5 - 6``\ ，按照运算顺序，先把 ``(3 + 4)`` 变成 ``3 4 +``\ ，接下来将乘法部分改成 ``3 4 + 5 *``\ ，最后处理减法部分，得到最终的后缀表达式 ``3 4 + 5 * 6 -``\ 。

.. admonition:: 练习

   1. 仿照前面所示的步骤，手工进行后缀表达式 ``3 4 + 5 * 6 -`` 的运算，得到正确的计算结果。
   2. 手工将下列中缀表达式转换为后缀表达式并完成运算，检查计算结果：

      ``1 - 2 - 3``

      ``12 + 13 * 14 - 15 / 16``

      ``1 + ((2 + 3) * 4) - 5``


中缀表达式的分析算法
^^^^^^^^^^^^^^^^^^^^

计算机软件以字符串的方式读入一个中缀表达式，首先要对它进行词法分析，把每一个元素分解出来识别为一个一个的记号。对于最简单的整数四则运算，记号有两种，一种是\ :strong:`运算符`\ （operator），包括 ``+-*/()``\ ，另一种是\ :strong:`运算数`\ （operand），即所有整数，为了简单起见，我们假设所有操作数都可以用 ``int`` 类型来表示。

所以我们先定义一个表示记号的结构，可以用来存放两种类型的记号：

.. literalinclude:: ../../codes/322_expr.cpp
   :language: c++
   :lines: 7-11

当 ``is_op == true`` 时，表示这个记号是一个运算符，此时 ``op`` 就存放这个具体的运算符，即 ``+-*/()`` 这六个字符中的任一个；\ ``is_op == false`` 时则表示这个记号是一个运算数，其值存放在 ``num`` 中。

表达式分析的第一步，词法分析，要做的工作就是把一个字符串形式的中缀表达式中每一个不同的元素分解出来，变成一个依从左向右次序存放的记号串。在这一步我们不需要考虑计算过程，只需要单纯地正确读取到所有记号即可。为了简化分析过程，我们假设读入的字符串只包含 ``+-*/()0123456789`` 这些字符和空白符（空格、换行、Tab），而空白符我们认为是可有可无的，一旦读到空白符直接舍弃即可。

事实上，词法分析的过程本身并不难，只需要注意 ``+-`` 这两个符号有时候是加法和减法的运算符，需要单独分析成对应的记号，有时候它们是运算数的正负号，要和它后面的正整数组合起来形成正确的运算数记号。例如表达式 ``-3-(-4*(-5))``\ ，这里面的第1、3、4个 ``-`` 字符是负号，而第2个 ``-`` 则是减法运算符。这个一种符号两种用途的情况粗看起来回给词法分析带来不少麻烦，但是其实很简单，稍微想想就不难总结出这样一个结论：整个字符串的第一个字符和所有跟在左括号 ``(`` 之后的 ``+=`` 字符是运算数的正负号，其他的都是加减运算符。

这样，只要配合上我们在前面学过的字符串转整数的算法就可以比较清楚的整理出词法分析的算法思路：

1. 初始化状态：下一个运算数的正负号为正
2. 从头到尾逐个扫描中缀表达式中的每一个字符

   * 如果是 ``+-`` 且当前字符是整个表达式的首字符或紧跟在 ``(`` 之后的字符，那么记录好下一个运算数的正负号；否则记录一个运算符记号并将下一个运算数的正负号设置为正
   * 如果是 ``*/()`` 则记录一个运算符记号并将下一个运算数的正负号设置为正
   * 如果是任一数码字符，那么启用字符串转整数算法，得到运算数的绝对值，然后正确设置其正负号，记录一个运算数记号
   * 如果是别的字符则直接舍弃

.. tip::

   我们可以用整数1或者-1来表示下一个运算数的正负号，当后面读取到一个运算数的绝对值之后，只需要将其和这个正负号变量相乘即可得到正确的运算数。

这个算法看起来简单，但是实际编程还是很有挑战的。由于算法竞赛很少遇到需要自己做词法分析的题目，所以我们直接给出函数代码，但还是建议自己先动手尝试一下，然后对照看懂这里给出的代码。

.. literalinclude:: ../../codes/322_expr.cpp
   :language: c++
   :lines: 2, 21-26, 50-93

一般来说，在词法分析结束后要进行语法分析，即检查表达式是否符合四则运算式的格式规定，比如不能连续出现加减乘除符号，左右括号要匹配等等。但如果是算法问题，一般输入的中缀表达式字符串是确保格式正确的，那么就不需要做语法分析了。不过语法分析中的括号匹配检查可以作为一个练习，使用栈可以轻松地完成这一检查。

.. admonition:: 练习

   设计一种简单的算法，利用一个栈来检查中缀表达式中的括号是否左右匹配。输入为一个中缀表达式字符串，如果其中左右括号是匹配的，就输出 ``"OK"``\ ，否则就输出 ``"Wrong"``\ 。编程实现并测试。

   提示：纯粹做括号匹配检查不需要先做词法分析，可以直接基于中缀表达式的字符串来进行检查。

   思考：能不能连一个栈都不使用，也不使用任何其他复杂的数据结构，仅使用基础数据类型来完成这一检查？如果能，请编程实现并测试。

   附加：现在进一步要求在检查到表达式中左右括号不匹配时，能模仿C++编译器那样的给出错误信息，指出错误发生的位置，例如输出像以下这样的错误信息：

   .. code-block:: none
   
      Wrong:
      2*(3+4))
             ^

   或者

   .. code-block:: none

      Wrong:
      2*((3+4)
        ^

后缀表达式的生成算法
^^^^^^^^^^^^^^^^^^^^

表达式根据中缀式生成后缀式是一个经典问题，在算法问题中极为常见。它有一个看上去不难，要理解和记住挺难，要在考场上一次性快速写对非常难的经典算法，也是一个必学的经典算法。

后缀式生成算法使用两个栈即可实现，这两个栈的元素类型都是 ``Token``\ ，一个是运算符栈 ``s1``\ ，另一个是中间结果栈 ``s2``\ 。算法结束时，\ ``s2`` 中存放的就是对应的后缀表达式。

运算符栈的应用原则是栈顶元素的运算优先级总是比其他元素更高。按照从左到右的顺序逐个读到的运算符，按照这个原则进行压栈，即只要当前栈顶元素的运算优先级不低于新运算符，那么就将其弹出并压入中间结果栈。这样做是为了保证后缀表达式的正确运算顺序。

算法的具体过程如下：



后缀表达式的计算算法
^^^^^^^^^^^^^^^^^^^^


