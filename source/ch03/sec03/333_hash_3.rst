冲突处理：链式哈希表
++++++++++++++++++++

有了冲突探测技术就够了吗？采用冲突探测技术实现的哈希表存在什么缺点吗？当然有，这种哈希表最大的问题是，底层数组很难实现动态大小。如果事先无法预知数据量，也就无法预先确定底层数组的大小。而一旦填充因子达到上限之后还有新数据项要添加进来，那么要么牺牲效率，要么设法扩张底层数组。但是扩张底层数组的长度有几个难点：一是扩多少很难定，二是找一个大质数很费时间，三是最大的问题，所有表中已有的数据项都需要重新哈希，全体搬家。所以扩张底层数组说说看容易做做看难，尤其是表本身已经很大的时候再做扩张可能会非常费时。如果干脆牺牲效率，让填充因子进一步扩大，那也最多只能到全部填满，如果数据项的数量超过了底层数组的长度还是免不了要扩张底层数组本身。

所以对于那些数据量很大而且事先无法预计的场景，采用冲突探测法就显得不太合适了。这时候我们一般会使用另一种处理哈希冲突的方法，构建\ :strong:`链式哈希表`\ 。

链式哈希表
^^^^^^^^^^^^

链式哈希表，顾名思义，就是指采用链表结构来存放数据项的哈希表。使用链式存储结构之后，每一个底层数组的元素其实都是一个单链表的头节点，初始时候都是空指针。当一个数据项的哈希值计算完成，确定了它应该存放在底层数组的哪一个位置之后，我们并不是把这个数据项直接存放在数组的这个元素里，而是把它插入到数组元素所指向的那个单链表里。通过这样的方法，所有具有相同哈希值的数据项就在该哈希值所指定的底层数组元素后面形成了一个理论上长度无限的单链表，从而让哈希表可以存放理论上无穷多的数据项。

仍然采用上一节的例子，用长度为13的底层数组构建哈希表，依次存入键值为16,74,60,43,54,90,46,31,29,88,77的11个数据项。这次我们采用链式哈希表，其过程如下图所示：

.. image:: ../../images/333_linked_hashtable.png

**添加数据项**

在链式哈希表中添加数据项非常简单，根据键值计算出哈希值，确定在底层数组中对应的位置，然后在该位置的单链表头部插入该数据项即可。这里需要注意的是插入数据项是在单链表的头部完成的，也就是说哈希值相同的数据项，后添加进来的在前，先添加进来的在后。这是为了编程的便利性，如果要按照添加顺序来保持链表中数据项的节点顺序，那么我们就需要额外为每一个单链表维护一个尾节点指针。这就会增加编程的复杂度，但是哈希表本身就不保持数据项的添加顺序，也不保证任何别的元素顺序，所以在链表中保持添加顺序没有什么意义。

可以看出，不管有没有发生哈希冲突，链式哈希表的添加数据项操作都是 :math:`O(1)` 的时间复杂度，忠实地满足哈希表的设计要求。

