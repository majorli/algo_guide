STL容器：集合
+++++++++++++

回顾前面的内容，我们学习了哈希表这种特殊的数据表，它具有能够以接近常数时间的效率进行元素增删查改的优秀性能，但是它对元素的类型有一定的要求，即要求元素是所谓的键值对形式的数据项，其中键这个部分要求是唯一的，不同的数据项必须有不同的键。在实际的算法问题编程中，很少遇见需要自己编写一个哈希表的情况，但是经常会用到集合和映射这两种数据结构，它们往往是基于哈希表来实现的。前面我们也已经说过，如果哈希表中保存的数据项是键值合一的，那么就相当于一个集合，如果是键值分开的，那么就相当于一个映射。

C++和Java等其他现代高级语言一般都会提供多种集合和映射容器，其中一定会有一些是基于哈希表技术来实现的，比如Java的 ``HashSet`` 和 ``HashMap`` 就是。算法竞赛所使用的C++98，其STL库也提供了集合 ``set`` 和映射 ``map`` 两种容器，它们是基于二叉检索树技术的，因此能够让容器中的元素根据键值大小保持有序，但是增删查的效率略微低一点。C++11标准开始增加了无序集合 ``unordered_set`` 和无序映射 ``unordered_map`` 容器，它们是基于哈希表来实现的，时间效率就高了，但可惜目前很多信息学算法竞赛不支持使用C++11标准。另外，C++的STL容器还提供了键值可重复的集合和映射容器，分别是 ``multiset`` 和 ``multimap``\ ，C++11开始同样地为无序集合和无序映射提供了键值可重复的版本 ``unordered_multiset`` 和 ``unordered_multimap``\ 。

本节我们将对STL的集合容器的使用方法进行介绍，下一节介绍映射容器。

集合的基本概念
^^^^^^^^^^^^^^

集合本身是一个数学概念，是现代数学的基石。数学上所述的集合概念非常简单，就是一系列互不相等的元素所构成的一个整体。数学的集合有以下几个性质：

1. 元素的类型可以多种多样，并不一定需要是同类型的。比如数字和几何图形也可以是同一个集合中的元素，只要是某种具体的东西都可以放进任何集合里去。
2. 元素的数量没有任何要求，最少可以是0个（空集），可以是有限个，比如10以内自然数的集合，也可以是无限个，比如一条线段上所有点的集合。
3. 元素的顺序没有任何规定，比如 {1,2,3} 和 {3,2,1} 是相同的集合，和它们的元素排列顺序没有关系。

编程语言提供的集合容器，会尽量地模拟数学上的集合概念，但是终究会有所不同。最显而易见的不同就是受到计算机存储空间的限制，不可能真正实现无限集合。根据实现技术的不同，有些集合容器会确保元素之间保持一定的顺序，例如C++的 ``set`` 容器会利用元素之间的小于比较运算来确保元素按照大小关系从小到大存放，Java的 ``LinkedSet`` 容器会保证元素按照添加入表的顺序来存放。有些则不会，例如C++11的 ``unordered_set`` 和Java的 ``HashSet`` 容器就不保证元素之间的任何存放顺序，因为它们都是基于哈希表来实现的集合。

编程语言提供的集合容器对于元素的数据类型也是多少有一点限制的。例如C++的 ``set`` 容器，在定义的时候要求指定一个数据类型，以后放入集合中的元素就必须是这种类型的，并不是数学上集合概念所说的完全没有任何限制，Java的集合容器也是一样。在算法编程中，这样的限制并不会带来太多麻烦，一般算法编程不会遇到要把不同类型数据放在一个集合里去的情况。

.. admonition:: 补充

   但是工程性质的软件开发时就不一样了，不同类型数据希望放在一个集合里去的情况时有发生，这时候就需要用到面向对象编程技术来解决问题。C++、Java和其他绝大多数现代编程语言都支持面向对象的编程技术，通过类型之间的继承关系，可以使用一个公共的父类型（也叫基类）来定义容器，然后所有继承自这个公共基类的子类型就都可以放进去了。

   例如最经典的解决方案来自Java语言，Java有一个理念叫做Everything is object，万物皆对象。在Java语言中预先定义了一个最基础的基类叫做 ``Object``\ ，所有其他任何类型都继承自它，都是它的子子孙孙，因此就叫做 Everything is object。在Java的世界里已经消灭了“你是不是东西？”这个千古难题，只剩下“你是个什么东西？”这个问题了。正因为如此，我们可以这样定义一个允许放进去任何东西的集合：

   .. code-block:: java

      HashSet<Object> h = new HashSet<Object>();

   C++虽然没有Java这么做得彻底，并没有一个最基础的基类，但是并不妨碍我们自己定义一个呀。如果使用C++的面向对象编程，我们完全可以自己定义一个类似这样的基类。当然了，这是面向对象的编程技术，在学习算法编程时我们不去学它，作为补充知识有所了解就可以了。

STL集合容器
^^^^^^^^^^^^

前面已经说过，STL的集合容器总共有四种：\ ``set``\ 、\ ``multiset``\ 、\ ``unordered_set`` 和 ``unordered_multiset``\ 。实际上，所有四种容器在使用上几乎完全相同。下面我们首先看最基础的 ``set`` 容器。

``set`` 是C++98的STL库中就提供的标准集合容器，是目前所有算法竞赛都允许使用的。这个容器是采用二叉检索树作为底层结构来实现的，它能够让集合中的所有元素按照大小顺序有序排列，增删查的时间复杂度都是 :math:`O(\log n)`\ ，虽然比不上C++11新增的使用哈希表作为底层结构的 ``unordered_set`` 容器，但是也已经够快了，毕竟它还能实现元素的自动排序。要使用 ``set`` 容器，和别的所有其他STL容器一样，要引入同名的库，要使用 ``std`` 命名空间，定义具体的集合时要指定元素数据类型，也可以利用一些已有的其他容器（或数组）来初始化新定义的集合。例如：

.. code-block:: c++

   #include <set>

   using namespace std;

   set<int> s1;  // 定义一个空的集合，元素为int类型
   int data[] = { 1, 2, 3, 4, 5 };
   set<int> s2(data, data+5);   // 定义一个集合，用数组data的一段数据来初始化

``set`` 也和其他STL容器一样，可以用迭代器来进行元素访问，也有四种迭代器：头部迭代器 ``begin()``\ 、尾部迭代器 ``end()``\ 、反向头部迭代器 ``rbegin()`` 和反向尾部迭代器 ``rend()``\ 。它也有常规的 ``empty()`` 和 ``size()`` 成员函数用来判断容器是否为空和获取元素数量，也有 ``clear()`` 成员函数用来清空集合，有 ``swap()`` 成员函数用来交换两个集合的内容。这些都是STL容器的标准成员函数，这里就不再一一详细说明了。

和 ``vector`` 这些我们已经学过的线性表类型容器不同的是，\ ``set`` 对它的元素数据类型有特殊的要求，即元素的数据类型必须支持大小比较。内置的数据类型和C++ string天生具有大小比较的能力，因此直接可以用做集合的元素数据类型；自定义的结构等派生数据类型，我们需要重载小于运算；而数组和C-string，不能直接作为集合的元素，我们需要用一个结构把它包装起来并重载一个小于运算才行。例如：

.. code-block:: c++

   struct Point4D {
           double coord[4];

           bool operator<(const Point4D &p) const
           {
                   double l1 = coord[0] * coord[0];
                   double l2 = p.coord[0] * p.coord[0];
                   for (int d = 1; d < 4; ++d) {
                           l1 += coord[d] * coord[d];
                           l2 += p.coord[d] * p.coord[d];
                   }
                   return l1 < l2;
           }
   };

   set<Point4D> s_p4d;

例如四维空间中一个点的坐标，由4个 ``double`` 型浮点数构成，一般可以用一个长度为4的 ``double`` 型数组来表示。但是数组不能直接用做集合的元素类型，所以我们用一个结构来包装它。并且我们需要重载这个结构的小于比较运算符，让它们可以比较大小，这里我们用比较点到空间原点的距离的规则来比较点的大小，离原点越近的就认为越小。上面这样一个结构 ``Point4D`` 就可以作为集合的元素数据类型了。

接下来就是集合容器特殊的元素访问操作了，一共增删查三种操作。因为集合元素是键值合一的数据项，所以不提供修改操作。增删查三种操作一共四个成员函数。

添加元素的成员函数为 ``insert()``\ ，我们只需记得它最最常用的用法：提供一个数据项参数作为要添加的元素，不用理会它的返回值。例如：

.. code-block:: c++

   Point4D p(1,2,3,4);
   s_p4d.insert(p);

删除元素的成员函数为 ``erase()``\ ，它有两种常用的用法：一种是提供一个数据项参数，删除集合中与之相等的那个元素；另一种是提供一个指向集合中某个元素的迭代器，然后删除这个元素。例如：

.. code-block:: c++

   Point4D q(1,1,1,1);
   s_p4d.erase(q);                      // 删除值为(1,1,1,1)的那个元素
   s_p4d.erase(s_p4d.begin()+1);        // 删除集合中第2小的那个元素

查找元素的成员函数有两个：\ ``find()`` 函数需要提供一个数据项参数，查找集合中是否存在与之相等的元素，如果存在，返回指向该元素的迭代器，不存在则返回尾部迭代器；\ ``count()`` 函数同样需要一个数据项参数并在集合中查找，返回的是集合中与之相等的元素的数量。由于 ``set`` 集合要求元素全部互不相等，所以实际上 ``count()`` 函数的返回值只有两种，要么是0要么是1，不会有其他返回值。

``set`` 容器的最常用的操作就上述这些，很简单。在实际编程中，除了真正用做集合，这个容器还经常被利用来进行某些特殊场景下的排序，例如下面这个非常简单的练习。

.. admonition:: 练习

   连续输入20个整数，用空格或换行来分隔。要求剔除其中所有重复的数之后按照从大到小的顺序输出，每个数一行。使用 ``set`` 容器完成这个任务。

.. warning::

   虽然遇到上面这个练习这样的场景，用 ``set`` 似乎挺简单，而且时间复杂度也是 :math:`O(n\log n)`\ ，但是要注意，\ ``set`` 的实际排序速度比 ``sort()`` 要慢，而且它读取单个元素的时间也是 :math:`O(\log n)`\ ，也就是说遍历集合元素的整体时间是 :math:`O(n\log n)`\ ，比线性表容器慢！所以在需要高效率的算法问题中，不要利用 ``set`` 集合来做排序的事情。


