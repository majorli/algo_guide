高精度整数算法(I) 数据的表示
++++++++++++++++++++++++++++++++++++++++++

我们在数值算法的编程中，常常会遇到C++内置的整型数据类型可以表示的数值大小范围有限不够用导致的\ :strong:`溢出`\ 问题，:strong:`高精度整数算法`\ 就是用来解决这个问题的。我们可以利用C++的基础整数类型来拼接构造出一个理论上能达到无限位的超大整数数据类型，并且自己编程模拟手算过程来实现它的四则运算等数值计算，这就是\ :strong:`高精度整数算法`，简称\ :strong:`高精度算法`。

要实现一种完美的高精度整型及其运算不是一件容易的事情。一般来说，我们会定义一个结构体作为它的数据存储（在大型项目开发的实际工程编程中往往是用类而不是结构，但在算法编程中一般就用struct简化了），然后我们要给这个结构添加必要的成员函数来实现运算能力，最常见的有加减乘除、比较和赋值，另外还有一些辅助功能，比如初始化、输入输出（支持 ``cin`` 和 ``cout``），更加完善的还可以让它支持取模、运算赋值 ``+=,-=,*=,/=,%=``、自增减 ``++,--``、移位 ``<<,>>,<<=,>>=``、按位逻辑运算等等。这里有一些操作的实现是相当复杂的，比如除法和取模，有些运算则一般在具体的问题中用不着，甚至有一些在算法编程领域基本上不会用到。所以，除非你是在从事大型工程软件开发，需要实现一个完美的高精度整型数类，或者最近实在闲着无聊想找点事情挑战一下自己，否则一般我们不会去完全实现这些功能。

在算法编程中，最最常见的用到高精度算法的情形有以下几个要求：

1. 实现一个理论上数值范围无限大的整型数据类型；
2. 通常不要求支持负数；
3. 实现加减乘除四则运算和相互比较大小，若为非负型，则减法通常用不着或者弱化为取绝对值的求差运算；
4. 要求能够用C++内置整型数、字面量进行初始化和赋值。

有时候，为了编程时更加方便，还可以适当增加以下辅助功能：

1. 能够用 ``cin >>`` 进行输入，用 ``cout <<`` 进行输出；
2. 能够用字符串对象、C字符串、字符串字面量进行初始化和赋值；
3. 支持和C++内置整型数之间的加减乘除运算和相互比较大小；
4. 支持 ``+=, *=, ++, --`` 运算；
5. 声明变量但没有初始化时能自动初始化为0。

从这一节起我们将逐步实现符合上述要求的一个非负高精度整数算法（BigInt）。掌握了这些常用功能的实现之后，其他不常见的功能实现起来也应该不难了。最后我们会使用它来完成一个实际的算法编程题。


BigInt数据结构
^^^^^^^^^^^^^^

**原理**

为了实现高精度整型数，我们的基本思路很简单，用现有的C++基本整数类型构造一个顺序表来拼接出超大整型数。具体要怎样构造呢？

一个朴素的思路是这样的，既然我们的目标是无符号整数，那么何不用最大的基本类型 ``unsigned long long`` 来进行拼接呢？一个 ``unsigned long long`` 最大可以表示 :math:`2^{64}-1`，所以两个拼接就能使上限达到 :math:`2^{128}-1`，:math:`n` 个 ``unsigned long long`` 就可以拼接成一个 :math:`64n` 位的无符号二进制整数，最大可以表示十进制数 :math:`2^{64n}-1`。

事实上这种朴素的思路是汇编语言实现高精度整数的标准思路，但是并不适合C++语言。原因是这样的表示方法是基于二进制的，在进行运算时需要直接进行二进制运算。二进制运算是汇编语言的拿手好戏，但C++毕竟是一种高级语言，它并不提供完备的二进制运算能力，C++的数值运算是十进制的。所以我们要基于十进制来进行拼接，这里涉及到好几个技术细节问题需要逐一确定。

问题一，用哪一种基本数据类型来作为拼接单位？答案当然是 ``int``，因为C++标准规定，所有计算机系统上的所有C++版本，必须确保 ``int`` 是运算速度最快的数据类型！有人可能会问，既然我们的目标类型是非负的，那么为什么不用 ``unsigned int`` 呢？那是因为在做减法的时候，对位相减可能会出现负数需要借位，而 ``unsigned int`` 无法表示负数，导致用它来构造会很难实现减法运算。事实上，所有 ``unsigned`` 整型都不适合用来构造高精度整数。

问题二，采用多大的进制？用于拼接的每一个 ``int`` 数相当于整个 ``BigInt`` 数的一个数位，不妨把它叫做一个“:strong:`节`”吧（这是我自己给它取的名字，以避免和十进制的数位产生混淆，并不是标准的名称）。前面已经说过了拼接要基于十进制，即 ``BigInt`` 在内部要看成是 :math:`10^n` 进制的数，一个节的取值范围相应就是 :math:`0` 到 :math:`10^n-1`，对应十进制数的 :math:`n` 个数位。所以 :math:`n` 要取多大合适呢？由于 ``int`` 最大可表示的正数大约为21亿左右，所以理论上最大可以支持到 :math:`10^9`，即十亿进制。实践中常见的有采用亿进制的，也有采用万进制的。

在这里，我们选用我喜欢的万进制。为什么？明明一个 ``int`` 最大可以表示到十亿的数量级，但我们要让一个节限制在一万以内，即0到9999呢？这是极大的存储资源浪费！理由还是因为算法编程的特性。算法编程首先考虑的是程序编写正确，然后是运行速度够快，而存储空间往往可以用来大把大把地挥霍以换取便捷性和高速性。所以我们有两个理由来支持万进制：

1. 模拟乘法运算，基本操作是节与节之间的整数乘法，采用万进制，结果最大为 :math:`9999\times9999`，这个结果恰好还在 ``int`` 的可表示范围之内。所以 ``BigInt`` 乘法运算时，可以直接在节上进行运算，无需引入 ``long long`` 型的中间变量，大大简化乘法运算的代码。这是编程便捷性、减少错误点的理由。
2. 类似地，所有加减乘除运算都可以直接在节上采用 ``int`` 型运算完成，无需引入中间变量，能够提高运算速度，尤其是乘除法这样的复杂运算。这是提高速度的理由。

这就是我们建议在算法编程时采用万进制节来构造高精度的理由。而大型软件开发的工程编程时往往会更优先考虑空间消耗，故常选用亿进制。

通常，我们把进制数称为\ :strong:`基`\ （Base），例如十进制的基就是10，2进制的基就是2，所以 ``BigInt`` 的基等于10000。每一个节所表示的十进制位数我们习惯上称之为\ :strong:`宽`\ （Width），这里 ``BigInt`` 的宽是4，一个节对应4位十进制数位。所以万进制的 ``BigInt`` 数和通常的十进制数是可以对位划分节的（就好像2进制和16进制一样）。

例如：十进制数 ``1234567890987654321``，总共19位。用 ``BigInt`` 型表示它，可以从个位开始每4位划分为1节，总共分为5节，表示成 ``|123|4567|8909|8765|4321|``，其数值为 :math:`4321\times b^0+8765\times b^1+8909\times b^2+4567\times b^3+123\times b^4`，其中 :math:`b` 是基，等于10000。

问题三，具体用什么数据结构拼接？怎么拼接？从前面的表示形式就可以看出，最合适的数据结构是顺序表，具体实现时使用 ``vector<int>`` 是最常见的。但是怎么拼接确是有一定技巧性的。熟悉汇编语言的人会知道，以Intel的x86架构为代表的现代计算机系统里，整数在内存中存放时通常都采用一种叫做\ :strong:`小端序`\ （Little-Endian）的存放方式，即所谓的“低位在前、高位在后”。例如一个两字节的数 ``1234``，存放在内存里的时候会是 ``3412``。为什么会这样？因为加减法和乘法运算都需要两个运算数低位对齐！虽然除法运算从最高位对齐开始，但是整数除法往往不采用直接模拟竖式手工除法运算的方法，而且往往可以用乘法来代替。所以，为了更方便地实现不同长度整数之间的算术运算，小端序是现代更流行的整数存储方式。

.. admonition:: 补充

   整数存放于内存时，为了计算方便，常采用小端序。但在网络传输时，没有了计算了需求，所以常采用大端序，以人们习惯的高位在前的方式进行传输，同时也便于接收一方查看。毕竟人眼看数，还是习惯先看高位。

鉴于以上原因，我们的 ``BigInt`` 在拼接时也采用小端序！即低位节在前，高位节在后。例如上面所说的那个数 ``1234567890987654321``，用 ``BigInt`` 表示时，在其内部的顺序表中存放的情形将是：``{ 4321, 8765, 8909, 4567, 123 }``。看起来挺诡异，但是到编写算术运算代码时就会发现它的好处了。

**基本结构**

下面我们就可以写出最基础的结构体定义了。

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++
   :lines: 4-11, 36

.. note::

   在这个结构里面定义了两个成员常量 ``static const int BASE = 10000;`` 和 ``static const int WIDTH = 4;``。它们分别表示 ``BigInt`` 的基和节的占位数，即采用万进制，每一节对应4个十进制位。这两个常量是类型本身固有的属性，后面对它进行各种操作的代码中时常会用到这两个属性。所以我们事先把它们定义成常量，有需要时就可以采用这种有意义的名称来使用它们了。

   这里我们第一次见到的是 ``static`` 这个修饰词，它表示\ :strong:`静态`\ 的意思。``BASE`` 和 ``WIDTH`` 这两个常量对于所有的 ``BigInt`` 变量来说都是一样的，从不改变。如果我们像通常那样的定义它们，不加上静态修饰，那么它们就是普通的结构体的\ :strong:`成员常量`，每个变量里面都有一份，用 ``变量名.BASE`` 这样的通常的方式可以访问到它们。但是显然这样做是浪费空间的，因为常量的值已经定义永不改变，所以只有那些对所有 ``BigInt`` 变量都一样的永不改变的值才会定义为成员常量，而成员常量既然大家一样且永不改变，为什么要每个变量里面存放一份呢？浪费空间！所以 ``static`` 就是起这个作用的，用它修饰过之后，``BASE`` 和 ``WIDTH`` 就成为了\ :strong:`静态成员常量`，在内存里只保存一份，所有结构体变量共享使用。

   在结构体内部，也就是在结构体自己的成员函数里，如果要使用这样的静态成员变量，那么只要简单地用它们的名字 ``BASE`` 或者 ``WIDTH`` 就可以了。如果是结构体成员函数之外的程序里如果要访问它们，就需要加上结构类型名称的命名限定：``BigInt::BASE``、``BigInt::WIDTH``。所以静态成员常量也可以认为是隶属于这种数据类型的成员，而普通的成员常量是隶属于这种类型的具体变量的成员。

   类似地，其实成员变量和成员函数也可以用 ``static`` 修饰成静态的。凡是静态的成员，就升格为隶属于类型的成员，用 ``类型名::成员名`` 的方式访问，这个类型的所有变量共用一份。

   这里，我们在每一个成员的名称之前都加了一个下划线 ``_``。这是一种编程的惯例，通常用来表示这个成员是“仅限内部使用”的，即只供结构体内部的成员函数使用，请除此以外的程序中不要去访问这样的名称之前有下划线的成员。


现在我们已经有了最基本的 ``BigInt`` 的数据存储结构，但是它还没什么用，我们要对它进行功能扩展。和C语言结构体只能用来组合数据不同，C++的结构体除了可以用成员变量、常量来组合数据，还可以有成员函数来给它定义专属自己的功能。另外还有一种特殊的成员函数叫做\ :strong:`构造函数`，用来提供更加丰富灵活的初始化能力。


BigInt构造函数：初始化
^^^^^^^^^^^^^^^^^^^^^^^^

下面我们先从编写构造函数实现C++风格的初始化功能开始。目前的 ``BigInt`` 结构还只是一个类似C语言风格的结构体类型，如果用它来定义新的变量，没有办法对它进行初始化。``BigInt b;`` 这样的语句定义出来的新变量 ``b`` 内部的成员 ``vector<int> s`` 处于未初始化状态，长度为0，无法进行任何操作。

我们希望可以在定义新变量时自动把它的值设置为0，或者我们可以用一个C++内置整数类型的数值来赋予它初始值，避免新变量为空的尴尬。这种情况下用C++结构体的\ :strong:`构造函数`\ 是最合适的。所谓构造函数，顾名思义，就是在生成新变量的时候用来构造它的初始情况的函数。

* 构造函数没有返回类型，不需要返回语句，构造函数的函数名必须和结构体同名（包括大小写），其他方面的规则和普通成员函数完全一样。
* 构造函数总是在一个结构体变量被定义的时候首先被运行，它的作用是初始化新变量。
* 一个结构可以依赖不同的参数表来提供多个不同版本的构造函数，用来提供丰富的多种多样的构造方法。
* 构造函数的使用方法是在定义新变量时在变量名后面加上构造函数的参数表，像调用一个函数一样调用它，具体调用那个版本，C++会根据实参来自动确定。
* 如果定义新变量时没有提供构造函数参数，那么C++会检查有没有不需要提供参数的构造函数，如果有就调用它，如果没有就什么都不干，就像C语言的时候一样。

所以让我们先来实现我们想要的这个构造函数：

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++
   :lines: 4-13, 15, 16, 36, 82-87
   :emphasize-lines: 10, 12, 15-19

.. note::

   这里我们先定义了一个成员函数 ``void BigInt::_assign(unsigned long long value)``，它真正实现把一个C++整数转换为 ``BigInt`` 内部数据的功能。构造函数 ``BigInt(unsigned long long value = 0)`` 只是简单地调用了它而已。为啥要把这个功能单独写成一个函数，而不是直接写在构造函数里呢？这是因为这个功能以后再别的地方还用得着，单独写开，以后别的函数也要用就不用重复写这些代码了。这叫做代码的\ :strong:`复用`，是一种重要的软件设计思想。

   同样的，在成员函数名前面加上一个下划线 ``_`` 表示这个成员函数只会在结构体内部被其他成员函数调用，请外部函数不要去调用这样的函数。事实上，这只是一种惯例，没有强制性。就算这么写了，你非要在结构体以外去访问这些成员也是不会有问题的，但这绝对不是一个好习惯。如果你喜欢严格地落实封装规则，那么可以去学习一下C++的类和访问控制语法，它们提供了一套严密的封装规则，但是这些属于面向对象领域的技能主要用于大型工程编程，在算法编程领域里，我们暂时只是引入一点惯例来提醒一下自己就够了。

   这里还有一个新的语法点，就是成员函数的原型与定义分离。为了减少结构体 ``struct BigInt`` 的代码长度，我们在结构体内只声明了 ``_assign()`` 函数的原型，它的实际代码写在结构体定义外部，通常是放在整个程序的后面。和普通函数的原型与定义分离写法稍有不同的地方，只是成员函数分离在外的函数定义中，在函数头上、函数名之前要加上命名限定 ``BigInt::``，用来表明自己是属于 ``BigInt`` 的成员函数。这是因为，不同结构体之间往往会有很多同名的函数，加上命名限定就不会互相冲突了。

   构造函数的参数表指明，它需要一个 ``unsigned long long`` 参数，这是C++内置整型的最大者，用它就可以支持C++原生的所有内置整型实参了。另外我们还把这个参数定义为有\ :strong:`默认值`\ 的参数，于是构造函数就有了两个版本，可以提供一个参数来初始化，也可以不提供参数，这时就会默认初始化为0，而不是像没有构造函数时那样傻傻地什么都不干，留下一个空的 ``_s`` 了。

   至于 ``_assign()`` 函数内部将参数值转成数个节，然后用小端序依次存放入 ``_s`` 中的功能是怎样实现的，我想大家应该很容易看懂。这里可以看出，即使函数体的定义被分离在结构体之外，但是除了函数名之前加上一个限定之外，在函数体内部是不会有任何区别的。例如仍然可以无障碍地访问成员变量 ``_s``，成员常量 ``_BASE``，没有任何限制。


现在，我们可以像这样来定义 ``BigInt`` 型的变量了：

.. code-block:: c++

   BigInt b1, b2(347), b3(123456789000012), b4(100001);  // b1 会被初始化为0

好，看上去初始化的任务已经通过编写构造函数实现了，但是好像还缺点什么。对了，我们现在的构造函数只能支持最大不超过 ``unsigned long long`` 的整数初始值，可是 ``BigInt`` 的目标是要理论上能支持无限长的整数的。如果我们有一个100位的整数要作为一个 ``BigInt`` 变量的初始值怎么办？

显然这样超长的整数在C++本身的数据类型中，恐怕也只能用字符串来模拟它的。所以我们是不是还应该有一个可以用字符串来进行初始化的构造函数呢？有了前面的经验，这项任务也并不难办到。于是 ``BigInt`` 结构再一次升级：

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++
   :lines: 1, 4-17, 36, 82-101
   :emphasize-lines: 12, 15, 24-36

.. note::

   这里利用C++函数重载的能力，定义了另一套基于字符串的构造函数和 ``_assign()`` 函数。看起来用字符串来初始化的代码稍微复杂一点，但是也不难理解，请务必看懂理解。


由于C++的 ``string`` 类和C语言字符串之间有很好的相互转换能力，所以我们现在又具备了这样的能力：

.. code-block:: c++

   string s1 = "";
   BigInt b5(s1);    // 空字符串将初始b7的值为0
   BitInt b6("987654321012345678909876543210123456789000");


BigInt赋值运算
^^^^^^^^^^^^^^^^^^^^^^

光有初始化显然还不够，我们当然还需要有给 ``BigInt`` 变量赋值的能力，而且有了赋值的能力后我们还能像通常的内置数据类型一样使用 ``BigInt x = 3;`` 这样的语句来初始化变量。

要让自定义数据类型具有赋值运算的功能，就需要用到C++的一项神技：:strong:`运算符重载`。没错，就是像重载成员函数一样，为特定的自定义数据类型重载各类运算符，使得这些运算符能给特定的数据类型提供特定的功能。最典型的一个例子就是C++的 ``string`` 类，它重载了加法运算符 ``+``，使得我们可以用 ``str1 + str2`` 这样的运算来实现两个字符串的首尾相接，而不是通常意义上的加法。

现在我们就来看看怎样为 ``BigInt`` 重载赋值运算符 ``=``。由于已经有了可以复用的函数 ``_assign()``，所以我们接下来只要在结构体内增加这样一个函数：

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++
   :lines: 19-23

现在我们可以在程序里使用这样的代码：

.. code-block:: c++

   BigInt b7 = b8 = 666, b9 = 0;
   b9 = 373 + 737;

.. note::

   运算符重载有特定的函数原型，不同的运算符的重载函数原型可能不太一样，这是需要记忆的。在接下来对 ``BigInt`` 类型逐渐完善的过程中，我们还可以看到很多常见的运算符重载函数的样子，基本上记住这些就足够了。关于运算符的重载函数语法规则，有兴趣的可以去翻阅相关的书籍和网站。

   大多数运算的返回值就是被运算的变量自己，比如这里的赋值运算，要返回的就是被赋值的变量自己，这时候就应该以引用的方式返回 ``*this``。``this`` 是一个C++语言固定的特殊指针，用于成员函数，顾名思义就是指向自己的指针，所以返回 ``*this`` 就是返回自己。

   运算符重载函数的函数名有固定格式：``operator`` 后跟运算符，比如这里的 ``operator=``。

   运算符重载函数的参数，如果是基本数据类型的就用普通的传值方式，派生数据类型则用 ``const`` 引用传参，不建议在运算时改变实参变量的值。

   关于赋值运算，核心不是中间那句对 ``_assign()`` 函数的调用，不要忘了赋值之前先调用 ``_s.clear()`` 清空原有数据。

要知道，运算符重载函数本身也是可以重载的，所以我们可以用类似的方式来实现用字符串赋值，以及 ``BigInt`` 变量之间的相互赋值，只需再增加下面这两个参数表不同的重载函数即可：

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++
   :lines: 25-35

.. note::

   由于这三个赋值运算重载函数都很简单，所以我们没有分离函数原型和函数定义，而是直接把函数定义写在了结构体内部。但这并不表示运算符重载函数不能写成分离形式。

   ``_s.assign()`` 是 ``vector`` 类的成员函数，用来做多元素的批量赋值。如果原有的元素数量不够，那么会自动添加新元素完成赋值。

   ``_s.begin()`` 和 ``_s.end()`` 返回 ``_s`` 的一头一尾两个迭代器，类型为 ``vector<int>::iterator``。所谓迭代器，本质上还是一个指针。头尾迭代器分别指向第一个元素和最后一个元素后面一个的位置（含头不含尾）。STL容器类全都提供了这两个迭代器，可以像通常的指针一样的使用它们来在元素之间游走和访问所指向元素的值。很多批量元素操作都支持用一头一尾两个迭代器来指定要操作的范围（全部采用含头不含尾惯例）。

于是我们比较完美地完成了 ``BigInt`` 类型的赋值功能，我们可以这样来使用：

.. code-block:: c++

   BigInt b10 = "1234567890987654321";
   b9 = b10;


BigInt输入输出
^^^^^^^^^^^^^^^^^^^^^^

如果我们可以让 ``BigInt`` 也能像其他内置的数据类型一样，可以用IO流来进行输入输出的话，那么它就更加完美了。为了达到这个目的，我们可以重载C++的IO流运算符 ``<<`` 和 ``>>``。

这两个运算符是C++流对象特有的，要重载它们，我们首先需要引入iostream库。为了在输出的时候能够控制输出格式，还需要引入iomanip库。因为它们本身并不是 ``BigInt`` 的运算，而是输出流 ``ostream`` 和 ``istream`` 的运算，而且我们使用了简单的结构体来构造 ``BigInt`` 类型，对其中的成员并没有设置严格的访问限制，所以我们可以直接在 ``BigInt`` 结构体之外单独地重载 ``<<`` 和 ``>>``。

流输入输出的运算符重载有其自己特定的格式，函数原型如下：

.. code-block:: c++

   #include <iostream>
   #include <iomanip>

   ostream &operator<<(ostream &os, const BigInt &bi);  // 重载输出运算 <<
   istream &operator>>(istream &is, BigInt &bi);        // 重载输入运算 >>

.. note::

   ``ostream`` 和 ``istream`` 是C++输出流和输入流的基本类型（基类），所有实际的输入输出流对象都是从它们两个继承而来的，比如最常见的标准输入输出流 ``cin`` 和 ``cout``，还有文件流、字符串流等。所以重载了这两个运算符之后，不光我们可以实现用 ``cin >>`` 和 ``cout <<`` 来从键盘输入、向屏幕输出 ``BigInt`` 型数据，而且我们同时实现了读写文件等其他所有方式的 ``BigInt`` 数据输入输出。

   这一点非常棒，如果我们不去实现这种IO流的重载，当然也可以自己编写成员函数，用 ``scanf/printf`` 等C语言输入输出方式来实现 ``BigInt`` 的读写，但是对于不同的IO方式可能就要编写不同的函数了。

   上面这两个重载函数的原型格式是固定的，如果我们还要实现对其他自定义类型的输入输出，那么也参考这两个原型，只需改一下参数表中第二个参数的类型就可以了。


实现 ``BigInt`` 输入的方法非常简单，因为我们已经有了用字符串给 ``BigInt`` 赋值的方法，所以我们只要先以字符串形式读入，然后用读入的这个字符串去赋值就可以了。

实现输出的方法同样很简单，只要从高到低的输出每一个节的数值就可以了。第一个节，也就是最高位上的节，用默认格式输出即可。从第二个节开始，每个节要确保按4位十进制整数的格式输出，不足4位的要在左边补0。比如12，就要输出为0012这样的形式。这里涉及到一些格式化输出的技巧：

1. 在输出流中，可以使用一些叫做\ :strong:`流操纵算子`\ 的函数来控制输出格式，它们包含在 ``iomanip`` 库中，所以要引入这个库；
2. 使用 ``setw()`` 算子，可以控制下一次输出时的最短宽度，比如 ``cout << setw(4) << x`` 就可以使得变量 ``x`` 的值在输出时至少占用4个字符的宽度；
3. 使用 ``left``、``right`` 这两个算子，可以控制下一次输出时数据的对齐方式，左对齐或右对齐；
4. 使用 ``setfill()`` 算子，可以控制下一次输出时如果实际数值位数小于指定的最小宽度，那么在空余地方填进什么字符，默认是填空格；
5. 请注意每次使用操纵算子设置的格式都是一次性的，仅针对下一次输出，随即就会自动复原为默认格式。

所以我们在输出非最高位的节时，应该在每次输出前采用这样的方式来控制输出格式：``... << right << setw(4) << setfill('0') << ...``。

现在我们已经让 ``BigInt`` 类初具雏形了，已经实现了定义、初始化、赋值和输入输出，下面给出到目前为止的完整代码和测试代码：

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++

编译运行后的结果如下：

.. code-block:: none

   Testing initialization
   ======================
   0
   347
   123456789000012
   100001
   Testing assigning
   ======================
   110
   666
   100001
   9207358
   0
   9207358
   Testing string init
   ======================
   0
   987654321012345678909876543210123456789000
   Testing string assign
   ======================
   31415926535
   0
   Testing cin input
   ======================
   123456789000000000000           # 这一行是输入
   123456789000000000000
   0 19087650432001100010000       # 这一行是输入
   0 and 19087650432001100010000
   

.. attention::

   为了比较完整地说明自定义数据类型和高精度整数类型的实现技术，我们实现了比较多的功能，比如用多种方式进行初始化，比如流输入输出等。在实际编程解决算法问题的时候，往往并不一定要用到所有的功能。考场编程必然是采取“极简”的策略，只实现必不可少的部分，任何可有可无的代码都应该避免。所以具体解决问题的时候，高精度整数算法要如何实现，实现哪些功能，还需不需要增加一些其他功能等等问题，都是要临场判断随机应变的。

   重要的是理解方法，记住必须记住的语法，不要死记硬背代码。

