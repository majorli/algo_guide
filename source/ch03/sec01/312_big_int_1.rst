高精度整数算法(I) 数据的表示
++++++++++++++++++++++++++++++++++++++++++

我们在数值算法的编程中，常常会遇到C++内置的整型数据类型可以表示的数值大小范围有限不够用导致的\ :strong:`溢出`\ 问题，:strong:`高精度整数算法`\ 就是用来解决这个问题的。我们可以利用C++的基础整数类型来拼接构造出一个理论上能达到无限位的超大整数数据类型，并且自己编程模拟手算过程来实现它的四则运算等数值计算，这就是\ :strong:`高精度整数算法`，简称\ :strong:`高精度算法`。

要实现一种完美的高精度整型及其运算不是一件容易的事情。一般来说，我们会定义一个结构体作为它的数据存储（在大型项目开发的实际工程编程中往往是用类而不是结构，但在算法编程中一般就用struct简化了），然后我们要给这个结构添加必要的成员函数来实现运算能力，最常见的有加减乘除、比较和赋值，另外还有一些辅助功能，比如初始化、输入输出（支持 ``cin`` 和 ``cout``），更加完善的还可以让它支持取模、运算赋值 ``+=,-=,*=,/=,%=``、自增减 ``++,--``、移位 ``<<,>>,<<=,>>=``、按位逻辑运算等等。这里有一些操作的实现是相当复杂的，比如除法和取模，有些运算则一般在具体的问题中用不着，甚至有一些在算法编程领域基本上不会用到。所以，除非你是在从事大型工程软件开发，需要实现一个完美的高精度整型数类，或者最近实在闲着无聊想找点事情挑战一下自己，否则一般我们不会去完全实现这些功能。

在算法编程中，最最常见的用到高精度算法的情形有以下几个要求：

1. 实现一个理论上数值范围无限大的整型数据类型；
2. 通常不要求支持负数；
3. 实现加减乘除四则运算和相互比较大小，若为非负型，则减法通常用不着或者弱化为取绝对值的求差运算；
4. 要求能够用C++内置整型数、字面量进行初始化和赋值。

有时候，为了编程时更加方便，还可以适当增加以下辅助功能：

1. 能够用 ``>>`` 进行输入，用 ``<<`` 进行输出；
2. 能够用字符串对象、C字符串、字符串字面量进行初始化和赋值；
3. 支持和C++内置整型数之间的加减乘除运算和相互比较大小；
4. 支持 ``+=, -=, *=, \=, ++, --`` 等能带来编程便捷性的运算；
5. 声明变量但没有初始化时能自动初始化为0。

从这一节起我们将逐步实现符合上述要求的一个非负高精度整数算法（BigInt）。掌握了这些常用功能的实现之后，其他不常见的功能实现起来也应该不难了。最后我们会完成一个实际的算法编程题，看看在实际解决问题的时候可以如何简化高精度算法。


BigInt数据结构
^^^^^^^^^^^^^^

**原理**

为了实现高精度整型数，我们的基本思路很简单，用现有的C++基本整数类型构造一个顺序表来拼接出超大整型数。具体要怎样构造呢？

一个朴素的思路是这样的，既然我们的目标是无符号整数，那么何不用最大的基本类型 ``unsigned long long`` 来进行拼接呢？一个 ``unsigned long long`` 最大可以表示 :math:`2^{64}-1`，所以两个拼接就能使上限达到 :math:`2^{128}-1`，:math:`n` 个 ``unsigned long long`` 就可以拼接成一个 :math:`64n` 位的无符号二进制整数，最大可以表示十进制数 :math:`2^{64n}-1`。

事实上这种朴素的思路是汇编语言实现高精度整数的标准思路，但是并不适合C++语言。原因是这样的表示方法是基于二进制的，在进行运算时需要直接进行二进制运算。二进制运算是汇编语言的拿手好戏，但C++毕竟是一种高级语言，它并不提供完备的二进制运算能力，C++的数值运算是十进制的。所以我们要基于十进制来进行拼接，这里涉及到好几个技术细节问题需要逐一确定。

问题一，用哪一种基本数据类型来作为拼接单位？答案当然是 ``int``，因为C++标准规定，所有计算机系统上的所有C++版本，必须确保 ``int`` 是运算速度最快的数据类型！有人可能会问，既然我们的目标类型是非负的，那么为什么不用 ``unsigned int`` 呢？那是因为在做减法的时候，对位相减可能会出现负数需要借位，而 ``unsigned int`` 无法表示负数，导致用它来构造会很难实现减法运算。事实上，所有 ``unsigned`` 整型都不适合用来构造高精度整数。

问题二，采用多大的进制？用于拼接的每一个 ``int`` 数相当于整个 ``BigInt`` 数的一个数位，不妨把它叫做一个“:strong:`节`”吧（这是我自己给它取的名字，以避免和十进制的数位产生混淆，并不是标准的名称）。前面已经说过了拼接要基于十进制，即 ``BigInt`` 在内部要看成是 :math:`10^n` 进制的数，一个节的取值范围相应就是 :math:`0` 到 :math:`10^n-1`，对应十进制数的 :math:`n` 个数位。所以 :math:`n` 要取多大合适呢？由于 ``int`` 最大可表示的正数大约为21亿左右，所以理论上最大可以支持到 :math:`10^9`，即十亿进制。实践中常见的有采用亿进制的，也有采用万进制的。

在这里，我们选用我喜欢的万进制。为什么？明明一个 ``int`` 最大可以表示到十亿的数量级，但我们要让一个节限制在一万以内，即0到9999呢？这是极大的存储资源浪费！理由还是因为算法编程的特性。算法编程首先考虑的是程序编写正确，然后是运行速度够快，而存储空间往往可以用来大把大把地挥霍以换取便捷性和高速性。所以我们有两个理由来支持万进制：

1. 模拟乘法运算，基本操作是节与节之间的整数乘法，采用万进制，结果最大为 :math:`9999\times9999`，这个结果恰好还在 ``int`` 的可表示范围之内。所以 ``BigInt`` 乘法运算时，可以直接在节上进行运算，无需引入 ``long long`` 型的中间变量，大大简化乘法运算的代码。这是编程便捷性、减少错误点的理由。
2. 类似地，所有加减乘除运算都可以直接在节上采用 ``int`` 型运算完成，无需引入中间变量，能够提高运算速度，尤其是乘除法这样的复杂运算。这是提高速度的理由。

这就是我们建议在算法编程时采用万进制节来构造高精度的理由。而大型软件开发的工程编程时往往会更优先考虑空间消耗，故常选用亿进制。

通常，我们把进制数称为\ :strong:`基`\ （Base），例如十进制的基就是10，2进制的基就是2，所以 ``BigInt`` 的基等于10000。每一个节所表示的十进制位数我们习惯上称之为\ :strong:`宽`\ （Width），这里 ``BigInt`` 的宽是4，一个节对应4位十进制数位。所以万进制的 ``BigInt`` 数和通常的十进制数是可以对位划分节的（就好像2进制和16进制一样）。

例如：十进制数 ``1234567890987654321``，总共19位。用 ``BigInt`` 型表示它，可以从个位开始每4位划分为1节，总共分为5节，表示成 ``|123|4567|8909|8765|4321|``，其数值为 :math:`4321\times b^0+8765\times b^1+8909\times b^2+4567\times b^3+123\times b^4`，其中 :math:`b` 是基，等于10000。

问题三，具体用什么数据结构拼接？怎么拼接？从前面的表示形式就可以看出，最合适的数据结构是顺序表，具体实现时使用 ``vector<int>`` 是最常见的。但是怎么拼接确是有一定技巧性的。熟悉汇编语言的人会知道，以Intel的x86架构为代表的现代计算机系统里，整数在内存中存放时通常都采用一种叫做\ :strong:`小端序`\ （Little-Endian）的存放方式，即所谓的“低位在前、高位在后”。例如一个两字节的数 ``1234``，存放在内存里的时候会是 ``3412``。为什么会这样？因为加减法和乘法运算都需要两个运算数低位对齐！虽然除法运算从最高位对齐开始，但是整数除法往往不采用直接模拟竖式手工除法运算的方法，而且往往可以用乘法来代替。所以，为了更方便地实现不同长度整数之间的算术运算，小端序是现代更流行的整数存储方式。

.. admonition:: 补充

   整数存放于内存时，为了计算方便，常采用小端序。但在网络传输时，没有了计算了需求，所以常采用大端序，以人们习惯的高位在前的方式进行传输，同时也便于接收一方查看。毕竟人眼看数，还是习惯先看高位。

鉴于以上原因，我们的 ``BigInt`` 在拼接时也采用小端序！即低位节在前，高位节在后。例如 ``1234567890987654321``，用 ``BigInt`` 表示时，在其内部的顺序表中存放的情形将是：``{ 4321, 8765, 8909, 4567, 123 }``。看起来挺诡异，但是到编写算术运算代码时就会发现它的好处了。

**基本结构**

下面我们就可以写出最基础的结构体定义了。

.. literalinclude:: ../../codes/312_bigint.cpp
   :language: c++
   :lines: 4-11, 49

.. note::

   在这个结构里面定义了两个成员常量 ``static const int BASE = 10000;`` 和 ``static const int WIDTH = 4;``。它们分别表示 ``BigInt`` 的基和节的占位数，即采用万进制，每一节对应4个十进制位。这两个常量是类型本身固有的属性，后面对它进行各种操作的代码中时常会用到这两个属性。所以我们事先把它们定义成结构的成员常量。

   这里我们第一次见到的是 ``static`` 这个修饰词，它表示\ :strong:`静态`\ 的意思。``BASE`` 和 ``WIDTH`` 这两个常量对于所有的 ``BigInt`` 变量来说都是一样的，从不改变。如果我们像通常那样的定义它们，不加上静态修饰，那么它们就是普通的\ :strong:`成员常量`，每个结构变量里面都存有一份。这就造成了空间浪费。``static`` 修饰可以解决这个问题，现在 ``BASE`` 和 ``WIDTH`` 成为了\ :strong:`静态成员`，它们在内存里只保存一份，所有结构体变量共享使用。

   结构体的成员函数如果要使用这样的静态成员，那么只要简单地用它们的名字 ``BASE`` 或者 ``WIDTH`` 就可以了。程序里其他地方如果要访问它们，就需要加上结构名的命名限定：``BigInt::BASE``、``BigInt::WIDTH``。所以静态成员可以认为是隶属于这种结构类型的成员，而普通的成员则是隶属于这种结构的变量的成员。

   类似地，其实成员变量和成员函数也可以用 ``static`` 修饰成静态的。凡是静态的成员，就升格为隶属于类型的成员，用 ``类型名::成员名`` 的方式访问，这个类型的所有变量共用一份。

   这里，我们在每一个成员的名称之前都加了一个下划线 ``_``。这是一种编程的惯例，通常用来表示这个成员是“仅限内部使用”的，即只供本结构的成员函数使用，请除此以外的程序都不要去访问这样的成员。


现在我们已经有了最基本的 ``BigInt`` 的数据存储结构，但是它还没什么用，我们要对它进行功能扩展。和C语言结构只能用来组合数据不同，C++的结构除了可以用成员变量、常量来组合数据，还可以有成员函数来给它定义专属自己的功能。另外还有一种特殊的成员函数叫做\ :strong:`构造器`，用来提供丰富灵活的初始化能力。


BigInt构造器：初始化
^^^^^^^^^^^^^^^^^^^^^^^^

下面我们先从利用构造器来实现C++风格的初始化功能开始。目前的 ``BigInt`` 还只是一个类似C语言风格的结构类型，如果用它来定义新的变量，没有办法对它进行初始化。``BigInt b;`` 这样的语句定义出来的新变量 ``b`` 内部的成员 ``vector<int> _s`` 处于未初始化状态，长度为0，无法进行任何操作。

我们希望可以在定义新变量时自动把它的值设置为0，或者我们可以用一个C++内置整数类型的数值来赋予它初始值，避免新变量为空的尴尬。这种情况下用\ :strong:`构造器`\ 是最合适的。所谓构造器，顾名思义，就是在生成新变量的时候用来构造初始状态的函数。

* 构造器没有返回类型，不需要返回语句，构造器的函数名必须和结构名完全相同。
* 构造器总是在一个结构变量被生成的时候首先被运行，它的作用是初始化新变量。
* 一个结构可以有多个参数表不同的构造器，使其具有多种多样的构造方法。
* 构造器的使用方法是在定义新变量时在变量名后面加上构造器参数，就像调用一个函数一样。具体调用哪个构造器，C++会根据提供的参数来自动确定。
* 如果定义新变量时没有提供构造器参数，那么C++会检查有没有不需要提供参数的构造器，如果有就调用它，如果没有就什么都不干，就像C语言的时候一样。

所以让我们先来实现我们想要的这个构造器：

.. literalinclude:: ../../codes/312_bigint.cpp
   :language: c++
   :lines: 4-13, 15, 16, 49, 75-81, 97

.. note::

   这里我们先定义了一个成员函数 ``void _assign(unsigned long long value)``，它真正实现把一个C++整数转换为 ``BigInt`` 内部数据的功能。构造器 ``BigInt(unsigned long long value = 0)`` 只是简单地调用了它而已。为啥要把这个功能单独写成一个函数，而不是直接写在构造器里呢？这是因为这个功能以后在别的地方还用得着，单独写出来就可以重复利用了。这叫做代码的\ :strong:`复用`，是一种重要的软件设计思想。

   在成员函数名前面加上一个下划线 ``_`` 表示这个成员函数只供本结构的成员函数调用，请外部函数不要去调用它。这叫做\ :strong:`封装`，也是一种特别重要的软件设计思想。但事实上给成员名称前加一个下划线只是一种惯例，并不具备强制性。如果希望让C++严格地执行封装规则，那么可以使用C++的面向对象编程。它提供了一套复杂而严密的封装规则。在算法编程时我们一般不需要用到那么复杂的东西，在适当的时候引入一点小小的惯例来提醒一下自己就够了。

   这里还用到一个语法点：成员函数的原型与定义分离。为了减少结构内部的代码长度，我们在结构内只声明了函数原型，它们的函数定义被写在结构外部。:strong:`C++规范建议所有函数都采用原型与定义分离的方式书写`。成员函数和普通函数的函数定义写法稍有不同，在成员函数的函数定义中，函数名之前要加上命名限定 ``BigInt::``，用以表明自己是属于 ``BigInt`` 的成员函数。这是因为不同结构之间往往会有同名函数，加上命名限定就不会互相冲突了。

   这个构造器需要一个 ``unsigned long long`` 参数，这是C++内置整型的最大者，用它就可以使实参支持C++所有的内置整型。另外我们还把这个参数定义为有\ :strong:`默认值`\ 的参数，于是构造器就有了两个版本，既可以提供一个初始值参数，也可以不提供任何参数，这时就默认初始化为0。

   注意：当函数采用原型和定义分离的方式来写的时候，默认参数只能写在一个地方，要么写在函数原型的参数表里，要么写在函数定义中函数头的参数表里，不能两个地方都出现。一般我们都建议写在函数原型的参数表里。

   至于 ``_assign()`` 函数内部将参数值转成节，并用小端序依次存入 ``_s`` 中的功能是怎样实现的，我想大家应该很容易看懂。这里可以看出，即使函数体的定义被分离在结构之外，代码和写在结构内部时不会有任何区别，仍然可以无障碍地访问成员变量 ``_s``，成员常量 ``_BASE`` 等，没有任何限制。


现在，我们可以像这样来定义 ``BigInt`` 型的变量了：

.. code-block:: c++

   BigInt b1, b2(347), b3(123456789000012), b4(100001);  // b1 会被初始化为0

好像还缺点什么？对了，我们现在的构造器只能支持最大不超过 ``unsigned long long`` 的整数初始值，可是 ``BigInt`` 的目标是要理论上能支持无限长的整数的。如果我们要用一个100位的超长整数来初始化怎么办？

显然这样超长的整数在C++本身的数据类型中，恐怕也只能用字符串来模拟它。所以我们是不是还应该有一个可以用字符串来进行初始化的构造器呢？有了前面的经验，这项任务也并不难办到。于是 ``BigInt`` 结构再一次升级：

.. literalinclude:: ../../codes/312_bigint.cpp
   :language: c++
   :lines: 1, 4-17, 49, 75-99

.. note::

   这里利用C++函数重载的能力，定义了另一套基于字符串的构造器和 ``_assign()`` 函数。看起来用字符串来初始化的代码稍微复杂一点，但是也不难理解，请务必看懂理解。


由于C++的 ``string`` 类和C语言字符串之间有很好的相互转换能力，所以我们现在又具备了这样的能力：

.. code-block:: c++

   string s1 = "";
   BigInt b5(s1);    // 空字符串使初始值为0
   BitInt b6("987654321012345678909876543210123456789000");

.. warning::

   这里我们没有对字符串进行有效性验证，如果字符串不是一个合法的整数形式，那么会出现错误。这是因为考虑到算法编程题目的输入数据格式都是确保有效的，所以我们不费心去进行有效性验证。这也是算法编程的特殊性，在实际的软件开发中，输入有效性验证是必不可少的。


BigInt赋值运算
^^^^^^^^^^^^^^^^^^^^^^

光有初始化显然还不够，我们当然还需要有给 ``BigInt`` 变量赋值的能力，而且有了赋值的能力后我们还能像通常的内置数据类型一样使用 ``BigInt x = 3;`` 这样的语句来初始化变量。

要让自定义数据类型具有赋值运算的功能，就需要用到C++的一项神技：:strong:`运算符重载`。没错，就是像重载成员函数一样，为特定的自定义数据类型重载各类运算符，使得这些运算符能给特定的数据类型提供特定的功能。最典型的一个例子就是C++的 ``string`` 类，它重载了加法运算符 ``+``，使得我们可以用 ``str1 + str2`` 这样的运算来实现两个字符串的首尾相接，而不是通常意义上的加法。

现在我们就来看看怎样为 ``BigInt`` 重载赋值运算符 ``=``。由于已经有了可以复用的函数 ``_assign()``，所以我们接下来只要在结构体内增加重载赋值运算符的函数原型：

.. code-block:: c++
   
   struct BigInt {
           // ...
           BigInt &operator=(unsigned long long value);
           // ...
   };

然后给出它的定义：

.. literalinclude:: ../../codes/312_bigint.cpp
   :language: c++
   :lines: 103-108

现在我们可以在程序里使用这样的代码了：

.. code-block:: c++

   BigInt b7 = b8 = 666, b9 = 0;
   b9 = 373 + 737;

.. note::

   运算符重载有特定的函数原型，不同的运算符重载函数原型可能不太一样。接下来我们还会看到很多其他常见的运算符重载，基本上记住这些就足够了。关于运算符重载函数的语法规则，有兴趣的可以去查阅相关的书籍和网站。

   赋值运算要返回的被赋值变量被赋予的值，这通过以引用方式返回 ``*this`` 来实现。``this`` 是一个C++的特殊指针，用于成员函数中。顾名思义就是指向自己的指针，所以返回 ``*this`` 就是返回自己。

   运算符重载函数的函数名有固定格式：``operator`` 后跟运算符，比如这里的 ``operator=``。

   运算符重载函数的参数，如果是基本数据类型的就用普通的传值方式，派生数据类型则用 ``const`` 引用传参，避免在运算时改变外部变量的值。

   调用 ``_assign()`` 函数完成赋值之前先调用的 ``_s.clear()`` 函数是用来清空原有数据的。

要知道，运算符重载函数本身也是可以重载的，所以我们可以用类似的方式来实现用字符串赋值。函数原型：

.. code-block:: c++

   struct BigInt {
           // ...
           BigInt &operator=(const string &str);
           // ...
   };

函数定义：

.. literalinclude:: ../../codes/312_bigint.cpp
   :language: c++
   :lines: 110-115

现在我们比较完美地完成了 ``BigInt`` 类型的赋值功能，我们可以这样来使用：

.. code-block:: c++

   b9 = "1234567890987654321";
   b8 = b9;      // 别忘了结构变量天生具有相互赋值的能力
   // 唯一的遗憾是在初始化时如果要用C字符串，则不能用传统的赋初始值的方式
   BigInt b10 = "12345";   // 这样是不行的，编译会报错：不支持的类型转换
   // 替代方案1：用C++构造器
   BigInt b11("12345");
   // 替代方案2：先定义，后赋值
   BigInt b12;
   b12 = "12345";
   // 替代方案3：生成临时的c++ string
   BigInt b13 = string("12345");


BigInt输入输出
^^^^^^^^^^^^^^^^^^^^^^

如果我们可以让 ``BigInt`` 也能像内置数据类型一样使用IO流输入输出的话，它就更加完美了。为了达到这个目的，我们可以重载C++的IO流运算符 ``<<`` 和 ``>>``。这两个运算符是IO流的运算符，要重载它们，我们首先需要引入iostream库。为了在输出的时候能够控制输出格式，还需要引入iomanip库（流操纵库）。

因为它们俩并不是 ``BigInt`` 的运算符，而是输出流 ``ostream`` 和 ``istream`` 的，所以重载函数不定义在结构内部。重载函数的原型如下：

.. literalinclude:: ../../codes/312_bigint.cpp
   :language: c++
   :lines: 2, 3, 50-53


.. note::

   ``ostream`` 和 ``istream`` 是C++输出流和输入流的基本类型（基类），所有实际的输入输出流对象都是从它们两个继承而来的，比如最常见的标准输入输出流 ``cin`` 和 ``cout``，还有文件流、字符串流等。所以重载了这两个运算符之后，不光我们可以实现用 ``cin >>`` 和 ``cout <<`` 来从键盘输入、向屏幕输出 ``BigInt`` 型数据，而且我们同时实现了读写文件等其他所有方式的 ``BigInt`` 数据输入输出。这一点非常棒！

   上面这两个重载函数的原型格式是固定的，如果我们还要实现对其他自定义类型的输入输出，那么也参考这两个原型，只需改一下参数表中第二个参数的类型就可以了。


实现 ``BigInt`` 输入的方法非常简单，因为我们已经有了用字符串赋值的方法，所以我们只要先以字符串形式读入数据，然后用这个字符串去赋值就可以了。

实现输出的方法同样很简单，只要从高到低的输出每一个节的数值就可以了。第一个节，也就是最高位上的节，用默认格式输出即可。从第二个节开始，每个节要确保按4位十进制整数的格式输出，不足4位的要在左边补0。比如12，就要输出为0012这样的形式。这里涉及到一些格式化输出的技巧：

1. 在输出流中，可以使用一些叫做\ :strong:`流操纵算子`\ 的函数来控制输出格式，它们包含在 ``iomanip`` 库中，所以要引入这个库；
2. 使用 ``setw()`` 算子，可以控制下一次输出时的最短宽度，比如 ``cout << setw(4) << x`` 就可以使得变量 ``x`` 的值在输出时至少占用4个字符的宽度；
3. 使用 ``left``、``right`` 这两个算子，可以控制下一次输出时数据的对齐方式，左对齐或右对齐；
4. 使用 ``setfill()`` 算子，可以控制下一次输出时如果实际数值位数小于指定的最小宽度，那么在空余地方填进什么字符，默认是填空格；
5. 请注意每次使用操纵算子设置的格式都是一次性的，仅针对下一次输出，随即就会自动复原为默认格式。

所以每次在输出非最高位的节之前应这样控制输出格式：``... << right << setw(4) << setfill('0') << ...``。

现在我们已经让 ``BigInt`` 类初具雏形了，已经实现了定义、初始化、赋值和输入输出。为了给今后实现加减乘除的算术运算时提供一点小便利，我们还给 ``BigInt`` 增加了一个小小的辅助功能函数 ``zero()`` 用来判断自己是不是等于0。下面给出到目前为止的完整代码：

.. literalinclude:: ../../codes/312_bigint.cpp
   :language: c++
   :lines: 1-22, 49-115

.. attention::

   为了比较完整地说明自定义数据类型和高精度整数类型的实现技术，我们实现了比较多的功能，比如用多种方式进行初始化，比如流输入输出等。在实际编程解决算法问题的时候，往往并不一定要用到所有的功能。考场编程必然是采取“极简”的策略，只实现必不可少的部分，任何可有可无的代码都应该避免。所以具体解决问题的时候，高精度整数算法要如何实现，实现哪些功能，还需不需要增加一些其他功能等等问题，都是要临场判断随机应变的。

   重要的是理解方法，记住必须记住的语法，不要死记硬背代码。

