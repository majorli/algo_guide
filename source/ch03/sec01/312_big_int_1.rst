高精度整数算法(I) 数据的表示
++++++++++++++++++++++++++++++++++++++++++

我们在数值算法的编程中，常常会遇到C++内置的整型数据类型可以表示的数值大小范围有限不够用导致的\ :strong:`溢出`\ 问题，:strong:`高精度整数算法`\ 就是用来解决这个问题的。我们可以利用C++的基础整数类型来拼接构造出一个理论上能达到无限位的超大整数数据类型，并且自己编程模拟手算过程来实现它的四则运算等数值计算，这就是\ :strong:`高精度整数算法`，简称\ :strong:`高精度算法`。

要实现一种完美的高精度整型及其运算不是一件容易的事情。一般来说，我们会定义一个结构体作为它的数据存储（在大型项目开发的实际工程编程中往往是用类而不是结构，但在算法编程中一般就用struct简化了），然后我们要给这个结构添加必要的成员函数来实现运算能力，最常见的有加减乘除、比较和赋值，另外还有一些辅助功能，比如初始化、输入输出（支持 ``cin`` 和 ``cout``），更加完善的还可以让它支持取模、运算赋值 ``+=,-=,*=,/=,%=``、自增减 ``++,--``、移位 ``<<,>>,<<=,>>=``、按位逻辑运算等等。这里有一些操作的实现是相当复杂的，比如除法和取模，有些运算则一般在具体的问题中用不着，甚至有一些在算法编程领域基本上不会用到。所以，除非你是在从事大型工程软件开发，需要实现一个完美的高精度整型数类，或者最近实在闲着无聊想找点事情挑战一下自己，否则一般我们不会去完全实现这些功能。

在算法编程中，最最常见的用到高精度算法的情形有以下几个要求：

1. 实现一个理论上数值范围无限大的整型数据类型；
2. 通常不要求支持负数；
3. 实现加减乘除四则运算和相互比较大小，若为非负型，则减法通常用不着或者弱化为取绝对值的求差运算；
4. 要求能够用C++内置整型数、字面量进行初始化和赋值。

有时候，为了编程时更加方便，还可以适当增加以下辅助功能：

1. 能够用 ``cin >>`` 进行输入，用 ``cout <<`` 进行输出；
2. 能够用字符串对象、C字符串、字符串字面量进行初始化和赋值；
3. 支持和C++内置整型数之间的加减乘除运算和相互比较大小；
4. 支持 ``+=, *=, ++, --`` 运算；
5. 声明变量但没有初始化时能自动初始化为0。

从这一节起我们将逐步实现符合上述要求的一个非负高精度整数算法（BigInt）。掌握了这些常用功能的实现之后，其他不常见的功能实现起来也应该不难了。最后我们会使用它来完成一个实际的算法编程题。


BigInt数据结构
^^^^^^^^^^^^^^

**原理**

为了实现高精度整型数，我们的基本思路很简单，用现有的C++基本整数类型构造一个顺序表来拼接出超大整型数。具体要怎样构造呢？

一个朴素的思路是这样的，既然我们的目标是无符号整数，那么何不用最大的基本类型 ``unsigned long long`` 来进行拼接呢？一个 ``unsigned long long`` 最大可以表示 :math:`2^{64}-1`，所以两个拼接就能使上限达到 :math:`2^{128}-1`，:math:`n` 个 ``unsigned long long`` 就可以拼接成一个 :math:`64n` 位的无符号二进制整数，最大可以表示十进制数 :math:`2^{64n}-1`。

事实上这种朴素的思路是汇编语言实现高精度整数的标准思路，但是并不适合C++语言。原因是这样的表示方法是基于二进制的，在进行运算时需要直接进行二进制运算。二进制运算是汇编语言的拿手好戏，但C++毕竟是一种高级语言，它并不提供完备的二进制运算能力，C++的数值运算是十进制的。所以我们要基于十进制来进行拼接，这里涉及到好几个技术细节问题需要逐一确定。

问题一，用哪一种基本数据类型来作为拼接单位？答案当然是 ``int``，因为C++标准规定，所有计算机系统上的所有C++版本，必须确保 ``int`` 是运算速度最快的数据类型！有人可能会问，既然我们的目标类型是非负的，那么为什么不用 ``unsigned int`` 呢？那是因为在做减法的时候，对位相减可能会出现负数需要借位，而 ``unsigned int`` 无法表示负数，导致用它来构造会很难实现减法运算。事实上，所有 ``unsigned`` 整型都不适合用来构造高精度整数。

问题二，采用多大的进制？用于拼接的每一个 ``int`` 数相当于整个 ``BigInt`` 数的一个数位，不妨把它叫做一个“:strong:`节`”吧（这是我自己给它取的名字，以避免和十进制的数位产生混淆，并不是标准的名称）。前面已经说过了拼接要基于十进制，即 ``BigInt`` 在内部要看成是 :math:`10^n` 进制的数，一个节的取值范围相应就是 :math:`0` 到 :math:`10^n-1`，对应十进制数的 :math:`n` 个数位。所以 :math:`n` 要取多大合适呢？由于 ``int`` 最大可表示的正数大约为21亿左右，所以理论上最大可以支持到 :math:`10^9`，即十亿进制。实践中常见的有采用亿进制的，也有采用万进制的。

在这里，我们选用我喜欢的万进制。为什么？明明一个 ``int`` 最大可以表示到十亿的数量级，但我们要让一个节限制在一万以内，即0到9999呢？这是极大的存储资源浪费！理由还是因为算法编程的特性。算法编程首先考虑的是程序编写正确，然后是运行速度够快，而存储空间往往可以用来大把大把地挥霍以换取便捷性和高速性。所以我们有两个理由来支持万进制：

1. 模拟乘法运算，基本操作是节与节之间的整数乘法，采用万进制，结果最大为 :math:`9999\times9999`，这个结果恰好还在 ``int`` 的可表示范围之内。所以 ``BigInt`` 乘法运算时，可以直接在节上进行运算，无需引入 ``long long`` 型的中间变量，大大简化乘法运算的代码。这是编程便捷性、减少错误点的理由。
2. 类似地，所有加减乘除运算都可以直接在节上采用 ``int`` 型运算完成，无需引入中间变量，能够提高运算速度，尤其是乘除法这样的复杂运算。这是提高速度的理由。

这就是我们建议在算法编程时采用万进制节来构造高精度的理由。而大型软件开发的工程编程时往往会更优先考虑空间消耗，故常选用亿进制。

通常，我们把进制数称为\ :strong:`基`\ （Base），例如十进制的基就是10，2进制的基就是2，所以 ``BigInt`` 的基等于10000。每一个节所表示的十进制位数我们习惯上称之为\ :strong:`宽`\ （Width），这里 ``BigInt`` 的宽是4，一个节对应4位十进制数位。所以万进制的 ``BigInt`` 数和通常的十进制数是可以对位划分节的（就好像2进制和16进制一样）。

例如：十进制数 ``1234567890987654321``，总共19位。用 ``BigInt`` 型表示它，可以从个位开始每4位划分为1节，总共分为5节，表示成 ``|123|4567|8909|8765|4321|``，其数值为 :math:`4321\times b^0+8765\times b^1+8909\times b^2+4567\times b^3+123\times b^4`，其中 :math:`b=10000`，就是基。

问题三，具体用什么数据结构拼接？怎么拼接？从前面的表示形式就可以看出，最合适的数据结构是顺序表，具体实现时使用 ``vector<int>`` 是最常见的。但是怎么拼接确是有一定技巧性的。熟悉汇编语言的人会知道，以Intel的x86架构为代表的现代计算机系统里，整数在内存中存放时通常都采用一种叫做\ :strong:`小端序`\ （Little-Endian）的存放方式，即所谓的“低位在前、高位在后”。例如一个两字节的数 ``1234``，存放在内存里的时候会是 ``3412``。为什么会这样？因为加减法和乘法运算都需要两个运算数低位对齐！虽然除法运算从最高位对齐开始，但是整数除法往往不采用直接模拟竖式手工除法运算的方法，而且往往可以用乘法来代替。所以，为了更方便地实现不同长度整数之间的算术运算，小端序是现代更流行的整数存储方式。

.. admonition:: 补充

   整数存放于内存时，为了计算方便，常采用小端序。但在网络传输时，没有了计算了需求，所以常采用大端序，以人们习惯的高位在前的方式进行传输，同时也便于接收一方查看。毕竟人眼看数，还是习惯先看高位。

鉴于以上原因，我们的 ``BigInt`` 在拼接时也采用小端序！即低位节在前，高位节在后。例如上面所说的那个数 ``1234567890987654321``，用 ``BigInt`` 表示时，在其内部的顺序表中存放的情形将是：``{ 4321, 8765, 8909, 4567, 123 }``。看起来挺诡异，但是到编写算术运算代码时就会发现它的好处了。

**基本结构**

下面我们就可以写出最基础的结构体定义了。

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++
   :lines: 4-11, 36

.. note::

   在这个结构里面定义了两个成员常量 ``static const int BASE = 10000;`` 和 ``static const int WIDTH = 4;``。它们分别表示 ``BigInt`` 的基和节的占位数，即采用万进制，每一节对应4个十进制位。这两个常量是类型本身固有的属性，后面对它进行各种操作的代码中时常会用到这两个属性。所以我们事先把它们定义成常量，有需要时就可以采用这种有意义的名称来使用它们了。

   这里我们第一次见到的是 ``static`` 这个修饰词，它表示\ :strong:`静态`\ 的意思。``BASE`` 和 ``WIDTH`` 这两个常量对于所有的 ``BigInt`` 变量来说都是一样的，从不改变。如果我们像通常那样的定义它们，不加上静态修饰，那么它们就是普通的结构体的\ :strong:`成员常量`，每个变量里面都有一份，用 ``变量名.BASE`` 这样的通常的方式可以访问到它们。但是显然这样做是浪费空间的，因为常量的值已经定义永不改变，所以只有那些对所有 ``BigInt`` 变量都一样的永不改变的值才会定义为成员常量，而成员常量既然大家一样且永不改变，为什么要每个变量里面存放一份呢？浪费空间！所以 ``static`` 就是起这个作用的，用它修饰过之后，``BASE`` 和 ``WIDTH`` 就成为了\ :strong:`静态成员常量`，在内存里只保存一份，所有结构体变量共享使用。

   在结构体内部，也就是在结构体自己的成员函数里，如果要使用这样的静态成员变量，那么只要简单地用它们的名字 ``BASE`` 或者 ``WIDTH`` 就可以了。如果是结构体成员函数之外的程序里如果要访问它们，就需要加上结构类型名称的命名限定：``BigInt::BASE``、``BigInt::WIDTH``。所以静态成员常量也可以认为是隶属于这种数据类型的成员，而普通的成员常量是隶属于这种类型的具体变量的成员。

   类似地，其实成员变量和成员函数也可以用 ``static`` 修饰成静态的。凡是静态的成员，就升格为隶属于类型的成员，用 ``类型名::成员名`` 的方式访问，这个类型的所有变量共用一份。

   这里，我们在每一个成员的名称之前都加了一个下划线 ``_``。这是一种编程的惯例，通常用来表示这个成员是“仅限内部使用”的，即只供结构体内部的成员函数使用，请除此以外的程序中不要去访问这样的名称之前有下划线的成员。


现在我们已经有了最基本的 ``BigInt`` 的数据存储结构，但是它还没什么用，我们要对它进行功能扩展。和C语言结构体只能用来组合数据不同，C++的结构体除了可以用成员变量、常量来组合数据，还可以有成员函数来给它定义专属自己的功能。另外还有一种特殊的成员函数叫做\ :strong:`构造函数`，用来提供更加丰富灵活的初始化能力。


BigInt构造函数：初始化
^^^^^^^^^^^^^^^^^^^^^^^^

下面我们先从编写构造函数实现C++风格的初始化功能开始。目前的 ``BigInt`` 结构还只是一个类似C语言风格的结构体类型，如果用它来定义新的变量，没有办法对它进行初始化。``BigInt b;`` 这样的语句定义出来的新变量 ``b`` 内部的成员 ``vector<int> s`` 处于未初始化状态，长度为0，无法进行任何操作。

我们希望可以在定义新变量时自动把它的值设置为0，或者我们可以用一个C++内置整数类型的数值来赋予它初始值，避免新变量为空的尴尬。这种情况下用C++结构体的\ :strong:`构造函数`\ 是最合适的。所谓构造函数，顾名思义，就是在生成新变量的时候用来构造它的初始情况的函数。

* 构造函数没有返回类型，不需要返回语句，构造函数的函数名必须和结构体同名（包括大小写），其他方面的规则和普通成员函数完全一样。
* 构造函数总是在一个结构体变量被定义的时候首先被运行，它的作用是初始化新变量。
* 一个结构可以依赖不同的参数表来提供多个不同版本的构造函数，用来提供丰富的多种多样的构造方法。
* 构造函数的使用方法是在定义新变量时在变量名后面加上构造函数的参数表，像调用一个函数一样调用它，具体调用那个版本，C++会根据实参来自动确定。
* 如果定义新变量时没有提供构造函数参数，那么C++会检查有没有不需要提供参数的构造函数，如果有就调用它，如果没有就什么都不干，就像C语言的时候一样。

所以让我们先来实现我们想要的这个构造函数：

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++
   :lines: 4-13, 15, 16, 36, 82-87
   :emphasize-lines: 10, 12, 15-19

.. note::

   这里我们先定义了一个成员函数 ``void BigInt::_assign(unsigned long long value)``，它真正实现把一个C++整数转换为 ``BigInt`` 内部数据的功能。构造函数 ``BigInt(unsigned long long value = 0)`` 只是简单地调用了它而已。为啥要把这个功能单独写成一个函数，而不是直接写在构造函数里呢？这是因为这个功能以后再别的地方还用得着，单独写开，以后别的函数也要用就不用重复写这些代码了。这叫做代码的\ :strong:`复用`，是一种重要的软件设计思想。

   同样的，在成员函数名前面加上一个下划线 ``_`` 表示这个成员函数只会在结构体内部被其他成员函数调用，请外部函数不要去调用这样的函数。事实上，这只是一种惯例，没有强制性。就算这么写了，你非要在结构体以外去访问这些成员也是不会有问题的，但这绝对不是一个好习惯。如果你喜欢严格地落实封装规则，那么可以去学习一下C++的类和访问控制语法，它们提供了一套严密的封装规则，但是这些属于面向对象领域的技能主要用于大型工程编程，在算法编程领域里，我们暂时只是引入一点惯例来提醒一下自己就够了。

   这里还有一个新的语法点，就是成员函数的原型与定义分离。为了减少结构体 ``struct BigInt`` 的代码长度，我们在结构体内只声明了 ``_assign()`` 函数的原型，它的实际代码写在结构体定义外部，通常是放在整个程序的后面。和普通函数的原型与定义分离写法稍有不同的地方，只是成员函数分离在外的函数定义中，在函数头上、函数名之前要加上命名限定 ``BigInt::``，用来表明自己是属于 ``BigInt`` 的成员函数。这是因为，不同结构体之间往往会有很多同名的函数，加上命名限定就不会互相冲突了。

   构造函数的参数表指明，它需要一个 ``unsigned long long`` 参数，这是C++内置整型的最大者，用它就可以支持C++原生的所有内置整型实参了。另外我们还把这个参数定义为有\ :strong:`默认值`\ 的参数，于是构造函数就有了两个版本，可以提供一个参数来初始化，也可以不提供参数，这时就会默认初始化为0，而不是像没有构造函数时那样傻傻地什么都不干，留下一个空的 ``_s`` 了。

   至于 ``_assign()`` 函数内部将参数值转成数个节，然后用小端序依次存放入 ``_s`` 中的功能是怎样实现的，我想大家应该很容易看懂。这里可以看出，即使函数体的定义被分离在结构体之外，但是除了函数名之前加上一个限定之外，在函数体内部是不会有任何区别的。例如仍然可以无障碍地访问成员变量 ``_s``，成员常量 ``_BASE``，没有任何限制。


现在，我们可以像这样来定义 ``BigInt`` 型的变量了：

.. code-block:: c++

   BigInt b1, b2(347), b3(123456789000012), b4(100001);  // b1 会被初始化为0

好，看上去初始化的任务已经通过编写构造函数实现了，但是好像还缺点什么。对了，我们现在的构造函数只能支持最大不超过 ``unsigned long long`` 的整数初始值，可是 ``BigInt`` 的目标是要理论上能支持无限长的整数的。如果我们有一个100位的整数要作为一个 ``BigInt`` 变量的初始值怎么办？

显然这样超长的整数在C++本身的数据类型中，恐怕也只能用字符串来模拟它的。所以我们是不是还应该有一个可以用字符串来进行初始化的构造函数呢？有了前面的经验，这项任务也并不难办到。于是 ``BigInt`` 结构再一次升级：

.. literalinclude:: ../../codes/312_bigint_1.cpp
   :language: c++
   :lines: 1, 4-17, 36, 82-101
   :emphasize-lines: 12, 15, 24-36

.. note::

   这里利用C++函数重载的能力，定义了另一套基于字符串的构造函数和 ``_assign()`` 函数。看起来用字符串来初始化的代码稍微复杂一点，但是也不难理解，请务必看懂理解。


由于C++的 ``string`` 类和C语言字符串之间有很好的相互转换能力，所以我们现在又具备了这样的能力：

.. code-block:: c++

   string s1 = "", s2 = "31415926535";
   BigInt b7(s1), b8("987654321012345678909876543210123456789000");



（待续）
