链表的C++实现
+++++++++++++

本节我们将使用C++语言实现单链表和双链表结构。作为数据结构这一领域的学习，我们将使用C++模板技术实现标准的链表ADT，可以接受任意类型的元素，具有以下标准功能：

1. 基本功能：

   1. 获取链表长度，即表中元素的数量；
   2. 判断链表是否为空；

2. 迭代访问：

   1. 获取链表首元素节点的指针，请注意是首元素的节点，不是头部的哑节点指针；
   2. 获取双链表的尾部指针，请注意是尾部的哑节点指针，不是尾元素的节点指针；
   3. 向后移动节点指针；
   4. 向前移动双链表节点指针。

3. 元素访问：

   1. 按照元素下标获取元素值；
   2. 根据节点指针获取元素值；
   3. 获取链表首元素；
   4. 获取双链表尾元素；
   5. 修改指定下标处的元素值；
   6. 修改给定节点（由指针给定）处的元素值。

4. 元素增删：

   1. 在链表头部插入新元素；
   2. 在双链表尾部添加新元素；
   3. 新元素插入为单链表给定节点（由指针给定）的后继；
   4. 新元素插入为双链表给定节点（由指针给定）的前驱，类似于顺序表中在指定元素位置处插入新元素；
   5. 删除链表首元素；
   6. 删除双链表的尾元素；
   7. 删除单链表给定节点（由指针给定）的后继；
   8. 删除双链表给定节点（由指针给定）本身。
   9. 清空链表。

以上是链表的常见标准功能，在学习数据结构时应全部予以掌握，在实际编程中可能会有所取舍或改变。本节详细介绍单链表的完整实现代码，双链表只做简单说明，代码实现将作为本节的练习。

.. attention::

   这一章是学习数据结构，在编写每一种数据结构的实现代码时我们都会用最接近面向对象的风格和工程编程的要求来编写一个比较完美的、甚至可以直接当做类库使用的抽象数据类型。这样的代码会比较繁琐，代码量大，在算法问题编程的时候如果要自己实现一些数据结构，不需要这样写，应该根据问题的要求，编写简化版的ADT，我们在这一章中的例题中会看到各种简化版代码。

单链表的实现
^^^^^^^^^^^^

**1、基本结构**

我们先定义好链表的基本结构形态，实现元素访问、迭代和其他一些基本功能。

首先我们需要设计一个用来存放元素节点的结构，为了可以适用于任何类型的元素，这里要用模板结构。如同上一节所述，常见的写法如下：

.. code-block:: c++

   template<typename T>
   struct Node {
           T _value;            // 元素值
           Node<T> *_next;      // 后继链指针

           // 构造函数
           Node() { _next = NULL; }                             // 默认构造函数
           Node(const &T val) { _value = val; _next = NULL; }   // 指定元素值的构造器
   };

这样就可以了，我们在成员变量的名称前加上下划线 ``'_'`` 只是为了表示数据封装的惯例，提醒编程人员不要在外部程序中直接访问使用这些成员变量。比如像下面这样的传统写法，现代程序设计理念认为是恶劣的：

.. code-block:: c++

   Node<int> n1(10), n2(11);
   int v = n1._value;
   n1._next = &n2;
   n2._value = v - 1;

但是如果外部程序代码遵循数据封装的惯例，不直接访问成员变量，那么外部程序要怎么才能获得结构里的元素值和后继指针呢？最常规的做法是给结构添加\ :strong:`访问器函数`\ （accessor），像下面这样：

.. code-block:: c++

   template<typename T>
   struct Node {
           T _value;            // 元素值
           Node<T> *_next;      // 后继链指针

           // 构造函数
           Node() { _next = NULL; }                             // 默认构造函数
           Node(const &T val) { _value = val; _next = NULL; }   // 指定元素值的构造器
           // 访问器函数
           T &value() { return _value; }                        // 访问元素值
           Node<T> *next() { return _next; }                    // 返回后继指针
	   void set_next(Node<T> *next) { _next = next; }       // 设置后继指针
   };

这是数据封装原则下的常规写法。

元素值的访问器 ``value()`` 返回的是成员变量 ``_value`` 的引用，所以只要这一个访问器就能同时满足外部程序对元素值进行读写的功能要求，例如：

.. code-block:: c++

   Node<int> n(2);      // 创建一个元素值为2的节点
   int v = n.value();   // 读取元素值
   n.value()--;         // 元素值减一
   n.value() = 3 * 3;   // 设置元素值

后继指针是一个指针类型，不能返回引用，所以需要有一读一写两个访问器，可以这样使用：

.. code-block:: c++

   Node<int> n1(1), n2(2), n3(3);
   n1.set_next(&n2);            // n1的后继设置为n2
   n3.set_next(n1.next());      // n3的后继设置为n1的后继

通常，这样写就很好了，大多数数据结构教程上就是这么写的。但是我们不打算采用这种风格，我们可以做得更酷炫，具体怎么做过一会儿再讲。

.. hint::

   算法问题编程时甚至往往会直接访问成员变量，连访问器都不用。如果那样的话，成员变量就不要用 ``'_'`` 来开头了，写写都挺麻烦的。

下面我们先来定义单链表结构，暂时先不要去管成员函数，先把成员变量和构造器设计好，通常是下面这样的形式：

.. code-block:: c++

   template<typename T>
   struct LinkedList {
           Node<T> *_head;      // 头指针，指向头部哑节点
           int _size;           // 链表长度

           // 构造函数
           LinkedList() { _size = 0; _head = new Node<T>; }
   };

但是这样还不够好！我们现在向使用者（比如利用这个单链表结构来进行算法编程的人）开放出了两个结构类型，一个是单链表本身 ``LinkedList``\ ，另一个是元素节点 ``Node``\ 。这样就出现了一个问题，使用者需要关心或者需要直接生成单独的元素节点吗？是不需要的，也是不应该的。

STL库有一个双链表容器 ``list``\ ，使用这个容器，通过迭代器、成员函数等方式可以像在 ``vector`` 容器或者最简单的数组里一样直接访问到元素值，而不是先要返回一个节点或者节点指针。换句话说，\ ``list`` 容器在实现的时候把节点这个中间环节向使用者隐藏了起来，它不光实现了把元素值和元素之间的链隐藏在节点里，而且连节点本身也被隐藏了。我们也打算这样做，做法是把 ``Node`` 结构定义到 ``LinkedList`` 结构内部去，形成一种嵌套的结构定义，内层的结构是外层结构的子结构。在把元素节点定义成单链表结构的子结构后，为了表示这个节点结构是给单链表结构私人定制的，外部使用者不得使用，我们也按惯例在它的名称之前加上下划线。所以现在我们的单链表结构变成下面这个样子：

.. code-block:: c++

   template<typename T>
   struct LinkedList {
           // 节点结构，内部结构
           struct _Node {
                   T _value;            // 元素值
                   Node<T> *_next;      // 后继链指针

                   // 构造函数
                   Node() { _next = NULL; }                             // 默认构造函数
                   Node(const &T val) { _value = val; _next = NULL; }   // 指定元素值的构造器
           };

           LinkedList<T>::_Node *_head; // 头指针
           int _size;                   // 表长度

           // 构造函数
           LinkedList() { _size = 0; _head = new LinkedList<T>::_Node; }
   };

.. note::

   1、把节点定义为内部结构之后，模板整个加载在外部结构 ``LinkedList`` 之上，所以节点结构 ``_Node`` 就不需要使用 ``<T>`` 的模板标注了，一律加在最外层的结构名后面，例如链表构造函数中的写法；
   
   2、代码中若要使用 ``_Node`` 结构，现在就必须使用全名 ``LinkedList<T>::_Node``\ ，即在它前面加上外层结构的名称并使用名称限定符 ``::`` 连接起来。

所以现在外部的使用者可以不用关心节点是怎么回事情了。

.. warning::

   事实上，STL的 ``list`` 容器是用类（class）来构造的，类有严格的访问控制机制，所以能够真正做到把内部结构或者内部类对外隐藏起来。但是我们是用结构（struct）来模仿，并没有真正地把 ``_Node`` 结构隐藏起来，外部使用者如果一定要自己创建节点，完全可以使用结构的全名自己创建，例如 ``LinkedList<int>::_Node my_node(17)`` 这样子。和成员变量一样，名称之前加一个下划线只是惯例，不是规则。

   其实类的访问控制机制也完全可以用于结构，但是面向对象不是我们现在要学的内容，而且太复杂，现在不要去管它，先模仿着就可以了。

接下来回到我们前面提过的要怎么不使用访问器，酷炫地访问节点里的元素值的问题。事实上，我们现在已经把节点结构封装隐藏起来了，哪怕它有访问器，遵守惯例的外部使用者也已经不能使用它们了。那么怎么办？

还记得我们曾经说过的STL库三大组成部分吗？其中有一个部分是迭代器：:ref:`ref-2562`\ 。我们说过，迭代器实际上是一个包装过的指针，可以像指针一样 ``++,--`` 前后移动，用解指针运算 ``*`` 来获取其中的内容。但是任何一种STL容器的迭代器都不会把节点这种中间结构暴露给使用者，例如 ``list`` 容器的迭代器 ``list<T>::iterator``\ ，我们可以像一个指针一样使用它，但是它的前移运算 ``--`` 是沿着双链表的前驱链移动，后移运算 ``++`` 是沿着后继链移动，解指针之后得到的也不是 ``list`` 的节点，而是直接得到节点里的元素值。

所以我们要做的就是仿造一个迭代器，当然就是把节点的指针再次包装一下变成一个名字听起来很高端的新类型，比如就叫它指示器（Indicator）吧。这个指示器无非是把节点指针包装成一个新的结构类型，并且通过运算符重载让它支持后移 ``++`` 和解指针 ``*`` 两个运算，如果是双链表，那么还应该重载一下前移 ``--`` 运算。由于单链表没有尾指针，但是尾节点的后继指针一定为空指针，所以为了判断一个指示器是否已经沿着后继链走到了终点，需要判断它内部那个指针是不是变成了空指针。我们需要给指示器结构增加一个判断指针是否为 ``NULL`` 的成员函数，以便今后用来迭代遍历元素时可以判断是不是已经走到了底。

当然了，我们还要模仿STL容器那样，给 ``LinkedList`` 结构增加一个返回首元素指示器的成员函数。现在我们的 ``LinkedList`` 结构定义已经发展壮大到下面这样了：

.. literalinclude:: ../../codes/318_linkedlist.cpp
   :language: c++
   :lines: 3-38, 42-43, 55

.. note::

   1、符号 ``NULL`` 在以下这几个库中定义：\ ``cstddef, cstdio, cstdlib, cstring, ctime``\ ，如果程序中没有引入任何一个，那么就请用数字0来代替，或者至少引入其中一个，比如 ``cstddef``\ 。

   2、指示器结构重载的 ``++`` 运算符实现节点指针沿着后链移动到当前节点的后继，如果当前的节点指针就是 ``NULL``\ ，那么访问其后继就会出现空指针访问的错误，所以在移动的时候用一个三元运算来判断当前指针是不是为空，如果不空就将其改为自己的后继，否则继续为空指针 ``NULL`` 不变，这里注意指针为空判断表达式的书写方式。

   3、注意指示器结构重载的前置和后置两种 ``++`` 运算，回顾一下它们之间的相同点和不同点；注意其重载的解指针运算 ``*`` 是采用传引用的方式来返回节点中的元素的，不是传值，所以我们不光可以通过指示器获得元素值，而且可以直接修改它们！

   4、注意链表结构的构造函数，它会在构造新链表的时候就动态生成一个节点，并让头指针指向它，这个就是头部哑节点，头指针将永远指向它不变。

   5、注意链表结构的 ``begin()`` 函数，它生成一个临时的指示器并以传值的方式返回出来，其指向的是链表头指针所指向节点的后继节点，不是头指针所指向的节点！头指针所指向的是头部哑节点，它的后继才是真正的首元素节点。如果链表是空的，那么 ``begin()`` 返回的指示器内部会是一个空指针。

现在，外部使用者可以利用指示器来迭代访问我们这个单链表结构里的元素，假如已经有了一个单链表 ``LinkedList<int> lst``\ ，里面已经存有若干个整数元素，那么就可以像下面这样做：

.. code-block:: c++

   for (LinkedList<int>::Indicator id = lst.begin(); !id.end(); ++id)
           printf("%d\n", *id);
   
或者这样：

.. code-block:: c++

   LinkedList<int>::Indicator id = lst.begin();
   while (!id.end()) {
           *id += 1;
           id++;
   }

是不是很酷炫？看起来和STL容器迭代器的用法几乎是一样的。

但是还不够完美，因为现在我们还只能使用指示器来访问链表元素，指示器有时候写写比较麻烦，很多时候我们还是希望能够直接使用下标，像数组一样访问元素。所以接下来我们再重载一下 ``LinkedList`` 结构的下标运算 ``[]``\ 。方便起见，我们单独提供一个直接访问首元素的成员函数。另外为了便于编写循环条件，我们再模仿STL容器提供获取链表长度和判断链表是否为空的两个基本功能成员函数。下面给出相应的代码，为了减少篇幅，我们接下来只给出与成员函数相关的代码：

.. literalinclude:: ../../codes/318_linkedlist.cpp
   :language: c++
   :lines: 3, 4, 39-41, 44-46, 55-63

这两个函数的代码都比较简单，其中按下标访问的代码略长一些，所以没有写在结构内部，采用了声明与定义分开的方式。

.. warning::

   在下标运算符重载函数中，我们只是简单地从首元素节点开始，按照给出的下标值向后移动到指定下标处，由于下标从0开始编号，所以下标是多少就移动多少步。这里我们并没有考虑下标超限的问题，如果参数给出的下标值是超限的，那么一定会出现移动到空指针上的情况，也就是移动到了尾元素的后继指针上。然后要么在下一次移动时，要么在返回元素值时引发访问空指针的错误。

   对这样的错误，我们秉承C/C++语言一贯的风范，不予处理！是否会超限的问题留给外部使用者自己去考虑，这是程序员的事情，不是库设计者的事情。

现在我们可以完全像使用数组一样使用这个单链表里的元素了（记得数组下标超限问题也是程序员自己的问题哦），如果总是操作链表的首元素，那么也可以直接调用 ``front()`` 成员函数来获取首元素的引用。例如下面的样子：

.. code-block:: c++

   printf("%d\n", lst.front());
   lst.front() = 0;
   for (int i = 0; i < lst.size(); ++i)
         lst[i]++;

.. hint::

   在算法编程中，有大量仅在一个线性表的头部或尾部操作的场景，因此对于单链表，单独提供一个 ``front()`` 成员函数是很有必要的。

.. warning::

   虽然提供了按下标访问的功能，但是一定要知道，链表是不提倡按下标值随机访问元素的，这样做的效率非常低。如果可能的话，尽量使用指示器（简化版直接使用节点指针）或仅在一头进行操作。

**2、元素增删**


**3、新技能：析构函数**


双链表的实现
^^^^^^^^^^^^

(待续)

