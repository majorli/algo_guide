链表的C++实现
+++++++++++++

本节我们将使用C++语言实现单链表和双链表结构。作为数据结构这一领域的学习，我们将使用C++模板技术实现标准的链表ADT，可以接受任意类型的元素，具有以下标准功能：

1. 基本功能：

   1. 获取链表长度，即表中元素的数量；
   2. 判断链表是否为空；
   3. 清空链表。

2. 迭代访问：

   1. 获取链表首元素节点的指针，请注意是首元素的节点，不是头部的哑节点指针；
   2. 获取双链表的尾部指针，请注意是尾部的哑节点指针，不是尾元素的节点指针；
   3. 向后移动节点指针；
   4. 向前移动双链表节点指针。

3. 元素访问：

   1. 按照元素下标获取元素值；
   2. 根据节点指针获取元素值；
   3. 获取链表首元素；
   4. 获取双链表尾元素；
   5. 修改指定下标处的元素值；
   6. 修改给定节点（由指针给定）处的元素值。

4. 元素增删：

   1. 在链表头部插入新元素；
   2. 在双链表尾部添加新元素；
   3. 新元素插入为单链表给定节点（由指针给定）的后继；
   4. 新元素插入为双链表给定节点（由指针给定）的前驱，类似于顺序表中在指定元素位置处插入新元素；
   5. 删除链表首元素；
   6. 删除双链表的尾元素；
   7. 删除单链表给定节点（由指针给定）的后继；
   8. 删除双链表给定节点（由指针给定）本身。

以上是链表的常见标准功能，在学习数据结构时应全部予以掌握，在实际编程中可能会有所取舍或改变。本节详细介绍单链表的完整实现代码，双链表只给出部分代码，剩余部分将作为本节的练习。

.. attention::

   这一章是学习数据结构，在编写每一种数据结构的实现代码时我们都会用最接近面向对象的风格和工程编程的要求来编写一个比较完美的、甚至可以直接当做类库使用的抽象数据类型。这样的代码会比较繁琐，代码量大，在算法问题编程的时候如果要自己实现一些数据结构，不需要这样写，应该根据问题的要求，编写简化版的ADT，我们在这一章中的例题中会看到各种简化版代码。

单链表的实现
^^^^^^^^^^^^

**1、单链表的结构设计**

首先我们需要设计一个用来存放元素节点的结构，为了可以适用于任何类型的元素，这里要用模板结构。如同上一节所述，常见的写法如下：

.. code-block:: c++

   template<typename T>
   struct Node {
           T _value;            // 元素值
           Node<T> *_next;      // 后继链指针

           // 构造函数
           Node() { _next = NULL; }                             // 默认构造函数
           Node(const &T val) { _value = val; _next = NULL; }   // 指定元素值的构造器
   };

这样就可以了，我们在成员变量的名称前加上下划线 ``'_'`` 只是为了表示数据封装的惯例，提醒编程人员不要在外部程序中直接访问使用这些成员变量。比如像下面这样的传统写法，现代程序设计理念认为是恶劣的：

.. code-block:: c++

   Node<int> n1(10), n2(11);
   int v = n1._value;
   n1._next = &n2;
   n2._value = v - 1;

但是如果外部程序代码遵循数据封装的惯例，不直接访问成员变量，那么外部程序要怎么才能获得结构里的元素值和后继指针呢？最常规的做法是给结构添加\ :strong:`访问器函数`\ （accessor），像下面这样：

.. code-block:: c++

   template<typename T>
   struct Node {
           T _value;            // 元素值
           Node<T> *_next;      // 后继链指针

           // 构造函数
           Node() { _next = NULL; }                             // 默认构造函数
           Node(const &T val) { _value = val; _next = NULL; }   // 指定元素值的构造器
           // 访问器函数
           T &value() { return _value; }                        // 访问元素值
           Node<T> *next() { return _next; }                    // 返回后继指针
	   void set_next(Node<T> *next) { _next = next; }       // 设置后继指针
   };

这是数据封装原则下的常规写法。

元素值的访问器 ``value()`` 返回的是成员变量 ``_value`` 的引用，所以只要这一个访问器就能同时满足外部程序对元素值进行读写的功能要求，例如：

.. code-block:: c++

   Node<int> n(2);      // 创建一个元素值为2的节点
   int v = n.value();   // 读取元素值
   n.value()--;         // 元素值减一
   n.value() = 3 * 3;   // 设置元素值

后继指针是一个指针类型，不能返回引用，所以需要有一读一写两个访问器，可以这样使用：

.. code-block:: c++

   Node<int> n1(1), n2(2), n3(3);
   n1.set_next(&n2);            // n1的后继设置为n2
   n3.set_next(n1.next());      // n3的后继设置为n1的后继

通常，这样写就很好了，大多数数据结构教程上就是这么写的。但是我们不打算采用这种看上去像Java风格的方式，我们可以做得更酷炫，具体怎么做过一会儿再讲。

.. hint::

   算法问题编程时甚至往往会直接访问成员变量，连访问器都不用。如果那样的话，成员变量就不要用 ``'_'`` 来开头了，写写都挺麻烦的。


双链表的实现
^^^^^^^^^^^^

(待续)

