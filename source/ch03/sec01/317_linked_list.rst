线性表的链式存储结构：链表
++++++++++++++++++++++++++

链表的概念
^^^^^^^^^^

:strong:`链表`\ 采用链式存储结构来实现线性表。既然是线性表，那么元素在逻辑关系上一定是一个接着一个连成一串的，用精确的定义语言来描述就是：每一个元素都至多有一个唯一确定的前驱，也至多有一个唯一确定的后继。但是和顺序表不同，链表中的元素在实际的物理存储上并不要求严格地一个紧接着一个的顺序排放。链表可以在内存中任意的位置存放其中的元素，只要找到一块可以存放元素的内存空间即可。为了维持元素之间逻辑上的前驱后继关系，链表为每一个元素节点增设表示元素间前后关系的\ :strong:`链`\ 字段，指向前驱元素的链称作\ :strong:`前链`\ 或\ :strong:`前向链`\ ，指向后继元素的链称作\ :strong:`后链`\ 或\ :strong:`后向链`\ 。

.. tip::

   通常在C++语言中，链就是指向另一个元素节点的指针。

如果链表中的每一个元素节点都只有一个后链，那么这样的链表叫做\ :strong:`单链表`\ 。如果每一个元素节点同时有一个后链和一个前链，那么称为\ :strong:`双链表`\ 或\ :strong:`双向链表`\ 。

例如整数序列[1,2,3]，如果用链表来存储，那么三个元素在物理内存中各自可能存放在任意的位置中，但是相互之间用链来维持前后关系，如下图所示：

.. image:: ../../images/317_linkedlist_mem.png

其中红色的箭头线表示后链指针，蓝色的表示前链指针。但是这样的示意图看起来非常不舒服，一般我们把链表的示意图画成下面这样更为抽象但是更简洁易懂的方式：

.. image:: ../../images/317_linkedlist.png

这样，在一个链表的元素节点中，包含一个存放实际元素值的变量和一到两个存放链的指针变量。在用C++语言实现链表的时候，一般总是用一个结构来定义链表节点。如果链表元素的类型是C++内置数据类型，例如 ``int``\ ，最简单的单链表节点可以这样定义：

.. code-block:: c++

   struct Node {
           int value;   // 元素值
           Node *next;  // 后链指针

           Node(int val = 0) { value = val; next = NULL; } // 构造函数
   };

如果希望将链表实现为一个抽象数据类型（ADT），支持任何数据类型，那么可以将节点定义为模板结构，比如下面这个双向链表节点：

.. code-block:: c++

   template <typename T>
   struct Node {
           T value;     // 元素值
           Node *next;  // 后链指针
           Node *prev;  // 前链指针

           Node() { next = NULL; prev = NULL; }      // 默认构造函数
           Node(const T &val) { value = val; next = NULL; prev = NULL; }  // 指定元素值的构造函数
   };




链表的操作
^^^^^^^^^^


