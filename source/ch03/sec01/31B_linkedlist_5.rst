STL双链表容器list
++++++++++++++++++++++

``list`` 是STL容器的一种，它是一个双向链表，要使用 ``list`` 容器需要先引入 ``list`` 库，并使用 ``std`` 命名空间。

``list`` 容器同样是一个线性表类型的容器，所以很多用法和规则都和 ``vector`` 容器类似，也使用左闭右开的规则定义其中的元素范围。下表列出了和 ``vector`` 容器相同的一些常用成员函数和运算：

+--------------------+-----------------------------------------------------------+
| 成员函数           | 功能                                                      |
+====================+===========================================================+
| 构造器             | 构造一个 ``list`` 容器的变量（对象）                      |
+--------------------+-----------------------------------------------------------+
| ``operator=``      | ``list`` 变量之间的相互赋值                               |
+--------------------+-----------------------------------------------------------+
| ``begin()``        | 获取头部迭代器，指向首元素                                |
+--------------------+-----------------------------------------------------------+
| ``end()``          | 获取尾部迭代器，指向尾元素的后一个位置                    |
+--------------------+-----------------------------------------------------------+
| ``empty()``        | 判断 ``list`` 是否为空                                    |
+--------------------+-----------------------------------------------------------+
| ``size()``         | 获取 ``list`` 的长度                                      |
+--------------------+-----------------------------------------------------------+
| ``front()``        | 获取首元素的引用                                          |
+--------------------+-----------------------------------------------------------+
| ``back()``         | 获取尾元素的引用                                          |
+--------------------+-----------------------------------------------------------+
| ``push_back()``    | 在尾部添加一个元素                                        |
+--------------------+-----------------------------------------------------------+
| ``pop_back()``     | 删除尾部元素                                              |
+--------------------+-----------------------------------------------------------+
| ``insert()``       | 使用迭代器指定位置插入元素                                |
+--------------------+-----------------------------------------------------------+
| ``erase()``        | 使用迭代器指定位置删除元素                                |
+--------------------+-----------------------------------------------------------+
| ``swap()``         | 和另一个 ``list`` 交换内容                                |
+--------------------+-----------------------------------------------------------+
| ``clear()``        | 清空所有元素                                              |
+--------------------+-----------------------------------------------------------+
| ``assign()``       | 批量赋值，可使用迭代器指定赋值范围                        |
+--------------------+-----------------------------------------------------------+
| 比较运算           | 按字典序比较两个 ``list`` 大小的六种比较运算              |
+--------------------+-----------------------------------------------------------+
| ``swap(x, y)``     | 非成员函数版交换两个 ``list`` 的内容                      |
+--------------------+-----------------------------------------------------------+

上表所列的函数和运算符的用法和 ``vector`` 完全相同，所以不再一一举例细说，有不清楚的可以回到 :ref:`ref_311_vector` 一节回顾一下。接下来重点讲一讲和 ``vector`` 容器不同的地方和 ``list`` 特有的几种用法。

首先，和 ``vector`` 容器最大的不同在于 ``list`` 容器不支持使用下标访问元素。如果我们有一个 ``list`` 容器的变量 ``a``\ ，我们不能使用 ``a[i]`` 这样的方式通过一个整数下标值 ``i`` 来访问 ``a`` 中的元素。这是因为通过下标值随机访问链表元素是低效操作，是不鼓励的，所以STL库干脆就不提供这种操作。

但是 ``list`` 提供了在表头处插入删除元素的功能，这是 ``vector`` 所不具备的，因为在顺序表的表头处增删元素也属于低效操作，是不被鼓励使用的。

**表头增删元素**

.. code-block:: c++

   void push_front (const value_type& val); // 在表头处增加元素，元素值为val
   void pop_front();                        // 删除表头元素

这两个函数的用法和在表尾增删元素的 ``push_back()``\ 、\ ``pop_back()`` 两个函数完全相同，只是操作位置在表头处而已，插入和删除的都是首元素。

除此之外，\ ``list`` 还提供了以下一些自己特有的成员函数，都非常实用。

**切片转移**

成员函数 ``splice()`` 可以用来将另一个 ``list`` 中的全部或一段元素切片出来并插入到自己一个由迭代器指定的位置处，即插入到该迭代器所指向的元素之前，转入完成之后，另一个 ``list`` 中被切片出来的元素会被从表中删除，所以这个操作叫做切片和转移。

``splice()`` 函数有三个重载版本：

.. code-block:: c++

   void splice(iterator position, list& x); // 整表转入
   void splice(iterator position, list& x, iterator i); // 单个元素转入
   void splice(iterator position, list& x, iterator first, iterator last); // 指定范围转入

