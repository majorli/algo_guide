高精度整数算法(II) 加法与乘法
++++++++++++++++++++++++++++++++++++++++++

我们已经有了高精度整数所需要的最基本框架，即实现了它的数据存储结构、赋值和输入输出功能。接下来我们就要逐步实现 ``BigInt`` 类型的常用运算了，首先来看最常用也是相对较简单的加法和乘法运算。

实现加法和乘法运算的基本思路是模拟竖式运算的手算过程。在我们的实现版本里，采用的是模拟万进制，每一个节可以看作是万进制整数的一个位。仿照小学阶段学过的竖式加法和乘法运算规则，从最低位对齐后进行运算。


BigInt加法运算
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

十进制下正整数加法的竖式运算规则是最简单的，两个加数最低位对齐，然后开始由低位向高位逐位做加法。每个位上由两个加数该位上的数字以及从低位进位来的数字三者相加，相加之和取其个位数作为该位的结果，如果超过10，则向更高一位进1。最终得到的和的长度可能和两个加数中较大的那个相同，或者多一位。

``BigInt`` 的万进制正整数加法和上面所描述的十进制情况并没有本质的区别，只是“位”变成了“节”，每个节上相加之和保留低四位，也就是除一万（基）的余数，进位则是最高位，也就是除一万的商，同样进位数最大只可能为一。

要模拟上面这样一个过程并不难。我们在设计 ``BigInt`` 的数据结构时使用了“小端序”存放各节，所以低位对齐是一件自然已经做好的事情，只要将两个加数各自从头到尾的各节相加，取结果，生成进位就可以了。两个加数的节数不同时，较短的那个加数高位上缺失的节视为0。

例如计算 ``99998765432101234567 + 9999123456789012`` 的过程如下：

.. code-block:: none

        9999|8765|4321|0123|4567
  +)         9999|1234|5678|9012
  ------------------------------
      1|0000|8764|5555|5802|3579

下面我们来具体实现加法运算。为了全面地展示怎样实现一个比较完整的数据类型，我们将重载所有的四种加法运算：``+, +=, 前置++, 后置++``。实际解决问题的编程中往往只需其中一种就够了。

既然我们要同时实现 ``+`` 和 ``+=`` 两种运算，那么按照代码复用的原则，我们可以只对其中一个编写真正的运算程序，而另一个则利用它来完成自己的功能。

``+`` 和 ``+=`` 两个运算符重载的成员函数原型为：

.. code-block:: c++

   struct BigInt {
           // ...
           BigInt &operator+=(const BigInt &a);
           BigInt operator+(const BigInt &a) const;
           // ...
   }

二者的共同点是都只接受一个常量引用参数 ``const BigInt &a``，它就是要和自己相加的那个加数。采用常引用确保了这个参数不光可以是 ``BigInt`` 变量，而且可以是任何能被 ``unsigned long long`` 兼容的内置整型变量、常量和字面量。这是因为C++对于常引用形参会在类型不匹配时自动尝试去做类型转换，而我们的 ``BigInt`` 恰好有一个能接受这种类型的构造器，所以C++能够把这些值默默地转为一个 ``BigInt`` 变量再传给形参。

.. attention::

   聪明如你，读到这里可能会认为既然这样，那么重载过加法运算符之后我们的 ``BigInt`` 是不是不光能和内置整型数做加法，而且还能和字符串做加法呢？毕竟我们还有一个接受 ``string`` 型参数的构造器。很遗憾，答案是否定的。前一节我们已经看到过了 ``BigInt b = "888";`` 这样的操作会被C++拒绝，理由是不支持这样的类型转换。这里也一样，``b + "888"`` 这样的操作也会被C++以相同的理由拒绝。这是因为字符串本身也是一种派生数据类型，而那种默默完成的隐式类型转换只支持内置数据类型。

再看二者的不同点。第一个不同点是 ``+`` 运算符重载的成员函数在函数原型后面有一个 ``const`` 的修饰。被这样修饰过的成员函数叫做\ :strong:`常成员函数`。这是成员函数才有的特性，普通的函数是没有这种操作的。常成员函数不允许修改成员变量的值，在常成员函数内部，C++会自动把所有成员变量改成常量。而我们知道，单纯的加法运算 ``b1 + b2`` 就是不允许修改加数本身的值的。

第二个不同点是 ``+=`` 运算返回一个引用，而 ``+`` 运算则是返回一个值。这是因为单纯的加法运算不在任何一个加数上进行运算，它一定是生成一个临时的 ``BigInt`` 变量来存放运算结果。而临时变量是不可以用引用来返回的，必须返回它的值。``+=`` 运算就不同了，它简单地把参数 ``a`` 加到自己身上，然后以引用方式返回 ``*this`` 就可以了。所以 ``+=`` 运算会比 ``+`` 运算高效一些，因为它的参数和返回值都是引用形式，不会产生数据复制。

那么如果用 ``+=`` 来实现具体的加法运算，然后用它来完成 ``+`` 的功能，这样会不会比反过来做更加高效呢？其实两种方式是一样的。我们来对比一下就知道了：

1. ``+`` 调用 ``+=`` 时，首先要把自己的值复制一个备份出来，然后用这个备份去调用 ``+=``，完成之后再以复制值的方式返回结果，总共做了两次数据复制。
2. ``+=`` 调用 ``+`` 时，普通加法运算结束后以复制值的方式返回结果，然后这个结果要复制给 ``*this``，一样是总共两次数据复制。

所以对于加法运算，这种谁复用谁的选择是没有太大意义的，个人喜好而已。真正的加法运算过程都是一样的。我们这里选择用 ``+=`` 来做真正的加法运算，然后 ``+`` 运算利用 ``+=`` 运算来完成。下面是




BigInt乘法运算
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

模拟竖式整数乘法时，同样先低位对齐，然后从乘数的最低节开始逐节与另一个乘数整体相乘，每次得到的部分积右移相应的节数后加到前一次得到的部分结果上去。

由于我们选择了模拟万进制，所以模拟乘法时会有一个非常好用的便利。节与节相乘不需要引入 ``long long`` 型的中间变量，节与节的乘积不会造成 ``int`` 溢出。结果对万取模就是该节的积，除万后剩余部分就是进位。例如，两个节都是最大值的情形，计算 :math:`9999\times9999=99980001`，所以两节相乘的结果记 :math:`1` 进 :math:`9998`。





（待续）