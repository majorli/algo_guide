高精度整数算法(II) 加法与乘法
++++++++++++++++++++++++++++++++++++++++++

我们已经有了高精度整数所需要的最基本框架，即实现了它的数据存储结构、赋值和输入输出功能。接下来我们就要逐步实现 ``BigInt`` 类型的常用运算了，首先来看最常用也是相对较简单的加法和乘法运算。

实现加法和乘法运算的基本思路是模拟竖式运算的手算过程。在我们的实现版本里，采用的是模拟万进制，每一个节可以看作是万进制整数的一个位。仿照小学阶段学过的竖式加法和乘法运算规则，从最低位对齐后进行运算。


BigInt加法运算
^^^^^^^^^^^^^^^^^^^^^^^^^^^^




BigInt乘法运算
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

一般的高精度整数乘法也是模拟竖式手算。低位（节）对齐后，从乘数的最低节开始逐节与另一个乘数整体相乘，每次得到的部分积右移相应的节数后加到前一次得到的部分结果上去。所以 ``BigInt`` 乘法运算要基于其加法运算，并用到 ``int`` 乘法。

乘法运算另有一种思路是用不断翻倍的加法去组合，例如 :math:`a\times 15` 就可以分解成 :math:`a+2a+4a+8a`。这样的话就可以分解成对乘数 :math:`a` 进行3次翻倍，然后再进行3次加法。其中翻倍也可以通过加法来实现。这样就避免了在乘法运算过程中使用速度比较慢的 ``int`` 乘法，而是全部采用速度最快的 ``int`` 加法。这个思路有点类似快速幂，请仔细思考一下，它是和其中一个乘数的二进制表示有密切关系的。

假设一个乘数的二进制位数为 :math:`n`，以 ``BigInt`` 加法为基本运算单位，那么这种方法是 :math:`O(2\log n)` 时间的。用普通的模拟竖式乘法，则需要各 :math:`\log n` 次 ``BigInt`` 加法和 ``BigInt`` 与 ``int`` 的乘法，相比会略微慢一点。

但是翻倍相加的方法有一个非常大的缺陷，那就是太消耗内存，需要在内存中保存所有 :math:`n` 次翻倍的结果，即 :math:`[a,2a,4a,\dots,2^{n-1}a]`，共计 :math:`n` 个 ``BigInt`` 型临时变量。这样的内存开销怕是太大了，特别是当数据的值非常大时（毕竟需要动用高精算法的场景一定是数值及其巨大的），所以大多数情况下还是使用模拟竖式乘法的方法来进行计算。我们这里也选择使用通常的模拟法来完成 ``BigInt`` 的乘法运算。

由于我们选择了模拟万进制，所以模拟乘法时会有一个非常好用的便利。节与节相乘不需要引入 ``long long`` 型的中间变量，节与节的乘积不会造成 ``int`` 溢出。结果对万取模就是该节的积，除万后剩余部分就是进位。例如，两个节都是最大值的情形，计算 :math:`9999\times9999=99980001`，所以两节相乘的结果记 :math:`1` 进 :math:`9998`。





（待续）