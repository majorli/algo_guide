高精度整数算法(II) 加法与乘法
++++++++++++++++++++++++++++++++++++++++++

我们已经有了高精度整数所需要的最基本框架，即实现了它的数据存储结构、赋值和输入输出功能。接下来我们就要逐步实现 ``BigInt`` 类型的常用运算了，首先来看最常用也是相对较简单的加法和乘法运算。

实现加法和乘法运算的基本思路是模拟竖式运算的手算过程。在我们的实现版本里，采用的是模拟万进制，每一个节可以看作是万进制整数的一个位。仿照小学阶段学过的竖式加法和乘法运算规则，从最低位对齐后进行运算。

.. attention::

   按照C++的规则，通常的 ``+, -, *, \, %`` 运算不改变操作数的值，运算时新生成一个临时的 ``BigInt`` 变量用来放置运算结果并返回它的值。返回临时变量是不可以返回其引用的，只能返回其值，所以返回过程会进行数据复制。而 ``BigInt`` 变量很可能是有很大的数据量的，所以复制过程会影响运行效率。但是 ``+=, -=, *=, \=, %=, ++, --`` 这些运算是直接修改操作数本身的值的，返回时不需要使用临时变量，可以返回引用。这就避免了复制数据，效率会比较高。因此在实际编程时应该关注是否可以只用这类运算符而不用普通运算符。


BigInt加法运算
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

十进制下正整数加法的竖式运算规则是最简单的，两个加数最低位对齐，然后开始由低位向高位逐位做加法。每个位上由两个加数该位上的数字以及从低位进位来的数字三者相加，相加之和取其个位数作为该位的结果，如果超过10，则向更高一位进1。最终得到的和的长度可能和两个加数中较大的那个相同，或者多一位。

``BigInt`` 的万进制正整数加法和上面所描述的十进制情况并没有本质的区别，只是“位”变成了“节”，每个节上相加之和保留低四位，也就是除一万（基）的余数，进位则是最高位，也就是除一万的商，同样进位数最大只可能为一。

要模拟上面这样一个过程并不难。我们在设计 ``BigInt`` 的数据结构时使用了“小端序”存放各节，所以低位对齐是一件自然已经做好的事情，只要将两个加数各自从头到尾的各节相加，取结果，生成进位就可以了。两个加数的节数不同时，较短的那个加数高位上缺失的节视为0。

例如计算 ``99998765432101234567 + 9999123456789012`` 的过程如下：

.. code-block:: none

        9999|8765|4321|0123|4567
  +)         9999|1234|5678|9012
  ------------------------------
      1|0000|8764|5555|5802|3579

下面我们来具体实现加法运算。为了全面地展示怎样实现一个比较完整的数据类型，我们将重载所有的四种加法运算：``+, +=, 前置++, 后置++``。实际解决问题的编程中往往只需其中一种就够了。

正如前面所说的，为了提高效率并充分利用代码的可复用性，我们将单独实现一个内部函数 ``BigInt &_add(BigInt &b1, const BigInt &b2);``，用来将后一个参数加到前一个参数上，并返回前一个参数的引用。这样一个函数无论在传参还是在返回的时候都采用引用形式，不会复制数据，所以调用效率是非常高的。我们可以发现，复用这样一个函数可以轻易地完成所有四种加法运算。




BigInt乘法运算
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

模拟竖式整数乘法时，同样先低位对齐，然后从乘数的最低节开始逐节与另一个乘数整体相乘，每次得到的部分积右移相应的节数后加到前一次得到的部分结果上去。

由于我们选择了模拟万进制，所以模拟乘法时会有一个非常好用的便利。节与节相乘不需要引入 ``long long`` 型的中间变量，节与节的乘积不会造成 ``int`` 溢出。结果对万取模就是该节的积，除万后剩余部分就是进位。例如，两个节都是最大值的情形，计算 :math:`9999\times9999=99980001`，所以两节相乘的结果记 :math:`1` 进 :math:`9998`。





（待续）