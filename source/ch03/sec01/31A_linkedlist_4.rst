链表的应用（续）
++++++++++++++++

链表的优势在于快速地插入和删除元素，它不光能在链上任意一个环节处以常数时间插入或删除单个元素节点，而且能以同样的常数时间插入或删除整段元素，因此非常适合多个链表之间的分段合并、拼接等操作。

两个有序单链表的归并
^^^^^^^^^^^^^^^^^^^^

前一节说过，链表天生不适合归并排序。但是链表非常适合两个有序表的归并操作，虽然时间复杂度仍然为 :math:`O(n)`\ ，但是实际运行的速度要比顺序表归并快许多。而且和顺序表归并不同，链表可以直接将一个表归并入另一个表，也就是可以实现原地归并，不需要另外开辟一张临时表。这都得益于链表方便的成段拼接能力。

下面仍然以单链表为例，介绍如何实现两个有序单链表的归并。设有两个有序整数序列 :math:`A,B` 保存在两个单链表中，现在要将 :math:`B` 中的所有元素归并入 :math:`A`\ ，并且我们要求在归并时若遇到值相等的元素，\ :math:`B` 中的元素一律归并在 :math:`A` 中所有等值元素的后面。

我们先考虑对于表 :math:`B` 的第一个元素 :math:`b_0`\ ，显然它要归并入表 :math:`A` 中所有小于等于它的元素之后，第一个大于它的元素之前。因此我们第一步要在表 :math:`A` 中寻找第一个大于 :math:`b_0` 的元素 :math:`a_i`\ ，从而就确定了归并后元素 :math:`b_0` 的前驱 :math:`a_{i-1}`\ 。

链表归并时要充分利用其可以整段插入的优势，而不是像顺序表归并时那样一个元素一个元素地搬。现在既然已经知道了 :math:`b_0` 的插入点为 :math:`a_{i-1}` 的后继，那么实际上它后面的所有小于 :math:`a_i` 的节点都应该插入在 :math:`a_i` 之前。因此接下来我们从 :math:`b_0` 出发沿着表 :math:`B` 向后寻找所有小于 :math:`a_0` 的节点，直到第一个大于等于 :math:`a_i` 的元素 :math:`b_j`\ 。那么整个 :math:`b_0` 到 :math:`b_{j-1}` 这一段就是这一次归并要整体搬入表 :math:`A` 中 :math:`a_{i-1}` 和 :math:`a_i` 之间的一段。如下图所示：

.. image:: ../../images/31A_linkedlist_merge_1.png

上图所展示的是一般的情况，这里还有两种特殊情况需要考虑：

1. 如果 :math:`A` 的长度为0或者在寻找 :math:`a_i` 的过程中一直找到 :math:`A` 表末尾都没有找到大于 :math:`b_0` 的元素，那么实际上整个表 :math:`B` 就应该完整地挂接到表 :math:`A` 的最后，这时候就不需要去寻找 :math:`b_j` 了。
2. 如果 :math:`B` 的长度为0或者在寻找 :math:`b_j` 的过程中一直找到 :math:`B` 表末尾都没有找到大于等于 :math:`a_i` 的元素，那么整个表 :math:`B` 都应该完整地插入到 :math:`a_{i-1}` 之后。

上述两种特殊情况在编程时的处理和一般情况是完全一致的，所以下面我们不单独给出它们的示意图。归并之后的情形如下图所示：

.. image:: ../../images/31A_linkedlist_merge_2.png

在完成一段归并之后，表 :math:`B` 的首元素实际上已经变成了 :math:`b_j`\ ，而它的插入位置一定是在 :math:`a_i` 之后。所以我们下一次要寻找从 :math:`b_j` 开始的某些元素归并入表 :math:`A` 的位置时，应该从 :math:`a_i` 的后继开始查找。我们只要在开始下一段归并之前，把表 :math:`A` 的查找位置调整为从 :math:`a_i` 的后继开始，就可以使得每一段归并的处理方法变得完全一致。

因此我们在表 :math:`A` 中应该保留一个查找起点指针 ``i``\ ，初始时让它指向表 :math:`A` 的头部哑节点 ``head_a``\ ，每一次查找到 :math:`a_i \gt b_0` 的时候，\ ``i`` 应该指向 :math:`a_{i-1}`\ 。每一次完成一段归并之后如果 :math:`b_j` 的后继不是空那么就应该将 ``i`` 改为指向它，事实上它就是 :math:`a_i`\ ，也就是下一段归并的查找起点。而查找 :math:`b_j \ge a_i` 的查找起点都是从表 :math:`B` 的头部哑节点 ``head_b`` 开始。

某一次归并时如果发生前面所述的两种特殊情况之一的，实际上整个归并过程就已经全部完成了，此时表 :math:`B` 一定已经空了，所以整个过程的结束条件是 ``head_b->next == NULL``\ 。下面是两个有序整数单链表归并的程序代码：

.. literalinclude:: ../../codes/31A_merge_ll.cpp
   :language: c++
   :emphasize-lines: 67-84

.. admonition:: 练习

   编写一个生成随机测试数据的程序。输入两个整数 :math:`m \ge 0,n \ge 0`\ 。输出最多三行：第一行两个整数 :math:`m,n`，中间用一个空格隔开；第二行为 :math:`m` 个10000以内的随机自然数，用一个空格隔开，按升序排列，如果 :math:`m=0` 就跳过此行；第三行为 :math:`n` 个10000以内的随机自然数，用一个空格隔开，按升序排列，如果 :math:`n=0` 就跳过此行。

   用这个工具程序生成测试数据，测试上面的有序单链表归并程序。特别注意观察如果有表为空的情况程序运行是否正确。


单链表实现基数排序
^^^^^^^^^^^^^^^^^^

