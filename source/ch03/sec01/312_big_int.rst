高精度整数算法(I) 数据的表示
++++++++++++++++++++++++++++++++++++++++++

我们在数值算法的编程中，常常会遇到C++内置的整型数据类型可以表示的数值大小范围有限不够用导致的\ :strong:`溢出`\ 问题，:strong:`高精度整数算法`\ 就是用来解决这个问题的。我们可以利用C++的基础整数类型来拼接构造出一个理论上能达到无限位的超大整数数据类型，并且自己编程模拟手算过程来实现它的四则运算等数值计算，这就是\ :strong:`高精度整数算法`，简称\ :strong:`高精度算法`。

要实现一种完美的高精度整型及其运算不是一件容易的事情。一般来说，我们会定义一个结构体作为它的数据存储（在大型项目开发的实际工程编程中往往是用类而不是结构，但在算法编程中一般就用struct简化了），然后我们要给这个结构添加必要的成员函数来实现运算能力，最常见的有加减乘除、比较和赋值，另外还有一些辅助功能，比如初始化、输入输出（支持 ``cin`` 和 ``cout``），更加完善的还可以让它支持取模、运算赋值 ``+=,-=,*=,/=,%=``、自增减 ``++,--``、移位 ``<<,>>,<<=,>>=``、按位逻辑运算等等。这里有一些操作的实现是相当复杂的，比如除法和取模，有些运算则一般在具体的问题中用不着，甚至有一些在算法编程领域基本上不会用到。所以，除非你是在从事大型工程软件开发，需要实现一个完美的高精度整型数类，或者最近实在闲着无聊想找点事情挑战一下自己，否则一般我们不会去完全实现这些功能。

在算法编程中，最最常见的用到高精度算法的情形有以下几个要求：

1. 实现一个理论上数值范围无限大的整型数据类型；
2. 通常不要求支持负数；
3. 实现加减乘除四则运算和相互比较大小，若为非负型，则减法通常用不着或者弱化为取绝对值的求差运算；
4. 要求能够用C++内置整型数、字面量进行初始化和赋值。

有时候，为了编程时更加方便，还可以适当增加以下辅助功能：

1. 能够用 ``cin >>`` 进行输入，用 ``cout <<`` 进行输出；
2. 能够用字符串对象、C字符串、字符串字面量进行初始化和赋值；
3. 支持和C++内置整型数之间的加减乘除运算和相互比较大小；
4. 支持 ``+=, *=, ++, --`` 运算；
5. 声明变量但没有初始化时能自动初始化为0。

从这一节起我们将逐步实现符合上述要求的一个非负高精度整数算法（BigInt）。掌握了这些常用功能的实现之后，其他不常见的功能实现起来也应该不难了。最后我们会使用它来完成一个实际的算法编程题。


BigInt数据结构
^^^^^^^^^^^^^^

**原理**

为了实现高精度整型数，我们的基本思路很简单，用现有的C++基本整数类型构造一个顺序表来拼接出超大整型数。具体要怎样构造呢？

一个朴素的思路是这样的，既然我们的目标是无符号整数，那么何不用最大的基本类型 ``unsigned long long`` 来进行拼接呢？一个 ``unsigned long long`` 最大可以表示 :math:`2^{64}-1`，所以两个拼接就能使上限达到 :math:`2^{128}-1`，:math:`n` 个 ``unsigned long long`` 就可以拼接成一个 :math:`64n` 位的无符号二进制整数，最大可以表示十进制数 :math:`2^{64n}-1`。

事实上这种朴素的思路是汇编语言实现高精度整数的标准思路，但是并不适合C++语言。原因是这样的表示方法是基于二进制的，在进行运算时需要直接进行二进制运算。二进制运算是汇编语言的拿手好戏，但C++毕竟是一种高级语言，它并不提供完备的二进制运算能力，C++的数值运算是十进制的。所以我们要基于十进制来进行拼接，这里涉及到好几个技术细节问题需要逐一确定。

问题一，用哪一种基本数据类型来作为拼接单位？答案当然是 ``int``，因为C++标准规定，所有计算机系统上的所有C++版本，必须确保 ``int`` 是运算速度最快的数据类型！有人可能会问，既然我们的目标类型是非负的，那么为什么不用 ``unsigned int`` 呢？那是因为在做减法的时候，对位相减可能会出现负数需要借位，而 ``unsigned int`` 无法表示负数，导致用它来构造会很难实现减法运算。事实上，所有 ``unsigned`` 整型都不适合用来构造高精度整数。

问题二，采用多大的进制？用于拼接的每一个 ``int`` 数相当于整个 ``BigInt`` 数的一个数位，不妨把它叫做一个“:strong:`节`”吧（这是我自己给它取的名字，以避免和十进制的数位产生混淆，并不是标准的名称）。前面已经说过了拼接要基于十进制，即 ``BigInt`` 在内部要看成是 :math:`10^n` 进制的数，一个节的取值范围相应就是 :math:`0` 到 :math:`10^n-1`，对应十进制数的 :math:`n` 个数位。所以 :math:`n` 要取多大合适呢？由于 ``int`` 最大可表示的正数大约为21亿左右，所以理论上最大可以支持到 :math:`10^9`，即十亿进制。实践中常见的有采用亿进制的，也有采用万进制的。

在这里，我们选用我喜欢的万进制。为什么？明明一个 ``int`` 最大可以表示到十亿的数量级，但我们要让一个节限制在一万以内，即0到9999呢？这是极大的存储资源浪费！理由还是因为算法编程的特性。算法编程首先考虑的是程序编写正确，然后是运行速度够快，而存储空间往往可以用来大把大把地挥霍以换取便捷性和高速性。所以我们有两个理由来支持万进制：

1. 模拟乘法运算，基本操作是节与节之间的整数乘法，采用万进制，结果最大为 :math:`9999\times9999`，这个结果恰好还在 ``int`` 的可表示范围之内。所以 ``BigInt`` 乘法运算时，可以直接在节上进行运算，无需引入 ``long long`` 型的中间变量，大大简化乘法运算的代码。这是编程便捷性、减少错误点的理由。
2. 类似地，所有加减乘除运算都可以直接在节上采用 ``int`` 型运算完成，无需引入中间变量，能够提高运算速度，尤其是乘除法这样的复杂运算。这是提高速度的理由。

这就是我们建议在算法编程时采用万进制节来构造高精度的理由。而大型软件开发的工程编程时往往会更优先考虑空间消耗，故常选用亿进制。

通常，我们把进制数称为\ :strong:`基`\ （Base），例如十进制的基就是10，2进制的基就是2，所以 ``BigInt`` 的基等于10000。每一个节所表示的十进制位数我们习惯上称之为\ :strong:`宽`\ （Width），这里 ``BigInt`` 的宽是4，一个节对应4位十进制数位。所以万进制的 ``BigInt`` 数和通常的十进制数是可以对位划分节的（就好像2进制和16进制一样）。

例如：十进制数 ``1234567890987654321``，总共19位。用 ``BigInt`` 型表示它，可以从个位开始每4位划分为1节，总共分为5节，表示成 ``|123|4567|8909|8765|4321|``，其数值为 :math:`4321\times b^0+8765\times b^1+8909\times b^2+4567\times b^3+123\times b^4`，其中 :math:`b=10000`，就是基。

问题三，具体用什么数据结构拼接？怎么拼接？从前面的表示形式就可以看出，最合适的数据结构是顺序表，具体实现时使用 ``vector<int>`` 是最常见的。但是怎么拼接确是有一定技巧性的。熟悉汇编语言的人会知道，以Intel的x86架构为代表的现代计算机系统里，整数在内存中存放时通常都采用一种叫做\ :strong:`小端序`\ （Little-Endian）的存放方式，即所谓的“低位在前、高位在后”。例如一个两字节的数 ``1234``，存放在内存里的时候会是 ``3412``。为什么会这样？因为加减法和乘法运算都需要两个运算数低位对齐！虽然除法运算从最高位对齐开始，但是整数除法往往不采用直接模拟竖式手工除法运算的方法，而且往往可以用乘法来代替。所以，为了更方便地实现不同长度整数之间的算术运算，小端序是现代更流行的整数存储方式。

.. admonition:: 补充

   整数存放于内存时，为了计算方便，常采用小端序。但在网络传输时，没有了计算了需求，所以常采用大端序，以人们习惯的高位在前的方式进行传输，同时也便于接收一方查看。毕竟人眼看数，还是习惯先看高位。

鉴于以上原因，我们的 ``BigInt`` 在拼接时也采用小端序！即低位节在前，高位节在后。例如上面所说的那个数 ``1234567890987654321``，用 ``BigInt`` 表示时，在其内部的顺序表中存放的情形将是：``{ 4321, 8765, 8909, 4567, 123 }``。看起来挺诡异，但是到编写算术运算代码时就会发现它的好处了。

**基本结构**

下面我们就可以写出最基础的结构体定义了。

.. literalinclude:: ../../codes/312_bigint.cpp
   :language: c++
   :lines: 6-12







（待续）
