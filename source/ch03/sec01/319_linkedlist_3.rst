链表的应用
++++++++++

由于链表特殊的存储结构，在某些应用场景会比使用顺序表更为方便高效，有些场景甚至会不得不使用链表。尤其是某些比较古老的编程语言，比如C语言，它们没有 ``vector`` 之类的可变长度顺序表可以使用，如果需要用到长度总是在变化的序列时，往往就只能使用链表来实现了。

本节我们看几个基于链表的简单应用，感受一下链式存储结构给某些算法场景带来的影响。本节的例题在编程时不使用上一节学习的那种完善的链表结构，而是按照算法编程的特点，根据题目的要求以 :emphasis:`够用就行` 的原则因地制宜予以简化。

单链表上的插入排序
^^^^^^^^^^^^^^^^^^

前面我们学过了插入排序，已经知道了插入排序的时间复杂度为 :math:`O(n^2)`\ 。哪怕是经过优化的二分插入排序，虽然插入点查找的过程能达到 :math:`O(\log n)`\ ，但是随后在顺序表中的插入仍然是一个 :math:`O(n)` 时间的操作，所以总体的时间复杂度还是二阶的，尽管实际应用上在元素数量不多时能够接近 :math:`O(n\log n)`\ 。

那么如果是在链表上进行插入排序，情况会不会不同呢？当然了，插入元素这一步操作现在从 :math:`O(n)` 直降为 :math:`O(1)` 了，关键看查找插入点的过程。如果仍然采用顺序查找，那么还是 :math:`O(n)` 时间，和使用顺序表的时候一模一样。综合起来看，查找过程的时间复杂度没有变化，插入过程大幅降低为常数时间。所以总体时间复杂度虽然还是 :math:`O(n^2)`\ ，但是常系数会变得很小，实际运行速度会比顺序表上的插入排序快很多。

那么如果把查找过程也改成二分查找会不会更好呢？答案是只会变得更坏，不会变得更好。为什么？这是因为链表这种结构不适合二分查找。我们知道，二分查找需要根据首尾两端直接找到中点位置，而链表天生不适合按下标值访问元素。根据首尾元素的指针无法计算出中间元素的指针，只能设法计算出下标值，然后一步一步地从首元素（或尾元素）爬过去，对于一段长度为 :math:`n` 的链表，访问它的中间点都需要沿着链爬行 :math:`n\over2` 步。而二分插入排序需要进行二分边界查找，二分边界查找一定要找到首尾相遇为止，这样查找结束的时候，一共走的步数一定是恰好 :math:`n` 步。如果采用顺序查找，每次都恰好查找 :math:`n` 步属于最差情况，通常没那么不走运，平均情况是 :math:`n\over2` 步。所以请记住下面这个结论：

.. important::

   链表不适合二分查找，其时间复杂度以 :math:`n` 为上界，即 :math:`O(n)`\ ，不优于顺序查找。

   链表不应该用于二分边界查找，其时间复杂度恰为上界 :math:`n`\ ，即 :math:`\Theta(n)`\ 。

   若要进行二分查找，应使用顺序表。

接下来我们编写一个在单链表上一边读入数据一边进行插入排序的程序。本节的所有例题我们都采用单链表进行实现，这是因为双链表今后可以使用STL的 ``list`` 容器，一般不需要自己编程实现，所以我们尽量多练习单链表的编程。

由于采用的是单链表，所以查找顺序必须是从前向后。为了保持算法的排序稳定性，要查找的应该是最后一个小于等于待插入元素的元素，找到后插入为它的后继。这里就有一个问题，怎么才能确定是不是\ :emphasis:`最后一个`\ ？必须看过它后面那个元素的值才能知道，对吧。所以要比对的是后继元素，是第一个比待插入元素值大的后继，而不是当前元素！这是单链表插入排序和顺序表情形最大的不同之处。

因为不是严格的数据结构练习，所以我们使用简化版的单链表结构，我们可以看到以下一些简化：

1. 因为这个程序只用到一个存放 ``int`` 型整数的单链表，所以我们不再使用模板来定义通用型的元素节点了，直接写死元素值为 ``int`` 型即可。
2. 无论怎样简化，单链表做好还是有一个头部哑节点，可以让程序的编写简单很多。由于哑节点的元素值本身并没有什么用，所以我们把它废物利用起来，用来存放元素个数 :math:`n`\ 。
3. 我们不管什么数据封装原则和惯例了，直接在主程序里访问节点的成员变量。
4. 这个程序里每一个节点的元素值都是输入进来的，所以没必要增加一个可以初始化元素值的构造函数，元素节点结构只需要一个默认构造器，用来把后继指针设置为空即可。事实上就算是这个构造器也并不是必须的，我们完全可以不提供构造器，然后在主程序里每次生成一个新节点之后把后继指针设置为空（这就是C语言唯一的方式），但是C++时代把这种千篇一律的事情写在构造器里是一个更好的习惯。
5. 整个程序只用到一份单链表，因此也就不单独写一个表示链表的结构了，在主程序中直接定义一个头部哑节点就可以了，至于要用到的单链表的各种功能，要么在主程序中直接写代码，要么定义为单独的函数，把头部哑节点以传指针的方式作为参数传递给函数（这也是以前C语言时代唯一的提供功能的方式）。
6. 事实上要完成边读入数据边排序的功能，我们只需要用到插入元素的功能，这很简单，我们直接写在主程序里。另外我们单独写两个辅助的功能函数，\ ``print()`` 函数用来输出链表中的元素、\ ``clear()`` 函数用来清空链表中的所有元素节点，释放内存。

.. important::

   我们上一节说过，链表中的节点都是动态 ``new`` 出来的，在链表不再使用的时候要及时 ``delete``\ 。理论上，程序退出运行会自动清空所有动态内存，所以对于本例这种在 ``main()`` 中创建链表并用到程序结束的简单情况，可以不需要在结束程序之前清动态内存。但这是一个好习惯，无论如何，只要有过 ``new`` 就一定要遵守谁借谁还、有借有还的原则。

   另外，如果头部哑节点也是 ``new`` 得到的，那么光情况链表元素是不够的，万万不要忘记头部哑节点也要 ``delete``\ 。

下面就是完整的程序和一个练习题：

.. literalinclude:: ../../codes/319_ins_sort_ll.cpp
   :language: c++
   :emphasize-lines: 37, 38, 40-44

.. admonition:: 练习

   上面是一个随着输入数据同时进行插入排序的示例程序，对于输入数据量不多的情况是很实用的。

   请参照上面的程序算法，编写一个对已经存放了若干数据项（\ ``int`` 型整数）的单链表进行插入排序的函数，即单链表版的插入排序。并使用 :download:`随机整数序列生成器<../../codes/tools/randints.cpp>` 生成随机数据进行测试，记录下排序使用的时间，和数组版的插入排序、二分插入排序进行比较，观察三者在实际运行速度上的区别，分析存在速度差异的原因并总结自己的结论。


单链表上的快速排序
^^^^^^^^^^^^^^^^^^

归并和快排理论上来说都是可以在单链表上实现的 :math:`O(n\log n)` 排序算法，但是事实上归并排序是很不合适的一个选择。这是因为归并排序每一步都需要按照元素下标找到一个序列的中点，而直接飞往某个下标值这种操作恰好触及了链表的功能盲区。

快速排序就很适合在链表上实现了，哪怕是单链表也没有太大问题，这里只是涉及一个分区方法的选择问题。以前我们说过，常见的分区方法有两类，一类是设置一前一后两个哨兵，让它们分别从后向前和从前向后地扫描整个待分区序列；另一类是我们详细介绍并推荐使用的《算法导论》一书介绍的方法。简单地想一想就明白应该选哪一类了，单链表根本没法从后向前扫描啊。所以前一类的方法根本没法用在单链表上，只能使用第二类方法，这也是我们强烈推荐掌握这种方法的原因之一。

回顾一下这种分区方法，一定会发现在单链表上实现它是有多么简单，几乎都不需要进行任何改变就可以实现，只是有这么几个点需要留意：

1. 在数组上进行分区，我们用左闭右开的下标值区间来表示要分区的范围，现在我们将改用节点指针，而且不在搞什么左闭右开，直接指向一头一尾两个元素节点（因此我们需要有保存尾节点）。
2. 当需要进行元素交换的时候，直接交换节点里的元素值成员变量，不要傻傻地去做节点交换。
3. 返回值也是指针，由于是单链表，需要返回的是中间元素节点的前驱节点指针，也就是左半区的尾节点指针，而不是中间节点本身的指针（否则就不知道左边半区的尾节点在哪里了）。

如果对这个分区算法或者对快速排序算法已经感到很陌生了，那么烦请先回到 :doc:`../../ch02/sec05/254_quick_sort` 认真复习。
