链表的应用
++++++++++

由于链表特殊的存储结构，在某些应用场景会比使用顺序表更为方便高效，有些场景甚至会不得不使用链表。尤其是某些比较古老的编程语言，比如C语言，它们没有 ``vector`` 之类的可变长度顺序表可以使用，如果需要用到长度总是在变化的序列时，往往就只能使用链表来实现了。

本节我们看几个基于链表的简单应用，感受一下链式存储结构给某些算法场景带来的影响。本节的例题在编程时不使用上一节学习的那种完善的链表结构，而是按照算法编程的特点，根据题目的要求以 :emphasis:`够用就行` 的原则因地制宜予以简化。

单链表上的插入排序
^^^^^^^^^^^^^^^^^^

前面我们学过了插入排序，已经知道了插入排序的时间复杂度为 :math:`O(n^2)`\ 。哪怕是经过优化的二分插入排序，虽然插入点查找的过程能达到 :math:`O(\log n)`\ ，但是随后在顺序表中的插入仍然是一个 :math:`O(n)` 时间的操作，所以总体的时间复杂度还是二阶的，尽管实际应用上在元素数量不多时能够接近 :math:`O(n\log n)`\ 。

那么如果是在链表上进行插入排序，情况会不会不同呢？当然了，插入元素这一步操作现在从 :math:`O(n)` 直降为 :math:`O(1)` 了，关键看查找插入点的过程。如果仍然采用顺序查找，那么还是 :math:`O(n)` 时间，和使用顺序表的时候一模一样。综合起来看，查找过程的时间复杂度没有变化，插入过程大幅降低为常数时间。所以总体时间复杂度虽然还是 :math:`O(n^2)`\ ，但是常系数会变得很小，实际运行速度会比顺序表上的插入排序快很多。

那么如果把查找过程也改成二分查找会不会更好呢？答案是只会变得更坏，不会变得更好。为什么？这是因为链表这种结构不适合二分查找。我们知道，二分查找需要根据首尾两端直接找到中点位置，而链表天生不适合按下标值访问元素。根据首尾元素的指针无法计算出中间元素的指针，只能设法计算出下标值，然后一步一步地从首元素（或尾元素）爬过去，对于一段长度为 :math:`n` 的链表，访问它的中间点都需要沿着链爬行 :math:`n\over2` 步。而二分插入排序需要进行二分边界查找，二分边界查找一定要找到首尾相遇为止，这样查找结束的时候，一共走的步数一定是恰好 :math:`n` 步。如果采用顺序查找，每次都恰好查找 :math:`n` 步属于最差情况，通常没那么不走运，平均情况是 :math:`n\over2` 步。所以请记住下面这个结论：

.. important::

   链表不适合二分查找，其时间复杂度以 :math:`n` 为上界，即 :math:`O(n)`\ ，不优于顺序查找。

   链表不应该用于二分边界查找，其时间复杂度恰为上界 :math:`n`\ ，即 :math:`\Theta(n)`\ 。

   若要进行二分查找，应使用顺序表。

接下来我们编写一个在单链表上进行插入排序的程序。本节的所有例题我们都采用单链表进行实现，这是因为双链表今后可以使用STL的 ``list`` 容器，一般不需要自己编程实现，所以我们尽量多练习单链表的编程。

由于采用的是单链表，所以查找顺序必须是从前向后。为了保持算法的排序稳定性，要查找的应该是最后一个小于等于待插入元素的元素，找到后插入为它的后继。这里就有一个问题，怎么才能确定是不是\ :emphasis:`最后一个`\ ？必须看过它后面那个元素的值才能知道，对吧。所以要比对的是后继元素，是第一个比待插入元素值大的后继，而不是当前元素！这是单链表插入排序和顺序表情形最大的不同之处。

