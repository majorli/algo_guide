顺序表
++++++

:strong:`顺序表`，全名\ :strong:`顺序存储结构`，是线性表的一种。和所有线性表一样，它采用位置和元素一一对应的方式组织数据。在实际存储时，顺序表会先在内存中开辟一块足够存放所有元素的连续的空间，然后把所有元素按其序号依次紧挨着存放，彼此之间不允许出现空隙。由于顺序表并不要求它开辟的所有空间全部填满数据，因此还需要一个额外的表示当前表中有多少个元素的长度变量，通常会叫做 ``length`` 或 ``size``。

例如，数列 :math:`\{a_1,a_2,a_3,a_4,a_5\}` 在用顺序表来表示的时候，实际的存储状态如下图所示。

.. image:: ../../images/311_sequence_list.png


.. note::

   图中每个元素上方的数字是它的序号，请千万要熟悉计算机语言中总是从0开始计数的设定。size指示当前表中的元素数量，因此等于5，而由于表元素从0开始计数，所以最后一个元素的序号是size-1，也就是4，而size=5刚好指向表尾后的下一个空位。


我们可以发现，顺序表极其天然的适合用C++数组来实现。事实上在许多算法程序里，为了简化编程，顺序表往往就是一个普通的数组加一个表示数据量的整型变量而已。

.. code-block:: c++
   
   int a[100], size = 0;

这样一句简单的变量声明语句就足以构造出一张最简单的顺序表。由于顺序表具有从头开始挨个存放元素，并且有一个长度变量指示元素总数的特点，我们甚至不需要初始化数组元素。当然了，如果程序中要用到多张顺序表，每一张都这样定义就会让代码变得很难看。因此一般我们至少要用一个结构来把存放元素的数组和长度变量封装起来，形成一个定义完整的顺序表数据类型。这是实现一个定义完好的数据结构的第一步，:strong:`整合数据`。

.. code-block:: c++
   
   struct List {
           int data[100];
           int size;
   };


.. hint::

   要知道虽然数据结构和算法是紧密结合的，但毕竟是两种不同的课程。二者在研究的目标、方法和技巧上有着诸多不同。正如我们刚看到的，如果重点是算法的设计与实现，那么有时候我们可以不拘泥于其用到的数据结构是否完美实现。但如果是学习数据结构，那么我们会很注重数据结构定义和实现的完整性，主要有以下几个关注点：

   * 所有数据和辅助变量是否有完整的封装，一般用一个或几个结构体来完成数据的封装。
   * 所需的最基本的功能是否都已经实现，传统的方式是定义一系列对封装了数据结构的结构体变量进行操作的函数，这也是大多数C语言数据结构教科书使用的方式；C++的方式则是给封装了数据结构的结构体（或者类）增加\ :strong:`成员函数`。

   我们采用给结构体增加成员函数的方式来同时封装数据和功能。

   
.. admonition:: 说明

   由于本章是数据结构部分的内容，所以本章我们将展示怎样利用C++ struct来实现一系列封装完好的数据结构。在学会了每一种数据结构的原理之后，实际算法编程时往往不需要如此完好地去手打代码自己实现它们，而是有两种变通的方法：一是根据程序需要自己实现一个简化版；二是利用C++ STL库的容器类，我们对此也会进行说明。


**顺序表的初始化**

定义了结构 ``List`` 之后，如果我们在程序里需要用到顺序表，那么我们就声明一个 ``List`` 型变量并对其进行初始化。顺序表的初始化只需要做一件事：把长度设为0。

.. code-block:: c++
   
   List l1 = { { 0 }, 0};     // 采用初始化结构变量和数组的方式进行初始化
   
   List l2;             // 也可以像这样分两句进行，但在开始使用这张表前一定要初始化好
   l2.size = 0;


但是我们可以用C++风格来给List结构增加一个\ :strong:`构造器`\ （constructor），这样每次声明一个List结构的变量时就会自动调用构造器来完成必要的初始化工作。

.. code-block:: c++
   
   struct List {
           int data[100];
           int size;
   
           List() { size = 0; }
   };


现在我们只需要声明变量就可以了，在变量被生成出来的时候构造器会自动被调用并执行其中的代码。现在生成一张顺序表时就不需要自己去显式地初始化它了，单纯地声明变量即可。

.. code-block:: c++

   List l3;


.. note::

   构造器有点类似一个函数，只不过它没有返回类型，所以也无需返回任何东西。如果它完全是一个顺序运行的代码块，那么甚至最后连 ``return;`` 语句都不需要。

   构造器也可以有参数表，接收一些参数用来初始化结构的成员变量。那样的话我们在声明变量时在变量名后面像调用函数一样加上参数表就可以了，类似于 ``List l(3);`` 这样的形式。

   C++甚至允许给一个结构定义多个构造器，只要每个构造器的参数表不同即可。在声明变量时会自动按照参数表来匹配应该调用哪一个构造器。


**插入元素**

向一张顺序表里插入元素要符合以下规则：


（待续）
