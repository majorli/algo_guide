指针 VS 引用
------------

指针和引用是C++语言编程者无法绕过的两个重要语法点。

**指针是C语言最精华的精华，也是最糟粕的糟粕**。因为有了指针，C语言才成为一种远远超越同时代的Fortran、Pascal、BASIC、ALGOL等语言，一举确立编程语言界第一任武林盟主的地位。指针给了C语言强大的能力、无与伦比的灵活性和大量的编程新技术新技巧。但也正因为指针过于强大和灵活，学习和完全掌握指针的使用难度极大，而且它又带来了非常严重的安全隐患，历史上曾经给C语言软件开发带来过大量灾难性的问题。几乎所有的C语言教程都会严正警告学习者，不要随意使用指针，不要在程序里滥用指针。指针带来的典型问题有：

1. 函数滥用指针参数，不对参数加以必要的 ``const`` 修饰，导致实参被函数代码篡改。
2. 滥用指针代替数组，超限问题更加频繁和隐蔽。
3. 滥用多重指针，导致常量被篡改。
4. 悬空指针：多个指针指向同一块动态分配的内存，随后通过其中一个释放了内存，其他指针成为悬空指针，容易导致内存泄漏。
5. 野指针：定义指针变量却未初始化，不用的指针未改为NULL，或动态分配的内存释放后没有将指针改为NULL，导致内存访问混乱。
6. 在函数体中声明指针并分配内存，把指针作为函数返回值交给调用者，容易造成内存只分配不销毁，最终导致内存耗尽。

以上是滥用指针或不正确使用指针最易发生的问题。其他还有许多情况，举不胜举。尤其是初学编程者，在尚未完全掌握的情况下如果不加节制地使用指针通常要遭遇严重问题，而且指针引发的错误和问题极难调试。

C++语言为了改善上述指针滥用问题，设计了 :emphasis:`引用` 这个机制来尽可能地替代指针。引用就是对变量增加一个别名，通过这个别名可以直接使用原变量。引用比直接操作内存地址的指针安全很多，绝大多数以前必须使用指针的场景都可以用引用来代替。另外还有一些别的场景在C语言中只能使用指针的，C++也实现了一些更加安全便捷的新方法来替代指针。所以使用C++语言绝大多数场景都可以有替代方案可以选择，但是还有少数场景指针无法或者很难被代替。下面我们一一进行介绍。


**可以用引用来完全替代指针的场景**


1、用来使函数代码可以修改实参

有时候我们需要函数代码能够改变为它提供形参值的外部变量的值，在C语言里只能采用指针作为参数。但是在C++语言里我们强烈建议用传引用来代替传指针，最典型的例子就是交换两个变量的值。

.. literalinclude:: ../codes/150_swap.cpp
   :language: c++


.. attention::

   和传指针的参数一样，传引用的参数不能用字面量或者表达式给它喂值，它必须接收一个实实在在的变量。


2、用来传递数组作为函数参数

C++引用加模板可以完美实现传递数组作为函数参数，请参阅上一节的介绍：:ref:`模板参数：搞定数组作为函数参数时的种种不爽<ref_140_template_array>`。


3、用来传递大型结构变量作为函数参数

我们知道C++函数的普通参数传递采用的是传值方式，也就是说实参值是复制一份具体的值喂给形参的。那么如果我们传递的参数是一个很大型的结构变量时，复制这个参数值会占用大内存，消耗较多时间。这一问题最严重的情况是结构的成员变量中有大型数组，例如一个封装好的顺序表。C语言采用传递指针的方法来解决这一问题，函数的参数接收一个该结构类型的指针。C++语言则用传引用来解决这个问题，我们强烈建议使用引用而不是指针。如果我们不允许函数代码改变被引用的结构，那么我们给参数表中的这个参数前加上 ``const`` 限制。


4、用作函数返回值

为什么函数有时候要返回引用？主要也是为了节约时间和空间。通常C++函数也是用传值的方式来返回值的，也就是说C++会在函数返回时为 ``return`` 后面的值创建一个临时变量，然后把具体的值复制到该临时变量里去进行返回。这种操作的性能问题仍然出现在需要返回一个大型结构变量时，和前面所说的情况类似。在C语言时代为了解决这个隐患只能采用返回指针的方法，但是存在安全隐患太多。C++则允许函数返回一个引用，这样就不会创建临时变量和复制返回的具体值了。

.. warning::

   函数如果要返回引用，因为引用必须背后有一个实实在在的变量作为支撑，所以绝对不能返回在函数内部创建的局部变量的引用。局部变量在函数返回的时候是会被销毁的，如果返回局部变量的引用，那么这个引用就会失效。这一点其实和返回指针很类似，如果函数的返回值是指针，同样是禁止返回局部变量的指针的。

所以如果函数要返回引用，它的返回值就只能是另一个在外部实际存在的变量的引用。而在函数内部唯一可以接触到外部变量的地方就只有参数表，所以参数表里必须至少有一个同类型的引用参数可供用作返回值。

.. attention::
   
   由于引用可以视作是它背后那个实际的变量的别名，所以返回引用的函数本身可以成为一种“可赋值”的东西，完全可以有这样诡异的语句存在：``func(a) = b;``。这种特性有时候可以用来实现可连续赋值，但是太过诡异了，绝少会需要用到这样的语句。为了避免出现把函数调用作为被赋值对象的尴尬场面，我们可以在函数头的最前面加上常量修饰 ``const``。

总之，函数返回引用的情况比较复杂，一般情况下还是要尽量避免使用，事实上绝大多数情况是可以避免的。


5、C字符串

C字符串本质上是一个字符数组，出于指针和数组夹缠不休的暧昧关系，许多程序代码和书本例题里都喜欢用字符指针来代替字符数组以表示C字符串。但实际上二者并没有太多区别，大多数情况下二者是等价的。所以我们建议如果程序中要处理C字符串的话，安全起见，还是多多使用数组表示法比较好。

尤其有一个地方需要说明，许多C语言教科书和老程序员会告诉你，如果你需要依次遍历一个字符串里的所有字符，那么用指针运算会比用数组下标更快。然后他们会津津乐道地给你讲解 ``*p++``，``(*p)++`` 和 ``*(p++)`` 之间的异同，把你彻底搞晕。实际上在现代计算机系统下，这点速度差异根本感觉不出来，而数组的方括号运算符 ``[]`` 比起指针运算要直白和安全多了。鉴于我们主要是要学习算法和参加竞赛考试，避免过多使用指针是更加推荐的方法。

只有一个地方是建议使用字符指针来表示C字符串的，那就是在函数的参数表里和函数返回值。在参数表里用字符指针 ``char *`` 来表示C字符串是一种惯例，这样就能一目了然地知道这里传入进来的应该是一个C字符串而不是普通的字符数组。而数组本身就不能是函数的返回值，所以返回C字符串的函数其返回值类型必须是 ``char *``。

我们可以用这样的代码来模拟实现库函数 ``strcpy()``，这里我们用数组的方括号运算符而不是指针运算来定位字符（事实上库函数本身也是用这种方式的）。

.. literalinclude:: ../codes/150_strcpy.cpp
   :language: c++

.. hint::

   在自己编程时我们更建议用C++的string类来表示字符串，不要使用C字符串。大多数情况下二者的处理速度不会有显著差异。


**无法或难以避免使用指针的情况**

1、动态内存管理

动态内存管理，就是在程序运行时根据需要动态地从堆中分配和释放所需的内存空间。动态数据结构，例如各类可变长顺序结构、各类链式存储结构、哈希表等，都依赖于动态内存管理来实现。不幸的是动态内存管理只能使用指针，没有其他可替代方式。

但是C++的设计者也知道传统C语言中指针存在的问题，因此C++语言提供了两个专门的动态内存管理运算符（``new, delete``）来代替原先C语言的动态内存管理库函数（定义在 ``cstdlib`` 库中）。我们强烈建议使用C++的动态内存管理指令，不再使用C库函数。但是现在还有一些程序和考题中会用C库函数来实现动态内存，所以对它们有所了解还是有必要的。下面列出常用场景下两种方式各自的语句对比。

1. 动态变量

.. code-block:: c++

   #include <cstdlib>

   int *p1 = NULL, *p2 = NULL;
   p1 = (int *)malloc(sizeof(int));        // 使用C库函数分配一块一个int变量长的动态内存并让指针p1指向它
   p2 = new int;                           // 使用C++的new运算符申请一个动态int变量并让指针p2指向它
   
   // ...
   
   free(p1);                               // 使用C库函数释放p1所指向的动态内存
   p1 = NULL;
   delete p2;                              // 使用C++的delete运算符释放p2所指向的动态变量
   p2 = NULL;

.. important::

   * 每一个指针在声明时必须有效初始化，要么赋予有效的值，要么初始化为NULL，避免野指针。
   * 每一个new必须对应一个delete，动态申请的内存用完了必须释放回系统，有借有还，避免内存耗尽。
   * 每一个delete后必须跟有新的赋值，如果这个指针不再使用了就赋为NULL，避免野指针。


2. 动态数组

.. code-block:: c++
   
   #include <cstdlib>

   int *a1 = (int *)malloc(20 * sizeof(int));      // C库函数的做法
   int *a2 = new int[20];                          // C++ new运算的做法
   
   // ...
   
   free(a1);                                       // C库函数的释放法
   a1 = NULL;
   delete [] a2;                                   // C++ delete运算符的释放法
   a2 = NULL;

3. 动态二维数组

.. code-block:: c++
   
   #include <cstdlib>
   
   int **b1 = (int **)malloc(10 * sizeof(int *));
   for (int i = 0; i < 10; i++)
           b1[i] = (int *)malloc(20 * sizeof(int));
   
   int **b2 = new int *[10];
   for (int i = 0; i < 10; i++)
           b2[i] = new int[20];
   
   // ...
   
   for (int i = 0; i < 10; i++)
        free(b1[i]);
   free(b1);
   b1 = NULL;
   
   for (int i = 0; i < 10; i++)
           delete [] b2[i];
   delete [] b2;
   b2 = NULL;


2、动态顺序数据结构

前面已经说过，动态数据结构的实现往往依赖于动态内存管理，因此难以绕过指针的使用。这样的数据结构主要包括各类可根据元素的数量动态调整自身大小的表格，常见的有可动态调整大小的顺序表、栈和队列。

我们知道，这一类数据结构的底层都是基于一个数组来构造的，C++的数组一旦定义好之后，它的长度就不会变了。例如一个长度为100的整型数组 ``int a[100]``，声明完之后它就最多能容纳100个整型数。如果用这样一个数组来构造了一个顺序表，当插入表中的元素超过100个时，它就没办法容纳了。所以如果无法事先知道可能要插入表中的元素数量，那么就不方便用这样的静态数组来构造顺序表。通常这种时候我们就会用动态数组来构造所需的数据结构，初始的时候用一个比较小的长度来分配空间，一旦不够用了就可以new一个新的更大的空间出来，把原先的元素复制过去，然后把原先分配的空间释放掉，再让表头指针指向新分配的空间。这样一通操作用动态内存管理和内存块复制来实现并不难，而且速度很快。虽然不是很必要，我们甚至还可以实现当元素数量很少的时候缩减空间。

但是在算法编程中，我们还是应该尽量避免使用指针和动态内存分配，因此对此类情况有以下几个建议：

1. 由于算法编程时对于空间的限制往往非常宽松，一般都是不得超过128MB的空间使用量。要知道128MB空间足够开出30个长度为10\ :superscript:`6`\ 的 ``int`` 数组了。而且算法编程题都会明确告诉输入的数据规模，所以容易预测所需数据量。鉴于此我们在算法编程时如果需要构造大型数据结构，绝大多数情况下可以用静态数组来完成。
2. 强烈推荐（如果你会的话）使用C++标准模板库（STL）提供的容器类。常用的有：``vector`` 类，是一种顺序表；``set`` 类是集合，也就是能保持元素值不重复的顺序表；``stack`` 类是栈；``queue`` 类是队列。另外还有比较特殊的优先队列 ``priority_queue`` 和两端队列 ``deque``。上述这些标准容器类全都实现了动态的可变容量。
3. 最后，如果题目是一个要求用标准方法实现某种可变容量的动态顺序数据结构的模版题，那么只能老老实实地按规矩自己用动态内存管理来实现了。但是据我所知这样的题目通常只会出现在大学计算机系《数据结构》这门课的考试中。


3、链式数据结构

所有的标准链式数据结构都是动态数据结构，其规范的实现方法离不开指针和动态内存技术。这样的数据结构主要有各类链表、树型结构和链式哈希表，另外有时候在解决一些算法难题的时候有可能需要自行设计一些非标准的数据结构，它们也可能全部或部分地使用链式存储结构。

在算法编程中，我们对此类情况也有一些建议：

1. 能转为使用顺序数据结构，避免使用链式结构的就尽量用顺序结构解决问题。
2. C++ STL库中提供了两个标准容器类，有时候能派上用场：``list`` 类是一个双向链表；映射类 ``map`` 非常适用于构造健值对、JSON对象、XML结构这些特殊数据结构，也适用于构造树型结构，某些时候很有用，不妨试一试。
3. 同样的，如果不幸遇到了模板题，那么老老实实自己用动态内存管理来实现。

.. important::

   再次重申，在使用动态内存管理功能的时候，delete和new必须成对出现。尤其是在用于构造数据结构时，必须要有delete数据结构里面所有new过的指针的功能。如果是动态的顺序结构就需要循环地delete所有元素；如果是链式结构，那么就需要遍历一遍所有节点并把它们全部delete释放内存。

