内存块操作
----------

**什么叫内存的块操作**

事实上无论是诸如 ``int`` 这样的基础数据类型也好，还是数组、结构这样的派生数据类型也罢，都是计算机内存中的一块连续的存储空间，大小不一而已。例如现在通常的64位计算机系统里，一个C++的 ``int`` 型变量占用的是连续4个字节。C++基础数据类型的单个变量占用空间都是固定的，最小的是 ``char`` 和 ``bool`` 类型，单个变量占用一个最小单位内存，即一个字节，而 ``long long int`` 和 ``double`` 则需要8个字节，在某些系统下一个 ``long double`` 会占用16个连续字节。派生数据类型只是把组成它的基础类型变量连续存放起来而已。例如一个含有100个 ``int`` 元素的数组在内存中就是连续的400个字节。结构体占用的内存空间也是连续的，例如下面这个用来表示一个最大长度为100的顺序线性表的结构：

.. code-block:: c++
   
   struct List {
           double a[100];
           int len;
   };

每一个这样的 ``List`` 类型的结构变量在内存中占用804个连续的字节，其中800个字节是100个元素的 ``double a[100]`` 数组，另外4个字节用来存放表示长度的 ``int len`` 变量。如果我们需要创建16张这样的顺序表，然后把它们放在一个数组里：

.. code-block:: c++

   List lists[16];

这个 ``lists`` 数组就占用了一块804\*16=12864字节的连续内存。凡是这样连续的内存空间我们称为\ :strong:`内存块`，对于内存块的操作有时候称为\ :strong:`块操作`。

我们常常需要对大型复合数据类型同时进行操作，例如我们有时候要对一个大数组进行初始化赋值，有时候我们需要清空一个大数组或者大结构里的信息，有时候我们需要把一个大数组里的内容复制到另一个大数组里。这些操作用C++语言的循环语句可以简单地完成，但是有时候我们更喜欢把这些大数据大结构看成是一个内存块对它们进行块操作。这是一种把高级视角下的事物用低级视角去考虑和处理的思路，而大自然的普遍规律往往是\ :strong:`越高级的事物功能越强，但性能越差`。块操作基本上属于硬件层级的低级操作，相对于高级的C++语言操作，它的最大优势就是快！


**块操作的两个常用C++库函数**

C++语言的C标准库 ``cstring`` 中有两个常用的块操作函数，用以完成两种最基本的块操作。``memset()`` 函数用来给一个内存块里的所有字节一次性统一设置数值，``memcpy()`` 函数用来将一个内存块的内容整块复制到另一个内存块中。另外还有几个别的块操作函数，但是这两个是用得最多的。作为算法程序的辅助手段，掌握这两个函数的用法就足够了。要知道几乎每一种计算机系统都会在硬件层级实现内存块设置、复制的硬指令，而C标准库中的这些块操作函数就会充分利用计算机系统提供的硬件指令来实现块操作，它们的运行速度就是所谓的“硬件级速度”，比C++语句的速度要快上不知道多少倍。如果要操作的数据量特别大，那么用块操作函数可以节省下极大量的时间。

``memset()`` 函数的功能是给一块指定起点、指定长度（以字节为单位）的内存块里的每一个字节都同时设置为一个指定的值。

.. code-block:: c++

   void *memset(void *s, int c, size_t n);

它的返回值其实就是这个内存块的起点地址，返回类型是一个“无类型指针”``void*``，这是个什么东西先不用去管，大多数情况下可能一辈子都用不上这个返回值。它接受三个参数：

1. ``void *s``：这个参数用来指定要操作的内存块的首地址。对于数组，我们用数组名（例如 ``a``）就可以获得它的首地址，数组名就是数组第一个元素的首地址，它等价于 ``&a[0]``；如果我们要设置的是从数组中间某个元素开始的部分，我们用 ``a+n`` 表示数组的第n号元素（注意从0开始计数）的首地址，它等价于 ``&a[n]``；对于结构或者其他任何什么别的大型变量，我们用C++的取地址运算符 ``&`` 来获得它们的首地址，就像在 ``scanf()`` 函数里所做的一样。
2. ``int c``：这是要给每个字节设置的值。要注意，虽然这个参数的数据类型是 ``int`` ，但实际上块操作是针对字节的操作，所以最终被设置的值是这个参数值最后一个字节的内容，可以理解为 ``c % 256`` 的值。之所以把它设为 ``int`` 类型无非是为了编程方便，可以有更多的灵活方便法门。我们暂时先不要去追究这方面的窍门，并且尽量使用规范的-128到127范围内的数值（或者0到255）。
3. ``size_t n``：内存块以字节为单位的长度，``size_t`` 其实是无符号长整型，实际使用的时候可以接受任意类型的整数。千万记得是以字节为单位的长度！例如 ``int a[100]`` 这个数组的内存块，长度是400，不是100！初学者最容易在这里掉坑！当然了，一般我们建议用 ``sizeof`` 运算来计算内存块长度。


``memcpy()`` 函数的功能是将一块指定起点指定长度（以字节为单位）的内存块里的内容复制到另一块指定了起点的内存块中去。

.. code-block:: c++

   void *memcpy(void *dest, const void *src, size_t n);

它的返回值也是一个很可能一辈子都用不上的 ``void *`` 指针，其实就是目标内存块的首地址。它同样接受三个参数：

1. ``void *dest``：这是要复制到的目标内存块的首地址。
2. ``const void *src``：这是要被复制的源内存块的首地址，``const`` 修饰符在这里的意思是限定源内存块里的内容不能被改变。
3. ``size_t n``：要复制的内存块长度，也就是字节数。

要注意内存块复制的时候，目标块和源块不能有重叠，也就是说目标块内的地址不能有包含在要被复制的源内存块里面的。

.. image:: ../images/130_memcpy.png
   :scale: 50%


**memset和memcpy的典型用例**

说了这么多，还是觉得糊涂？那么直接上案例。下面所举的是在算法编程中内存块操作最为常见的典型用例，学会它们的使用其实也就差不多了。

1、批量清空数组中的全部或部分连续元素

所谓清空，对于C++语言的基础数据类型来说就是把每一个字节都设置为0。对于 ``char, short, int, long, long long, float, double, long double`` 这些数值型变量，无论是否 ``unsigned``，每一个字节都设置为0后它们的数值就变成了0；对于用作字符的 ``char`` 变量，设置为0成为空字符 ``'\0'``；对于C字符串 ``char[]``，设置为0就变成空字符串 ``""``；对于 ``bool`` 型变量，设为0就是设为 ``false``；如果是指针，那么设置为0就成了空指针 ``NULL``。而派生数据类型归根到底都是由基础数据类型组合而成的，所以用 ``memset()`` 可以方便地清空数组中的元素，至于部分还是全部，完全由首地址和长度两个参数决定。

以整型数组为例：

.. code-block:: c++
   
   const int MAXN = 1e6;
   int a[MAXN];
   
   memset(a, 0, MAXN * sizeof(int));       // 清空整个数组
   memset(a, 0, 100 * sizeof(int));        // 清空前100个元素
   memset(a+100, 0, 50 * sizeof(int));     // 清空a[100]到a[149]这50个元素


同样的方法可以用来清空结构体变量中的所有成员值。但是尽量不要去尝试对结构体中的部分成员变量进行块操作，因为不同的计算机系统对于结构体中成员变量的存放位置规则可能有所不同。

.. code-block:: c++
   
   struct S {
           // 成员变量...
   };
   
   S a, b[100];
   
   memset(&a, 0, sizeof(S));       // 清空结构体a
   memset(b, 0, 100 * sizeof(S));  // 清空结构S数组b中的所有结构体

.. _ref_130_memset:

2、批量给数组中的全部或部分元素赋值

有一些特殊的值可以用块操作来批量赋值，例如0就是这样一个特殊的值。但并不是每一个值都是可以这样批量赋值的。例如对于 ``int`` 型数组，就不能用 ``memset(a, 1, n * sizeof(int))`` 来把其中所有元素都赋值为1。这是因为一个 ``int`` 变量在内存中占据4个字节，而块操作是按字节来设置值的，如果执行上面这一条语句，那么每个 ``int`` 元素的所有4个字节都被设置为1，结果元素的值变成了十六进制的 ``0x01010101``，转为十进制就是 ``1+256+256*256+256*256*256=16843009``。所以对于 ``int`` 型变量来说，1这个数值是不能用块操作来批量赋值的。

事实上每一种基础数据类型都有一些可以用块操作批量赋值的数值，有时候可以带来一些对编程有帮助的小技巧。常会用到的有两种，请务必记住。

.. code-block:: c++
   
   int a[100];
   bool b[100];
   
   memset(a, -1, 100 * sizeof(int));       // 把数组a中的所有元素赋值为-1
   memset(b, 1, 100 * sizeof(bool));       // 把数组b中的所有元素赋值为true

至于 ``char`` 这种本身就只占用一个字节的数据类型，从-128到127都是可以批量赋值的，而 ``float, double, long double`` 这三种浮点数类型则除了0没有别的特殊值。

.. warning::

   千万不要轻易尝试对结构体的成员变量批量赋值，除了0以外哪怕是特殊值也不要轻易尝试。所以如果是一个结构体类型的数组，尽量不要用 ``memset()`` 去批量赋不是0的值。


3、批量复制数组内容

如果要把一个数组里的全部或者部分元素复制到另一个数组里去，那么就用块复制来进行。一般来说要复制到目标数组应该和源数组有相同的数据类型，并且要保证长度足够。

.. code-block:: c++
   
   int a[100], b[100];
   
   memcpy(b, a, 100 * sizeof(int));        // 复制整个a数组中的内容到b数组
   memcpy(b+50, a, 50 * sizeof(int));      // 复制a[0]到a[49]到b[50]到b[99]
   memcpy(a+20, b+20, 80 * sizeof(int));   // 复制b数组的后80个元素到a数组对应位置

当然了，只要源块和目标块不相互重叠，完全可以在同一个数组里实现在不同区块之间复制内容。

.. code-block:: c++
   
   double a[1000];
   
   memcpy(a, a+100, 100 * sizeof(double)); // 复制a[100]开始的100个元素到a[0]开始的位置去

.. warning::

   用块复制来批量复制数组元素时，一定要当心目标块数组超限的问题！


另外，由于C语言字符串本质上是一个字符型数组，所以memcpy完全可以用来复制字符串，只是别忘了字符串尾部必须有一个空字符 ``'\0'``。

``memcpy()`` 函数同样可以用来复制结构体变量，但是一般并没有这个必要，因为结构体变量本身就是可以使用 ``=`` 赋值的，所以一般不需要用 ``memcpy()`` 来复制结构体内容。


可以看出，块复制只是单纯地按字节来复制内存中的内容，它本身根本不关心复制的是什么数据类型，这也是硬件系统的一个特点。利用这个特点还可以实现一些奇特的技巧。

例如在传统的C语言和一些比较古老的计算机语言里，变量名实际上只有前8位字符在起作用，如果有两个变量的变量名前8位相同，只有第9位字符开始不同，比如 ``abcdefg_1`` 和 ``abcdefg_2``，语言会认为他们是重复命名的变量。这些语言的编译器在编译源程序的时候，会把每一个变量名前8位字符的ASCII码从后往前串起来构成一个64位整数。这个整数叫做变量名的哈希值，是和前8位字符一一对应的，两个变量是否重名只需要对比二者的哈希值就可以了。

如果我们用普通方法逐个字节从后向前去串起来构成一个64位整数，需要用到一个循环，共计计算8次整数乘、8次整数加。

.. code-block:: c++
   
   char var_name[] = "variable_name_xxx";
   unsigned long long hash = 0;
   
   for (int i = 7; i >= 0; i--)
           hash = hash * 256 + var_name[i];

如果用上内存块复制的话，这样就搞定了：

.. code-block:: c++

   #include <cstring>

   char var_name[] = "variable_name_xxx";
   unsigned long long hash;
   memcpy(&hash, var_name, 8);

代码简单速度快，堪称奇技淫巧的典范。

一些有经验的C++语言老程序员有很多这样的小技巧，但是实际上这类技巧不容易把控，需要对计算机的数据表示原理有比较精深的掌握，而且在算法编程中能用的场景并不多，所以我们并不推荐在算法编程中过多使用这类技巧。对于内存块操作，重点掌握批量清零的方法，适当应用特殊值批量赋值和数组区块复制即可。有兴趣的话可以先去学习一下计算机组成与原理的相关知识再尝试更多此类方便法门。

