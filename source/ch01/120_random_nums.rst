生成随机数
----------

编写算法程序常常会需要自己生成一些测试数据。如果数据量小可以自己手动编一些，但是往往会需要大数据量的测试数据，这时候手动编数据就很困难了。我们需要用计算机来自动生成一批随机数。

在C++语言中，继承自C语言的 ``cstdlib`` 标准库里有一个 ``rand()`` 函数就是用来生成 *伪随机数* 的。

.. code-block:: c++

    int rand();

调用这个函数不需要提供任何参数，每次调用会返回一个从0到最大的 ``int`` 型（一般是 :math:`2^{31}-1=2,147,483,647`）之间的随机数。所以最常见的用法是生成从0到某个正整数 :math:`a` 以内的随机数，不包含这个正整数自身。那么我们利用除法余数取值范围的规律，即一个正整数除以 :math:`a` 得到的余数取值范围为 :math:`[0,a)`，每调用一次 ``rand() % a`` 就可以得到一个这样的随机数。

更一般地，如果要生成 :math:`[a,b)` 区间内的整数随机数的话，我们可以调用 ``rand() % (b - a) + a`` 来实现。例如要生成范围为从1开始，100以内（不含100）的随机数，那么调用 ``rand() % 99 + 1``，而 ``rand() % 100 + 1`` 生成的是从1到100（包含100）的随机数；如果要生成 :math:`[-100,100]` 区间内的随机数，那么就这样调用 ``rand() % 201 - 100``。请一定要搞清楚范围的两头是不是包含，不熟练的时候可以先用除法余数取值范围来算一算。

.. attention::

   *请注意在计算机软件的世界里，表示范围的惯例就是“含头不含尾”，用数学语言来说就是“左闭右开”区间，千万要牢记并熟悉这一惯例。*


但是要知道 ``rand()`` 函数生成的是 *伪随机数*。意思是这个“随机”数实际上是用一套精巧但是确定的数学方法计算出来的，它看上去是随机的，但实际上它有规律。这个规律表现在每次第一次调用它生成第一个数时，这套数学公式需要一个初始值来启动整个生成随机数的过程。这个初始值叫做伪随机过程的\ **种子**。用同一个种子启动的所有伪随机过程，它每次生成出的所有随机数都是一模一样的。不巧的是，``rand()`` 函数每当第一次被调用时会自动使用1来作为启动的种子，从来不变，永远是1！我们可以多次运行下面这个小程序观察其输出结果。

.. literalinclude:: ../codes/120_random_nums.cpp
   :language: c++
   :linenos:
   :lines: 1,3-6,8-12

我可以保证，不管运行多少次，你都会得到同样的一百个数，如果你也使用NOI Linux下的g++ 4.8.4的话，十有八九会是这样的：

.. code-block:: none

      1,  4,  6, 70, 87, 66, 57, 92, 60, 11, 81, 79, 85, 72, 50, 62, 43, 16, 36, 56
     13, 70, 25, 99, 17,  8, 91, 97,  8, 64, 50, 61, 20, 56, 84,  7, 74, 41, 51, 87
      4, 33, 66, 41, 57, 16,  3,  0, 84, 39,  9, 50, 61, 34,  1, 78, 94, 92, 28,  2
     56, 78, 16, 28, 35,  0, 88,  9, 41, 39, 96, 97, 24, 62, 38, 82, 30, 41, 34, 15
     32, 43, 17, 45, 29, 18, 23, 24, 10, 51, 78, 18, 30, 94, 46, 17, 94, 34, 26, 87


这可怎么办？这样不就没法生成真正的，至少是像模像样可以用的随机数了吗？当然不会。``cstdlib`` 库同时提供了一个用来人为设置一个种子的函数 ``srand()``。

.. code-block:: c++

    void srand(unsigned int seed);


这个函数没有返回值，调用它会给伪随机过程人为设置一个无符号整型的种子，然后用这个种子启动随机过程。所以我们只要在程序开始时调用一下 ``srand()`` 函数，用一个能保证每次程序运行都不相同的而且难以被复制的种子来启动，我们就可以用 ``rand()`` 来生成仿真程度相当好的随机数了。