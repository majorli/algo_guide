生成随机数
----------

编写算法程序常常会需要自己生成一些测试数据。如果数据量小可以自己手动编一些，但是往往会需要大数据量的测试数据，这时候手动编数据就很困难了。我们需要用计算机来自动生成一批随机数。

在C++语言中，继承自C语言的 ``cstdlib`` 标准库里有一个 ``rand()`` 函数就是用来生成 *伪随机数* 的。

.. code-block:: c++

    int rand();

调用这个函数不需要提供任何参数，每次调用会返回一个从0到最大的 ``int`` 型（一般是 :math:`2^{31}-1=2,147,483,647`）之间的随机数。所以最常见的用法是生成从0到某个正整数 :math:`a` 以内的随机数，不包含这个正整数自身。那么我们利用除法余数取值范围的规律，即一个正整数除以 :math:`a` 得到的余数取值范围为 :math:`[0,a)`，每调用一次 ``rand() % a`` 就可以得到一个这样的随机数。

更一般地，如果要生成 :math:`[a,b)` 区间内的整数随机数的话，我们可以调用 ``rand() % (b - a) + a`` 来实现。例如要生成范围为从1开始，100以内（不含100）的随机数，那么调用 ``rand() % 99 + 1``，而 ``rand() % 100 + 1`` 生成的是从1到100（包含100）的随机数；如果要生成 :math:`[-100,100]` 区间内的随机数，那么就这样调用 ``rand() % 201 - 100``。请一定要搞清楚范围的两头是不是包含，不熟练的时候可以先用除法余数取值范围来算一算。

.. attention::

   请注意在计算机软件的世界里，表示范围的惯例就是“含头不含尾”，用数学语言来说就是“左闭右开”区间，千万要牢记并熟悉这一惯例。


但是要知道 ``rand()`` 函数生成的是 *伪随机数*。意思是这个“随机”数实际上是用一套精巧但是确定的数学方法计算出来的，它看上去是随机的，但实际上它有规律。这个规律表现在每次第一次调用它生成第一个数时，这套数学公式需要一个初始值来启动整个生成随机数的过程。这个初始值叫做伪随机过程的\ **种子**。用同一个种子启动的所有伪随机过程，它每次生成出的所有随机数都是一模一样的。不巧的是，``rand()`` 函数每当第一次被调用时会自动使用1来作为启动的种子，从来不变，永远是1！我们可以多次运行下面这个小程序观察其输出结果。

.. literalinclude:: ../codes/120_random_nums.cpp
   :language: c++
   :linenos:
   :lines: 1,3-6,8-12

我可以保证，不管运行多少次，你都会得到同样的一百个数，如果你也使用NOI Linux下的g++ 4.8.4的话，十有八九会是这样的：

.. code-block:: none

      1,  4,  6, 70, 87, 66, 57, 92, 60, 11, 81, 79, 85, 72, 50, 62, 43, 16, 36, 56
     13, 70, 25, 99, 17,  8, 91, 97,  8, 64, 50, 61, 20, 56, 84,  7, 74, 41, 51, 87
      4, 33, 66, 41, 57, 16,  3,  0, 84, 39,  9, 50, 61, 34,  1, 78, 94, 92, 28,  2
     56, 78, 16, 28, 35,  0, 88,  9, 41, 39, 96, 97, 24, 62, 38, 82, 30, 41, 34, 15
     32, 43, 17, 45, 29, 18, 23, 24, 10, 51, 78, 18, 30, 94, 46, 17, 94, 34, 26, 87


这可怎么办？这样不就没法生成真正的，至少是像模像样可以用的随机数了吗？当然不会。``cstdlib`` 库同时提供了一个用来人为设置一个种子的函数 ``srand()``。

.. code-block:: c++

    void srand(unsigned int seed);


这个函数没有返回值，调用它会给伪随机过程人为设置一个无符号整型的种子，然后用这个种子启动随机过程。所以我们只要在程序开始时调用一下 ``srand()`` 函数，用一个能保证每次程序运行都不相同的而且难以被复制的种子来启动，我们就可以用 ``rand()`` 来生成仿真程度相当好的随机数了。可是到哪里去找这样一种“**每次程序运行都不一样，而且很难被复制**”的无符号整数呢？方法有很多种，最方便最常用的方法是利用 ``ctime`` 库提供的库函数 ``time()``。这个库函数的功能是获取程序运行到当前语句时的时间，用从1970年1月1日凌晨0点0分0秒开始到当前为止的秒数来表示时间，它返回的数据类型 ``t_time`` 恰好是一个无符号整数，而这样的一个秒数恰好能满足我们需要的“每次运行都不一样，很难被复制”的要求。它的调用方法是 ``time(NULL)``。

现在我们来试着运行一下用 ``time()`` 函数优化过的这个小程序。

.. literalinclude:: ../codes/120_random_nums.cpp
   :language: c++
   :linenos:
   :emphasize-lines: 2,7

多运行几次，你会发现现在每次都会得到100个完全看不出规律的不同的随机数。

.. hint::

   在每一个要用到随机数的程序的开头，运行一下 ``srand(time(NULL))``。

.. admonition:: 思考

   那么如果要生成浮点数类型的随机数，或者比 ``int`` 更大的整型，比如 ``long long`` 类型的随机数时应该怎么办呢？这个问题请自行思考解决。

.. warning::

   无论看上去多么没有规律，``cstdlib`` 库提供的 ``rand()`` 函数使用的伪随机数生成算法都是最为普通的和不安全的，只能用于一般的随机数模拟，不能用于真正加解密应用。如果今后你要编写实用的加密解密算法，绝对不能使用它来生成密钥！
