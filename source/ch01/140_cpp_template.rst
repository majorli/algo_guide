C++模板的妙用
-------------

C++语言提供了一种叫做模板（template）的技术，用来支持所谓的泛型（generic types）编程。那么什么叫做泛型呢？简单地说就是使C++语言能够让某些特定的变量支持各种不同的数据类型，最典型的就是函数的形参、函数返回值、结构体成员变量等。C++实现泛型编程的具体方式就是通过模板技术让原本对数据类型有很严格要求的传统C++函数、结构体变成模板函数、模板结构，实现一次定义多种用途。

虽然模板技术更多地被应用在面向对象的工程编程领域，但是它在算法编程中也有自己的用武之地。尤其在数据结构这个部分，模板技术是实现所谓抽象数据类型（ADT）的关键技术。在这里我们先了解一下模板技术的一些典型用法。

**模板函数：让一个函数适用多种数据类型**

通常一个定义好的函数只能适用于在它的参数表里定义好了的参数数据类型。例如最常见的取两个 ``int`` 型整数中较大那个值的函数，我们已经很熟悉了。

.. code:: c++
   
   int max(int a, int b)
   {
           return a > b ? a : b;
   }

可是如果我们的程序里不光需要处理 ``int`` 型变量，还需要处理 ``long long``，有可能还需要比较 ``char``，甚至还有 ``double``，怎么办呢？当然我们可以为每一种需要进行大小比较的数据类型都写一个这样的函数出来，然后分别叫做 ``max_int()``、``max_long_long()``、``max_char()``，等等等等。是不是感觉很愚蠢？用模板技术就可以轻松解决这个问题，先看代码。

.. literalinclude:: ../codes/140_template_1.cpp
   :language: c++
   :emphasize-lines: 3,4

.. note::

   * ``template<...>`` 是一条C++模板指令，写在函数头的前面，这个函数就变成了模板函数。
   * 尖括号里的 ``typename`` 是模板指令的关键字，用来指定这里要使用一个泛型数据类型。
   * 使用 ``template<typename T>`` 指令之后就把紧跟在它后面的那个函数变成了模板函数，这个函数的形参和返回值可以用 ``T`` 来代替以往的数据类型，表示这是一个泛型，函数本身不再限定数据类型。

于是通过这种方式，模板函数 ``max()`` 就实现了适应各种数据类型。如果函数比较复杂，需要写成“声明+定义”的形式，那么在函数声明和后面的函数定义两处都应该加上相同的模板指令。

.. warning::

   值得注意的是，C++模板技术并没有想象中严格，模板函数能否正确运行完全取决于程序员是否传递了不会引起错误的参数值。例如我们的 ``max()`` 函数，能够正确运行的参数类型应该是数值类型。但如果我们传入了两个C字符串：
   
   ``printf("%s is bigger\n", max("abc", "def"));``
   
   程序仍会编译通过，而运行结果八成会告诉我们 ``abc is bigger``。这就不对了，按照字符串比较的规则，明明应该是 ``def`` 更大啊。这就是因为C字符串的比较不能简单地使用 ``<`` 运算，我们的代码本身不适用于比较C字符串。但是C++模板并不会对真正传入的参数类型是否合适进行检验，于是它就一本正经地胡说八道。


C++模板并不限制一个模板函数里的泛型数量，也允许泛型和指定类型混用，所以一个模板函数可以有多个泛型，也可以同时存在指定类型。接下来我们让刚才的 ``max()`` 函数华丽变身为一个更加强大灵活的比较大小函数，它能接受两个不同数据类型的数值进行比较，并且用返回前一个参数的数据类型来返回比较结果，而且我们用一个逻辑参数来指定是用来找较大的那个数还是较小的那个数。

.. literalinclude:: ../codes/140_template_2.cpp
   :language: c++
   :emphasize-lines: 3,4

.. note::

   在这个比较函数的参数表中，最后一个逻辑参数 ``bool max = true`` 这样的写法叫做 *默认值参数*。对于这样的函数，在调用时如果不提供这个参数值，那么就会自动使用参数表里指定的默认值。所以如果我们调用这个函数时省略掉这个 ``max`` 参数，那么它就默认等于 ``true`` 了。使用默认值参数需要注意的是，C++语言允许函数参数里有一个或多个默认值参数，但是它们必须放在参数表的后面。在任何一个默认值参数之后不能出现普通参数。

上面这段程序的运行结果如下：

.. code-block:: none

   3.141593 is bigger
   -3 is smaller


**模板结构：让成员变量可以适应多种数据类型**

模板结构是实现所谓抽象数据类型封装的关键技术，在数据结构的领域里会广泛使用到，C++的STL模板库就大量采用了这种技术。

其实它的用法和模板函数没什么太大的区别，并不复杂。例如我们要实现一个封装好的顺序线性表，最大长度为100个元素，但是我们要求这个顺序表可以用来装载各种不同类型的数据，以免发生要为每一种数据类型分别写一个顺序表的尴尬。有了编写模板函数的经验，写一个模板结构也就不难了，看代码。

.. literalinclude:: ../codes/140_template_3.cpp
   :language: c++
   :emphasize-lines: 6,8,14,22

运行结果：

.. code-block:: none

   sqr(0) = 0
   sqr(1) = 1
   sqr(2) = 4
   sqr(3) = 9
   sqr(4) = 16
   sqr(5) = 25
   sqr(6) = 36
   sqr(7) = 49
   sqr(8) = 64
   sqr(9) = 81
   area of radius 0 circle =   0.00000000
   area of radius 1 circle =   3.14159265
   area of radius 2 circle =  12.56637061
   area of radius 3 circle =  28.27433388
   area of radius 4 circle =  50.26548246
   area of radius 5 circle =  78.53981634
   area of radius 6 circle = 113.09733553
   area of radius 7 circle = 153.93804003
   area of radius 8 circle = 201.06192983
   area of radius 9 circle = 254.46900494

计算了从0到9十个整数的平方以及它们对应半径的圆的面积，分别放在两张顺序表里面，但是封装顺序表的结构体定义只有一个。这就是模板结构的威力。

模板结构的定义方式和模板函数并无二致，只是在使用模板结构来生成具体的结构变量时有所不同。要声明一个模板结构变量，在结构名后面要紧跟一对尖括号，在里面给出和泛型对应的实际数据类型。如果模板结构使用了多个泛型，那么声明变量的时候尖括号里要按顺序依次给出对应的具体类型。

.. code:: c++
   
   template<typename T, typename V>
   struct S {
           T a;
           V b;
   };
   
   S<int, double> s1 = { 10, 3.14159 };


**模板参数：搞定数组作为函数参数时的种种不爽**

（待续）
